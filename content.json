{"meta":{"title":"Ming-Dm blog","subtitle":null,"description":null,"author":"Ming-Dm","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-08-26T06:20:02.644Z","updated":"2018-05-31T09:07:34.692Z","comments":true,"path":"2018/08/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"jQuery宝典","slug":"jQuery宝典","date":"2018-07-26T02:30:45.000Z","updated":"2018-07-26T02:30:45.079Z","comments":true,"path":"2018/07/26/jQuery宝典/","link":"","permalink":"http://yoursite.com/2018/07/26/jQuery宝典/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JSON宝典","slug":"JSON宝典","date":"2018-07-23T06:32:39.000Z","updated":"2018-07-25T02:49:09.109Z","comments":true,"path":"2018/07/23/JSON宝典/","link":"","permalink":"http://yoursite.com/2018/07/23/JSON宝典/","excerpt":"JSON 简介JSON 语法JSON 对象JSON 数组JSON 和 JS 对象相互转换","text":"JSON 简介JSON 语法JSON 对象JSON 数组JSON 和 JS 对象相互转换 JSON 简介1.1 什么是JSONJSON是JavaScript Object Notation的简称，中文含义为“JavaScript 对象表示法”，它是一种数据交换的文本格式，而不是一种编程语言。 JSON 是一种轻量级的数据交换格式，它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 JSON 使用 JavaScript 语法来描述数据对象，请看以下实例：123456&#123; \"social\": [ &#123; \"weibo\": \"https://weibo.com/baiyu\" &#125;, &#123; \"github\": \"https://github.com/zhuyilong\" &#125; ]&#125; 以上这个 social 对象，用来描述作者的社交媒体信息，它是包含 2 个社交媒体对象的数组，一个社交媒体对象是 weibo ，另一个社交媒体对象是 github JSON之所以受欢迎，主要是因为它仍然使用 JavaScript 语法来描述数据对象，并没有改变开发人员的使用习惯，这更容易被开发人员接受。由于这种相似性，JavaScript 程序就无需解析器，便可以直接用 JSON 数据来生成原生的 JavaScript 对象。 1.2 JSON的特点JSON 主要具有以下特性，这些特性使它成为理想的数据交换语言： JSON 是轻量级的文本数据交换格式 JSON 具有自我描述性，更易理解 JSON 采用完全独立于语言的文本格式：JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前常见的动态编程语言（PHP，JSP，.NET）都支持JSON。 JSON 是存储和交换文本信息的一种语法，它与XML具有相同的特性，是一种数据存储格式，却比 XML 更小、更快、 更易于人编写和阅读、更易于生成和解析。 类似于 XML 的特性： JSON 是纯文本 JSON 具有“自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输 相比 XML 的不同之处： 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 请看一个简单实例：12345678910111213141516&lt;html&gt;&lt;body&gt;&lt;p&gt;weibo: &lt;span id=\"weibo\"&gt;&lt;/span&gt;&lt;br /&gt;github: &lt;span id=\"github\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;script type=\"text/JavaScript\"&gt;var JSONObject= &#123; \"weibo\": \"https://weibo.com/baiyu\" , \"github\": \"https://github.com/zhuyilong\"&#125;;document.getElementById(\"weibo\").innerHTML=JSONObject.weibo;document.getElementById(\"github\").innerHTML=JSONObject.github;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中运行以上代码，得到的结果为： weibo: https://weibo.com/baiyugithub: https://github.com/zhuyilong JSON 语法2.1 JOSN 键/值 对JSON键/值对由键和值组成，键必须是字符串，值可以是字符串（string）、数值(number) 、对象（object）、数组（array）、true、false、null。 在定义JSON键/值时，先是键名，后面写一个冒号，然后是值。如： &quot;github&quot;: &quot;https://github.com/zhuyilong&quot;这就等价于这条 JavaScript 语句： github = &quot;https://github.com/zhuyilong&quot; 2.2 JOSN 字符串JSON 的字符串（string）跟C或者Java的字符串非常相似，是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。 由于JSON 字符串不能使用单引号，因此一个字符（character）就是一个单独的字符串（character string）。 2.3 JOSN 数值JSON 数值（number）与C或者Java的数值非常相似，支持整型、浮点型，浮点型也可以用指数表示。 JSON不支持八进制和十六进制， 数值必须以十进制表示，且不能使用NaN和Infinity。以下是合法的JSON数值： { “age”: 30 } 2.4 JOSN 对象JSON 对象是一个无序的key/value对的集合。一个对象以 ‘{‘ 开始，以 ‘}’ 结束；每个key 和 value 中使用冒号分隔；每个 key/value 对之间使用逗号分隔。 JSON 对象语法： JSON 对象在大括号({})中书写。 对象可以包含多个key/value（键/值）对。 key是字符串，必须放在双引号里面。value 可以是合法的 JSON 数据类型（字符串, 数值, 对象, 数组, 布尔值或 null）。 一个 key/value 对内部，key 和 value使用冒号(:)分隔。 key/value 对之间，使用逗号(,)分隔。 JSON 对象可以嵌套 下面就是一个合法的JSON 对象：12345678&#123; \"weibo\": \"https://weibo.com/baiyu\" , \"github\": \"https://github.com/zhuyilong\" , \"qq\": &#123; \"number\": \"123\", \"email\": \"123@qq.com\" &#125;&#125; 2.5 JOSN 数组JSON数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。 JSON 数组： JSON 数组在中括号中书写。 JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数值, 对象, 数组, 布尔值或 null），也可以是 JavaScript 的表达式，包括函数、日期、undefined。 对象的属性值也可以是一个JSON数组。如，以下对象的 sites 属性值是一个包含三个元素的数组：12345&#123; \"name\": \"网站\", \"num\": 3, \"sites\": [ \"Google.com\", \"Taobao.com\", \"baidu.com\" ]&#125; 使用索引值来访问数组的元素。如：1x = myObj.sites[2]; // &quot;baidu.com&quot; JSON数组的元素也可以是对象。如，以下对象 “employees” 是包含三个对象的数组，每个对象代表一条关于某人（有姓和名）的记录：1234567&#123;&quot;employees&quot;: [ &#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;, &#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;, &#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125; ]&#125; 2.6 JOSN 布尔值JSON 布尔值可以是 true 或者 false。如： { “flag”:true } 2.7 JOSN nullJSON 可以设置 null 值。如： { “zhihu”:null } 2.8 JOSN 文件JSON 文件的文件类型是 “.json”JSON 文本的 MIME 类型是 “application/json” JSON 对象3.1 访问 JSON 对象的值可以使用点号（.），或中括号（[]）来访问 JSON 对象的值。 使用点号访问对象时，直接使用对象的 key 来访问， key 无须放在双引号中。如：123456&lt;script&gt; var myObj, x; myObj = &#123; \"github\": \"https://github.com/zhuyilong\" &#125;; x = myObj.github; document.write(x);&lt;/script&gt; 在浏览器中运行，得到运行结果为： https://github.com/zhuyilong使用中括号访问对象时，要把对象的 key 以字符串形式，放在中括号中。也就是说，key 要放在双引号中。如：123456&lt;script&gt; var myObj, x; myObj = &#123; \"github\": \"https://github.com/zhuyilong\" &#125;; x = myObj[\"github\"]; document.write(x);&lt;/script&gt; JSON 对象中，可以包含另外一个 JSON 对象。如，以下代码在 myObj 对象中，嵌套了一个 qq 对象：12345678&#123; \"weibo\": \"https://weibo.com/baiyu\" , \"github\": \"https://github.com/zhuyilong\" , \"qq\": &#123; \"number\": \"123\", \"email\": \"123@qq.com\" &#125;&#125; 你可以使用点号(.)、或者中括号([])来访问嵌套的 JSON 对象：1document.write(myObj.qq.email); 或者：12document.write(myObj[\"qq\"][\"email\"]);document.write(myObj.qq[\"email\"]); 上述三种方法的效果相同，在浏览器中的运行结果都是： `123@qq.com` 3.2 修改 JSON 对象的值你可以使用点号(.)来修改 JSON 对象的值。如：1myObj.zhihu = \"https://www.zhihu.com/people/zhenhun/\"; 你可以使用中括号([])来修改 JSON 对象的值。如：1myObj[\"zhihu\"] = \"https://www.zhihu.com/people/zhenhun/\"; JSON 数组4.1 遍历 JSON 数组你可以使用 for-in循环来遍历数组：123for (i in myObj.sites) &#123; x += myObj.sites[i] + \"&lt;br&gt;\";&#125; 你也可以直接使用 for 循环来遍历数组：123for (i = 0; i &lt; myObj.sites.length; i++) &#123; x += myObj.sites[i] + \"&lt;br&gt;\";&#125; JSON 对象中的数组也可以包含另外一个数组，或者另外一个 JSON 对象：123456789myObj = &#123; \"name\":\"网站\", \"num\":3, \"sites\": [ &#123; \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] &#125;, &#123; \"name\":\"Weibo\", \"info\":[ \"微博\", \"随时随地分享新鲜事\" ] &#125;, &#123; \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] &#125; ]&#125; 可以使用 for-in 来循环访问每个数组：123456for (i in myObj.sites) &#123; x += \"&lt;h1&gt;\" + myObj.sites[i].name + \"&lt;/h1&gt;\"; for (j in myObj.sites[i].info) &#123; x += myObj.sites[i].info[j] + \"&lt;br&gt;\"; &#125;&#125; 4.2 修改 JSON 数组的值可以使用索引值来修改JSON 数组的值。如： myObj.sites[1] = &quot;Github&quot;; 4.3 删除 JSON 数组元素你可以使用delete关键字来删除数组元素。如： delete myObj.sites[1]; JSON 和 JS 对象相互转换JSON的本质是一个字符串，它之所以受欢迎，是因为可以把JSON字符串解析为有用的JavaScript对象。 ECMAScript5中，对解析JSON的行为进行了规范，并定义了一个全局对象JSON，该对象有两个方法：JSON.parse() 和 JSON.stringify()。 5.1 JSON.parse()JSON.parse() 方法，用于把JSON字符串转换为原生的 JavaScript 值或对象。如：12345678JSON.parse('1') // 1JSON.parse('&#123;&#125;') // &#123;&#125;JSON.parse('true') // trueJSON.parse('\"foo\"') // \"foo\"JSON.parse('[1, 5, \"false\"]') // [1, 5, \"false\"]JSON.parse('null') // nullvar o = JSON.parse('&#123;\"name\": \"张三\"&#125;');o.name // 张三 如果传递给JSON.parse()方法的字符串不是有效的JSON格式，JSON.parse()方法将报错。如：1234JSON.parse(\"'String'\")//Uncaught SyntaxError: Unexpected token u in JSON at position 0(…)JSON.parse(\"undefined\")//Uncaught SyntaxError: Unexpected token u in JSON at position 0(…) 除了直接进行字符串转换之外，JSON.parse()方法也可以接收一个函数参数，该函数被称为还原函数。如果提供还原函数，则对象的每个成员都会调用这个函数。 还原函数接收两个参数，一个键和一个值，并返回一个值。如果还原函数返回undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。如：12345678910var o = JSON.parse('&#123;\"a\":1,\"b\":2&#125;', function(key, value) &#123; if (key === '')&#123; return value; &#125; if (key === 'a') &#123; return value + 10; &#125;&#125;);o.a // 11o.b // undefined JSON 不能存储 Date 对象。如果你需要存储 Date 对象，需要将其转换为字符串，之后再将字符串转换为 Date 对象。在将日期字符串转换为Date对象时，经常要用到还原函数。如：1234567891011121314var book = &#123; \"title\": \"javascript\", \"date\": new Date(2018,1,21)&#125;var jsonStr = JSON.stringify(book);console.log(jsonStr)//'&#123;\"title\":\"javascript\",\"date\":\"2018-02-20T16:00:00.000Z\"&#125;'var bookCopy = JSON.parse(jsonStr,function(key,value)&#123; if(key == 'date')&#123; return new Date(value); &#125; return value;&#125;)console.log(bookCopy.date.getFullYear()); //2018 说明：JSON.parse() 和 eval()实际上，eval() 函数的功能类似于 JSON.parse()方法，也可以将json字符串转换为json对象。如：12eval('(' + '&#123;\"a\":1&#125;'+')').a; //1JSON.parse('&#123;\"a\":1&#125;').a; //1 但是，eval() 函数可以执行不符合 JSON 格式的代码。如：12eval('(' + '&#123;\"a\":alert(1)&#125;'+')').a; //弹出1JSON.parse('&#123;\"a\":alert(1)&#125;').a; //报错 在浏览器中运行上述代码，eval() 函数就会弹出 alert 框，而 JSON.parse()方法将会报错。由于 eval() 函数会为恶意代码提供可乘之机，因此应当尽量少使用 eval() 函数，而是使用更安全的 JSON.parse()方法。 5.2 JSON.stringify()JSON.stringify()方法用于把JavaScript值（对象或者数组）序列化为JSON字符串，并返回序列化后的JSON字符串。调用格式为：1JSON.stringify(value[, replacer[, space]]) 参数： value: 必需。将要序列化为JSON 字符串的值。 replacer: 可选。用于替换结果的函数、或仅包括指定的属性数组。 space: 可选。用于文本添加缩进、空格和换行符。 序列化规则序列化的本质，就是按照 JSON 的语法规则，把 JavaScript 值（对象或者数组），转换为 JSON 字符串，以方便存储和数据交换。 1）数值、布尔值、字符串的包装对象，会转换成对应的原始值。如：1234JSON.stringify(1) // \"1\"JSON.stringify(false) // \"false\"JSON.stringify('abc') // \"\"abc\"\"JSON.stringify([1, \"false\", false]) // '[1,\"false\",false]' 2）键和值都被序列化，如果键名没有引号，会自动为它添加引号。如：12JSON.stringify(&#123;x: 5, y: 6&#125;); // \"&#123;\"x\":5,\"y\":6&#125;\"JSON.stringify(&#123;name: \"张三\"&#125;) // '&#123;\"name\":\"张三\"&#125;' 3）数组，会转换成数组格式。如：12JSON.stringify([]) // \"[]\"JSON.stringify([1, \"false\", false]) // '[1,\"false\",false]' 4）对象，会转换成对象格式。如：12JSON.stringify(&#123;&#125;) // \"&#123;&#125;\"JSON.stringify(&#123;x: 5, y: 6&#125;); // \"&#123;\"x\":5,\"y\":6&#125;\" 5）正则表达式和数学对象，转换成空对象的字符串形式。如：12JSON.stringify(/foo/) // \"&#123;&#125;\"JSON.stringify(Math) // \"&#123;&#125;\" 6）日期对象和包装对象，转换成字符串。如：1234JSON.stringify(new Boolean(true)) //\"true\"JSON.stringify(new String('123')) //\"\"123\"\"JSON.stringify(new Number(1)) //\"1\"JSON.stringify(new Date()) //\"\"2016-09-20T02:26:38.294Z\"\" 7） 如果非数组对象的成员是undefined、或任意的函数、或 symbol 值，这个成员会被省略。如果数组对象的成员是undefined、或任意的函数、或 symbol 值，则这些值被转成null。如：123456JSON.stringify(&#123; a: function()&#123;&#125;, b: undefined, c: [ function()&#123;&#125;, undefined ]&#125;);// \"&#123;\"c\":[null,null]&#125;\" 8）不可枚举的属性，会被忽略。如：123456var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'foo': &#123; value: 1, enumerable: true &#125;, 'bar': &#123; alue: 2, enumerable: false &#125;&#125;);JSON.stringify(obj); // \"&#123;\"foo\":1&#125;\" 9）所有以 symbol 为键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。如：123456789JSON.stringify( &#123;[Symbol.for(\"foo\")]: \"foo\"&#125;, function (k, v) &#123; if (typeof k === \"symbol\")&#123; return \"a symbol\"; &#125; &#125;);// undefined replacer参数replacer参数可以是一个函数或者一个数组。 1）函数 如果replacer参数是一个函数，则对象的每个成员都会调用这个函数。该函数接收两个参数，一个是键（key），一个是值（value），执行序列化时，键和值都会被序列化。如：1234567function dobule(key, value)&#123; if (typeof value === \"number\") &#123; value = 2 * value; &#125; return value;&#125;console.log(JSON.stringify(&#123;a:1,b:2&#125;, dobule())); // \"&#123;\"a\":2,\"b\":4&#125;\" 如果replacer函数返回的是一个对象，则该对象被递归地序列化成JSON字符串，并且允许键为空。如：12345var jsonObj = &#123;a: &#123;b: 1&#125;&#125;;JSON.stringify(jsonObj, function(key, value) &#123; console.log(\"[\"+ key +\"]:\" + value); return value;&#125;); 上述代码中，对象 jsonObj 一共会被 function函数处理三次。第一次键名为空，键值是整个对象 jsonObj；第二次键名为 a，键值是 {b:1}；第三次键名为 b，键值为 1。运行结果为：123[]:[object Object][a]:[object Object][b]:1 如果replacer函数返回了undefined或没有返回值，那么相应的属性会被忽略，这种情况将不会被序列化成JSON字符串。如：123456JSON.stringify(&#123; a: \"abc\", b: 123 &#125;, function (key, value) &#123; if (typeof(value) === \"string\") &#123; return undefined; &#125; return value;&#125;) 上述代码得到的结果为：1&apos;&#123;&quot;b&quot;: 123&#125;&apos; 2）数组 如果replacer是一个数组，数组的值代表将被序列化成JSON字符串的属性名。执行序列化时，则只对数组中所列举的键执行序列化操作，就相当于实现一个过滤器的功能。如：12345678var jsonObj = &#123; \"title\":\"javascript\", \"group\":&#123; \"a\":1, \"b\":2 &#125;&#125;;console.log(JSON.stringify(jsonObj,[\"group\",\"b\"])) 上述代码的运行结果为：1&#123;&quot;group&quot;:&#123;&quot;b&quot;:2&#125;&#125; 需要特别说明的是，过滤器功能只适用于对象，对数组无效。如，12var jsonObj = [1,2];console.log(JSON.stringify(jsonObj,[\"0\"])); // \"[1,2]\" space参数默认情况下，JSON.stringify() 输出的JSON字符串不包括任何空格字符或缩进。如：123456789var jsonObj = &#123; \"title\":\"javascript\", \"group\":&#123; \"name\":\"jia\", \"tel\":12345 &#125;&#125;;JSON.stringify(jsonObj);//&#123;\"title\":\"javascript\",\"group\":&#123;\"name\":\"jia\",\"tel\":12345&#125;&#125; 通过指定space参数，可以在JSON字符串中添加空格或字符串，用于增加返回的JSON字符串的可读性。space参数的值可以是数值或字符串。 1）数值 如果space参数的值是数值，则序列化的字符串中，每一级别会比上一级别缩进指定数目的空格（不超过10个空格）。如：1console.log(JSON.stringify(&#123; p1: 1, p2: 2 &#125;, null, 2)); 上述代码得到的结果为：1234&#123; &quot;p1&quot;: 1, &quot;p2&quot;: 2&#125; 2）字符串 如果space参数的值是字符串（字符串不超过10个字符），则序列化的字符串中，每一级别会比上一级别的缩进，使用该字符串填充。如：1console.log(JSON.stringify(&#123; p1:1, p2:2 &#125;, null, &apos;|-&apos;)); 上述代码得到的结果为：1234&#123;|-&quot;p1&quot;: 1,|-&quot;p2&quot;: 2&#125; 注意：在序列化一个对象时，如果该对象拥有 toJSON()方法，那么该 toJSON() 方法就会覆盖该对象默认的序列化行为: 被序列化的不是那个原始对象，而是调用 toJSON() 方法后返回的那个对象。如：12345678var obj = &#123; foo: &apos;foo&apos;, toJSON: function () &#123; return &apos;bar&apos;; &#125;&#125;;JSON.stringify(obj); // &apos;&quot;bar&quot;&apos;JSON.stringify(&#123;x: obj&#125;); // &apos;&#123;&quot;x&quot;:&quot;bar&quot;&#125;&apos; 如果 toJSON()方法返回 undefined，此时如果包含它的对象嵌入在另一个对象中，会导致该对象的值变成 null。而如果包含它的对象是顶级对象，结果就是 undefined。Date 对象部署了一个自己的 toJSON()方法，它会自动将 Date 对象转换成日期字符串。如：12JSON.stringify(new Date(\"2017-12-29\"))// \"2017-12-29T00:00:00.000Z\"","categories":[],"tags":[{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"CSS宝典","slug":"CSS宝典","date":"2018-07-21T14:32:47.000Z","updated":"2018-07-25T03:49:48.177Z","comments":true,"path":"2018/07/21/CSS宝典/","link":"","permalink":"http://yoursite.com/2018/07/21/CSS宝典/","excerpt":"CSS基础CSS选择器字体和文本盒模型元素的定位链接和导航表格和表单变换、过渡和动画布局解决跨浏览器问题","text":"CSS基础CSS选择器字体和文本盒模型元素的定位链接和导航表格和表单变换、过渡和动画布局解决跨浏览器问题 CSS基础1.1 CSS简介1.1.1 认识CSSHTML 标签的初衷是用于定义文档的内容，而不用关注文档的布局，布局交由浏览器来完成。然而，当时的两大主流浏览器（Netscape和IE）不断地将新的 HTML 标签和属性（如字体标签和颜色属性等）添加到 HTML 规范中。使文档的内容和表现（布局、字体、颜色、背景等）完全耦合在一起，对网页表现的任何修改，都必须修改网页的内容，造成站点的维护越来越困难。 为了解决此问题，万维网联盟（W3C）肩负起了 HTML 标准化的使命，并在 HTML 4.0 之外创造出CSS，让CSS来控制网页的外观，让HTML继续回到最拿手的老本行——为内容提供结构。 有了CSS，你再也不必担心HTML中的 h1 的字体是否过大，也不必担心无序列表的间隔是否合适，因为这些都可以在稍后用CSS进行调整。你只需集中精力用HTML来组织网页的内容，而如何使内容看起来更美观，就完全交给CSS来完成。 CSS是Cascading Style Sheet的简称，中文含义为“层叠样式表”，简称“样式表”，是用来控制如何显示HTML元素的一种样式设计语言，简单的说，就是告诉浏览器如何渲染网页。 CSS是一项出色的技术，它使得网页的表现与内容完全分离，可以称得上WEB 设计领域的一个重大突破。CSS使得网站维护工作变得更容易，不会因为内容的改变而影响表现，也不会因为表现的改变而影响内容。 CSS不需要编译，直接由浏览器解释执行。网站开发者只需为HTML 元素定义样式，并应用到所希望的任意页面。如需进行全局更新，只需简单地改变样式，网站中的所有元素均会自动更新，而不必对HTML代码做任何修改，使开发效率得到极大的提高。 1.1.2 CSS简史为了是网页在视觉是可以得到更好的表现，W3C负责CSS标准的制定和推动。CSS经历了CSS1、CSS2、 CSS2.1、CSS3，CSS3是正在进行中的标准。 1996年12月17日，CSS1正式推出，到了1999 年1月11日，该推荐标准被重新修订。CSS1中主要定义了具体的颜色、字体、文本样式、外边距、边框、背景等最基本的样式。 1998年5月12日，CSS2正式推出，它定义了许多高级特性（如，浮动和定位）以及一些高级的选择器（如，子选择器、相邻同胞选择器、通用选择器）。 2004年2月，CSS2.1正式推出，它在CSS2的基础上略微做了改动，并删除了浏览器厂商从未支持的功能。现代浏览器基本上都完全支持CSS2.1，但是低于IE8的IE还有一些遗留问题。 自从1998年推出CSS2以来，在这 10 多年间，可以说CSS基本没有太大的变化。直到 2010 年，终于推出了一个全新的版本CSS3。 CSS3是CSS规范的最新版本，不过，CSS3的标准化工作还在继续进行着。CSS3从IE、Flash等技术中吸收和借鉴了很多优点，并在CSS2.1的基础上增加了很多强大的功能解决了一些现实的问题，如对圆角、多背景、阴影、动画等提供原生支持。 由于CSS3结构相当庞大，因此，它不再采用总体结构，而是采用分工协作的模块化结构。CSS3被划分为多个模块，每个模块都可以独立发布和实现，这样做的好处是可以加快标准化的进程，避免因某个模块的小问题，而影响整个标准的完成进度。 更详细的信息参见 https://www.w3.org/Style/CSS/current-work.en.html，其中介绍了CSS3具体划分为多少模块组、CSS3所有模块组的当前状态，以及将在什么时候发布。 1.2 CSS开发环境1.2.1 编辑工具CSS文件是纯文本文件，可以使用任何文本编辑器来编辑。常用的文本编辑器有记事本、写字板、UltraEdit32、EditPlus、NotePad++等等，笔者首选 EditPlus 和 NotePad++。因为它们的功能都非常强大，并且启动速度快、界面简洁，可以无限制的撤消与重做，具有语法高亮、英文拼字检查、查找替换（支持正则表达式）、自动换行、列数标记、多文档编辑等功能。 当然，你也可以使用一些专业的所见即所得的CSS 编辑器，如Dreamweaver等，这完全取决于你的个人喜好。不过，手工编写代码有以下好处： 可以加深记忆，输入次数多了，所有属性自然烂熟于心。久而久之，便可信手拈来、挥洒自如。熟能生巧就是这个道理。 手工编写没有工具提醒，错误在所难免，排查错误的过程，就是成长的过程。而且，犯错越多，成长就越快，错误越离谱，印象就越深刻，错误越难解决，收获就越大。 手工编写代码的过程，也是思考的过程，更有助于加深理解。理解越深，开发起来就越得心应手、左右逢源。有助于使你快速成为一名专业的Web设计师。 手工编写的每一行代码都是有用代码，而所见即所得编辑器常常会产生大量冗余代码，给后期维护带来极大不便。1.2.2 预览工具绝大多数浏览器对CSS都有很好的支持，设计师不必担心其设计的CSS不被浏览器所支持。 而在实际开发中，最让设计师头痛的是各个浏览器对新标准的支持程度，以及在CSS细节上的处理差异。经常出现的情况是，在一种浏览器中设计的效果，在另一个浏览器中并没有像预期的那样显示。因此，页面开发完成后，应该在一个或多个平台的几种浏览器下对网站进行充分测试，查看页面是不是按照预期的方式工作。 你并不知道用户使用哪种浏览器，因此在不同的浏览器中进行测试是非常必要的。常见的浏览器有IE、Google Chrome、Firefox、Opera、Safari等。由于Google Chrome、Firefox、Opera、Safari、IE10+ 等浏览器被称作现代浏览器，因为它们出现较晚，并且能够理解和支持HTML5、CSS3、ECMAScript、W3C DOM 等这些较新的标准。 使用HTML5和CSS3制作的网页，在所有现代浏览器中的渲染效果基本一致，而在老的IE中，不同版本的渲染效果差别较大，而老的IE仍然占有很大的市场份额。因此，为了确保网站尽可能适用于绝大多数的用户，毫无疑问，你需要在IE的各个版本中测试你的设计。 然而，IE版本众多，安装这么多版本，并在众多版本间进行切换，也是令人头疼的问题。令人欣慰的是，IE Tester可以使该问题迎刃而解。 IE Tester是一款完全免费的工具，使用它可以在一台机器上同时运行多个IE版本，并在IE11，IE10，IE9，IE8，IE7，IE6 和 IE5.5版本间自由切换，支持XP、Vista、Win7~Win10 等，是测试网页在IE不同版本中表现的不可多得的工具。 1.3 CSS语法1.3.1 样式规则语法样式规则是CSS的基本单位，每个样式规则由选择器（selector）和声明块（declaration block）两个基本部分构成。 选择器决定为哪些元素应用样式，声明块定义相应的样式。声明块包裹在一对花括号中。声明块由一条或多条声明（declaration）组成，每条声明由一个属性和一个值组成，属性和值之间用冒号隔开。属性是希望设置的样式属性，每个属性有一个值。 具体来讲，一个样式规则由选择器、属性和值这 3 部分构成。格式如下：1selector &#123; property: value; &#125; 为了全面描述一个元素的样式，通常需要指定多个属性，每个属性就需要一条声明，多条声明之间用分号隔开（最后一条声明可以省略分号）。如：1h1 &#123; color: red; font-size: 14px &#125; 上述样式规则中，h1 是选择器，其中包含两条声明。第一条声明中，color 是属性， red是 color 属性的值；第二条声明中，font-size 是属性，14px 是 font-size 属性的值。 一个样式规则中包含多条声明时，声明的顺序并不重要，并且多条可以在一行内书写，也可以在多行内书写。为了阅读方便，建议一行只写一条声明，一般是将选择器和左大括号放在第一行，然后一条声明写一行，右大括号则单独放在最后一行。由于浏览器会忽略样式规则中的所有空格和跳格，建议使用空格或跳格为每条声明增加缩进，并在冒号和属性值之间增加一个空格。如：1234h1 &#123; color: red; font-size: 14px;&#125; 在定义属性时，如果属性的值由多个单词组成，单词之间存在空格，则必须把属性值放在引号中。引号既可以是单引号，也可以是双引号。如：123p &#123; font-family: 'Times New Roman';&#125; 本样式规则中，font-family属性的值为Times New Roman，由于该值是多个单词组成，所以加上了引号。 某些经常在一起使用的样式属性，可以组合起来使用一个特殊的复合属性。复合属性中，属性会包含多个值，值之间需要使用空格隔开。 如，描述边框的border-width、border-style、border-color属性，就可以使用复合属性 border 来一次性设置完成。123img &#123; border: 1px solid blue;&#125; CSS对所有的属性和值都有严格要求，如果声明的属性名称在CSS规范中不存在，或者属性的值不符合该属性的要求，则该声明就不会生效。 1.3.2 CSS注释语法CSS注释，只不过是用“/*”和“*/”包围起来的内容。注释的内容不会被浏览器读取或执行，而它确为你提供了有益的提示。 如果CSS文件非常长，那么寻找特定的样式会很困难。一种改进方法是使用大的注释块，来把CSS文件分隔成多个逻辑部分，并在注释块的头部添加一个标志。这样，搜索这个标志和注释头中的前几个字母，就可以立即找到要寻找的部分。 /*———— @ reset ————*//*———— @ general ———-*//*———— @ hack ————-*/ 1.4 CSS属性的值CSS中，每个属性可以接受哪些值都有不同的规定，有的属性只能接受预定义的值，有的属性接受数字、长度、百分数、URL或颜色，有的属性还可以接受多种类型的值。 1.4.1 数字CSS中有两类数字：整数和浮点数。只有极少数的CSS属性接受不带单位的数字，最常见的就是 line-height、z-index、opacity，如line-height: 1.5。 跟数学中的数字一样，整数和浮点数都可以是正数或负数。因此，以下都是合法的数值：12、1.5、-20。不过，一般情况下，一个属性会限制数字的取值范围，如果超出了这个访问，则该声明无效，浏览器会忽略该声明。 1.4.2 长度长度必须包含数字和长度单位，并且它们之间不允许出现空格。数字可以是整数或小数，可以是正数或负数。如果数字为0，则可以带单位，也可以不带。因此，以下都是合法的长度值：1.5em，-20px，0。 CSS的长度单位分为绝对长度单位和相对长度单位。使用绝对长度单位时，其值是一个固定的值；使用相对长度单位时，其长度值不是固定的，它会随着参考值的变化而变化。 常用的绝对长度单位有pt（点）、mm（毫米）、cm（厘米）、in（英寸），pt是一个标准印刷度量单位，一英寸是72 点，即 1pt = 1/72inmm、cm、in 这几个长度单位，大家已经很熟悉，不再赘述。 共有 3 种相对长度单位：em、ex 、px，前两个分别代表 “m-height” 和 “x-height”，即字母 m 的高度和字母 x 的高度，是常见的印刷度量单位。 px代表“像素”，实际上就是计算机屏幕上的一个点。像素被定义为相对定位，是因为它取决于显示器的分辨率。一旦分辨率确定，设置为px的尺寸就成为固定尺寸，不会自动缩放。 em是一个相对长度单位，1em被定义为一种给定字体的 font-size 值。如果一个元素的font-size 为 14px，那么对于该元素，1em 就等于 14px。当 em 用于设置元素的 font-size 属性本身时，em 的值会相对于父元素的字体大小。显然，em的值会随元素的不同而发生变化，这给计算带来极大的困难。于是，就产生了rem这个相对单位，它是相对于根元素（即html元素）的字体大小。由于根元素的字体大小始终不变，计算起来就容易多了。 ex是一个相对长度单位，1ex被定义为一种给定字体的小写字母“x”的高度。因此，这个值会随字体的不同而变化。然而，很多浏览器都没有内置 ex 高度值，只是简单的取 em 的值，再取其一半作为 ex 的值。所以，一般不推荐使用 ex 这个长度单位。 随着响应式Web设计的流行，px已经无法跟上时代的脚步。%、em、rem这几个能够自适应的相对长度单位开始流行。 1.4.3 百分数百分数由一个数字和一个百分号组成，数字和百分号之间，不允许出现空格。百分数可以是整数或小数，可以是正数或负数。如果数字为0，则可以省略百分号。 百分比的值几乎总是相对于另一个值（如长度单位）计算得到的。每一个允许使用百分比单位的属性，都要定义百分比的参考值。大多数情况下，百分比的参考值都是元素本身的字体大小，即 font-size 属性的值。如：1234div &#123; font-size: 14px; line-height: 200%;&#125; 由于 line-height 属性是基于当前元素 font-size 的值计算得到的。上述代码就表示，line-height 属性的值为font-size属性值的 200%，故得到的行高为 200% * 14px = 28px。 CSS中，所有可继承的属性，如果其属性值使用百分比单位来定义，则子元素继承的是计算后的结果，而不是百分比的值。所以，上述代码中，无论子元素 font-size 的值是多少，子元素的行高始终是28px。 1.4.4 颜色在CSS中，使用 color 属性来定义元素中文本的前景色，使用 border-color 属性来定义元素边框的前景色，使用 background-color 属性来定义元素的背景色。 在CSS1中，定义了2种表示颜色的方式：预定义颜色名和RGB颜色。CSS3开始支持HSL颜色模式，借助人性化的HSL颜色模式，Web设计师可用更直观的定义所需要的颜色，并能很轻松的控制网页中的颜色变化。 预定义颜色名称在CSS1中，预定义了 17 种颜色名称，分别为aqua（水绿色）、black（黑色）、blue（蓝色）、fuchsia（紫红色）、gray（灰色）、green（绿色）、lime（绿黄色）、maroon（紫酱色）、navy（藏蓝色）、olive（橄榄色）、orange（橙色）、purple（紫色）、red（红色）、silver（银灰色）、teal（蓝绿色）、white（白色）、yellow（黄色）。也可以使用关键字transparent，表示透明。 RGB颜色从物理光学试验中得出结论：通过对红、绿、蓝这三种单色以不同比例的混合，几乎可以得出自然界所有的颜色，这就是所谓的RGB颜色模式。 RGB颜色模式中，通过 R、G、B 的值表示颜色，并通过 R、G、B 分量的变换和叠加，来得到各种各样的颜色。其中，R 为红色分量，G 为绿色分量，B 为蓝色分量，并为每个分量分配一个从 0 到 255的强度值，数值越大就越白，数值越小就越黑。 在CSS中，RGB颜色有 3 种表示方法：十六进制表示法、数字表示法、百分比表示法。 1）数字表示法 数字表示法，就是直接用 0 ~ 255 之间的数字表示RGB颜色，格式为RGB(R, G, B)。 可以把RGB颜色想象为由红、绿、蓝三盏灯发出三束光，当三束光叠加在一起就产生了白色，当三盏灯的亮度都减半就产生了灰色，当三盏灯都关掉就会一片漆黑了。得到相应的RGB颜色为：白色RGB(255, 255, 255)，灰色RGB(127, 127, 127)，黑色RGB(0, 0, 0)。 如果关掉绿灯和蓝灯，只亮红灯，那么只会看到一片红色，即红色RGB(255, 0, 0)；如果只亮绿灯，就只会看到绿色，即绿色RGB(0, 255, 0)；如果只亮蓝灯，就只会看到蓝色，即蓝色RGB(0, 0, 255)。 关掉其中一盏灯，用其它两盏灯的光线叠加，则蓝 + 绿 = 青，红 + 蓝 = 洋红，红 + 绿 = 黄，即青色 RGB(0, 255, 255)，洋红色 RGB(255, 0, 255)，黄色 RGB(255, 255, 0)。 2）百分比表示法 百分比表示法，就是用0.0% ~ 100.0% 之间的百分比表示RGB颜色，0 对应 0.0%，255 对应 100.0%。 3）十六进制表示法 十六进制表示法，即HEX表示法，就是将这些数字值转化为十六进制，再将它们合并到一起，并在前面加一个井号（#），格式为 #RRGGBB。 其中，RR为红色分量，GG为绿色分量，BB为蓝色分量，均为两位十六进制正整数，也就是用十六进制的0x00 ~ 0xff，来表示十进制的 0 ~ 255，但三个数字之间不能有空格、逗号或任何其他分隔符。如，十六进制表示法 #59007f 。 对于 #59007f，十六进制的59、00、7f，分别等于十进制的89、0、127。十六进制表示法中，字母不区分大小写，7f 和 7F都是允许的，推荐使用小写字母。 当十六进制的数值是由三对重复的数字组成时， #RRGGBB 就可以简写为 #RGB。如，# ff00ff 可简写为 #f0f，#cc9966 可以简写为 #c96。这也是推荐的写法，因为没有理由让代码无谓地变长。 上述 3 种表示方法，只是RGB颜色的不同表示形式而已，其作用是等价的，它们之间可以相互转换。如，RGB(255, 255, 255) = RGB(100%, 100%, 100%) = #ffffff = #fff。 常见的预定义颜色名称对应的HEX值及RGB值见表 颜色名称 HEX值 RGB值 RGB百分比 black #000 rgb(0,0,0) rgb(0%,0%,0%) silver #c0c0c0 rgb(192,192,192) rgb(75%,75%,75%) gray #808080 rgb(128,128,128) rgb(50%,50%,50%) white #fff rgb(255,255,255) rgb(100%,100%,100%) red #f00 rgb(255,0,0) rgb(100%,0%,0%) purple #800080 rgb(128,0,128) rgb(%,0%,%) green #008000 rgb(0,128,0) rgb(0%,50%,0%) yellow #ff0 rgb(255,255,0) rgb(100%,100%,0%) HSL颜色HSL颜色模式，是工业界的一种颜色标准，通过对色相（H）、饱和度（S）、亮度（L）三个颜色通道的变化，以及它们之间的相互叠加来获得各种颜色，它几乎包括了人类视力所能感知的所有颜色，是目前应用最广的颜色系统之一。 使用HSL颜色模式定义颜色的语法格式为HSL(H, S, L)，其中： H（Hue）分量，指的是颜色的色相，代表的是人眼所能感知的颜色范围，这些颜色分布在一个360°的色相环上，每个角度代表一种颜色。色相值的意义在于，在不改变光感的情况下，通过旋转色相环来改变颜色。在实际应用中，只需记住色相环上的六大主色，它们在色相环上按照60°圆心角的间隔排列，0°红、60°黄、120°绿、180°青、240°蓝、300°洋红。 S（Saturation）分量，指的是颜色的饱和度，用 0% ~ 100% 的值来控制相同色相和亮度下颜色纯度的变化。0% 表示灰色，100% 表示完全饱和。数值越大，颜色中的灰色越少，元素越鲜艳。 L（Lightness）分量，指的是颜色的亮度，用 0% ~100% 的值来控制颜色的明暗变化。数值越小，颜色越暗，越接近于黑色，到 0% 就成了黑色；数值越大颜色越亮，越接近于白色，到 100% 就成了白色。 在使用HSL颜色模式表示颜色时，只需选择一个0 到360 之间的色相，并将饱和度设为100%，亮度设为50%，就会得到这种颜色最纯的形式。降低饱和度，颜色就会向灰色变化。增加亮度，颜色就会向白色变化；减少亮度，颜色就会向黑色变化。 如，沿着圆环移动的过程中，就可以得到以下比较重要的颜色：红色为 hsl(0, 100%, 50%)；黄色为 hsl(60, 100%, 50%)；绿色为 hsl(120, 100%, 50%)；青色为 hsl(180, 100%, 50%)；蓝色为 hsl(240, 100%, 50%)；洋红色为 hsl(300, 100%, 50%)。 透明通道和透明度适当的使用透明度，可以让设计效果更加丰富多彩。对于相互重叠的元素，可以为元素设置透明度，让元素呈现出半透明效果，使其下方的元素可见。 在CSS3出现之前，只能通过浏览器的某些特殊属性，来实现元素的透明度效果，如IE8 以及更早的版本使用 filter 属性来替代。假如要弹出一个告警框，它会覆盖在现有文档上面，通过使用 filter 属性，就可以使其下方的内容依然可见：123alert &#123; filter: alpha(opacity = 50);&#125; 在CSS3中，可以通过 alpha 透明通道和 opacity 属性，来设置元素的透明度。它们都是浮点数，取值在 [ 0.0 ~1.0 ] 之间，值越接近0，颜色就越透明。如果设置为0.0，就会完全透明，就像没有设置任何颜色。类似的，1.0 就表示完全不透明，默认值为1.0。 alpha 透明通道是一个 8 位的灰度通道，该通道用 256 级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域，其中黑表示透明，白表示不透明，灰表示半透明。 opacity 属性可以单独使用，而 alpha 透明通道则要作为RGB或HSL颜色模式的 alpha分量来使用。支持 alpha 透明通道后，RGB就成为 RGBA，格式为RGB(R, G, B, A)，HSL就成为HSLA，格式为HSLA(H, S, L, A)。 当 A 的值等于 1 时，RGBA与RGB的效果相同，HSLA与HSL的效果相同。在任何使用颜色的地方都可以使用RGBA或HSLA颜色，如背景、边框、文本颜色等。如：1background-color: rgba(255, 76, 76, 0.9); /* 10% 透明 */ 应用透明度的经典案例是按钮的淡入淡出效果，其基本原理是，按钮的原始透明度为某个值，当鼠标悬停到按钮上时，将按钮背景的透明度缓慢地变为另外一个值，当鼠标移出按钮后，再把背景透明度恢复到原始值。 本例分别使用 opacity 属性和 alpha 透明通道，来实现按钮的淡入淡出效果。代码如下：12345678input[type = submit] &#123; color: #fff; font-size: 14px; padding: 6px 30px; border-radius: 3px; border: 1px solid #f00; background-color: rgb(255, 76, 76);&#125; 1&lt;input type = \"submit\" value = \"提 交\"/&gt; 可以使用 opacity 属性设置透明度：1234input[type = submit]:hover &#123; opacity: 0.9; transition:all rase-in 0.2s; /* 缓慢改变透明度 */&#125; 也可以使用alpha透明通道设置透明度：1234input[type = submit]:hover &#123; transition: all ease-in 0.2s; /* 缓慢改变透明度 */ background-color: rgba(255, 76, 76, 0.9);&#125; 从上述代码可以看出，opacity 属性和 alpha 透明通道稍微有点不同，可以根据需要选择使用。opacity 设置的透明度会对整个元素产生影响（元素的内容也会透明），而使用RGBA或HSLA则可以让元素的某些部分有透明效果。所以，如果希望一个元素带有透明的背景、边框、盒阴影等，但内部的文字仍然不透明，就可以使用RGBA或HSLA。 为IE6、IE7、IE8提供备用颜色值在CSS中，可以使用预定义的颜色名、十六进制数值、RGB值、RGB百分比、RGBA值、HSL值、HSLA值中的任意一种值来声明元素的文本颜色、边框颜色、背景颜色等。这些颜色值都是字符串类型，并且不区分大小写。如：1234567color: black; /* 预定义的颜色名 */color: #000; /* 十六进制数值 */border-color: RGB(0, 0, 0); /* RGB值 */border-color: RGB(100%, 0%, 0%); /* RGB百分比 */background-color: RGBA (80, 80, 80, 0.6); /* RGBA值，40% 透明 */background-color: HSL (300, 90%, 50%); /* HSL值 */background-color: HSLA(300, 90%, 50%, 0.8); /* HSLA值，20% 透明*/ 需要注意的是，由于IE9以下的版本并不支持RGBA、HSL和HSLA颜色，因此，如果需要针对这些浏览器提供备用的颜色声明，则要放在RGBA、HSL和HSLA值之前。如：1234div &#123; background-color: #fe0208; background-color: hsl(359, 99%, 50%);&#125; 1.4.5 URIURI是Uniform Resource Identifier的缩写，表示统一资源标识符，是一个用于标识某一互联网资源名称的字符串。该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。 Web上可用的每种资源，如HTML文档、图像、视频片段、程序等，都由一个通用资源标识符进行定位。 在CSS属性中，使用功能符号 url 来定义一个URI，为网页提供一个图像、视频及浏览器所支持的任何资源。其格式是在 url 后跟一对小括号，小括号中为 URI 的值，如：1url(protocol://server/pathname) 其中，url 和开始括号之间不能有空格，而开始括号的后面，及结束括号的前面，既可以有空格，也可以没有。URI值的两侧，既可以加引号，也可以不加。但是，URI值中包含空格时，必须加引号。加引号时，既可以使用单引号，也可以使用双引号。URI中，如果包含括号、逗号、单引号、双引号等特殊字符，则必须使用反斜杠进行转义，如 ‘(‘，’)‘，’\\,’。 上述这种方式定义了一个绝对URI。这里的绝对是指，无论这个URI放在哪里，它都能正常工作，因为它定义了Web空间中的一个绝对位置。假设在一个名为 www.baidu.com 的Web服务器，该服务器是有一个名为 images 的目录，在这个目录中有一个图像logo.jpg。这种情况下，该图像的绝对URI将是： url(http://www.baidu.com/images/logo.jpg)； 不管这个URI放在哪里，它都是合法的，而不论包含这个URI的页面是在服务器 www.baidu.com 上，还是在 www.bilibili.com 上。 另一种URI是相对URI，之所以如此称呼，是因为它指定的是一个相对于该URI所在文档的位置而言的。 在CSS中使用相对路径时，URI是相对于样式表的位置，而不是要应用样式的HTML文件的位置。如：123body &#123; background: url(image.jpg);&#125; 上述代码就表示，使用图像 image.jpg 作为网页的背景图像，图像文件和css 文件位于相同的目录。 URI、URL和URNURI ：Uniform Resource Identifier，统一资源标识符；URL：Uniform Resource Locator，统一资源定位符；URN：Uniform Resource Name，统一资源名称。其中，URL,URN是URI的子集。Web上地址的基本形式是URI,它代表统一资源标识符。有两种形式：URL：目前URI的最普遍形式就是无处不在的URL或统一资源定位器。URN：URL的一种更新形式，统一资源名称(URN, Uniform Resource Name)不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。URI是以某种统一的（标准化的）方式标识资源的简单字符串。 1.4.6 时间CSS中的时间，主要用来指定语言元素的延迟、动画或过渡的延迟、动画或过渡的持续时间等。时间不能为负值。 时间可以表示为秒（s），也可以表示为毫秒（ms）。秒和毫秒之间可以进行换算，换算公式为 1s = 1000ms。因此，0.1s 和 100ms 是等价的。 1.4.7 角度CSS中，有 4 种表示角度的单位：度（deg）、弧度（rad）、圈（turn）、梯度（grad）。角度允许为负值。 一个圆周总是等于 360 度、或 2π 弧度、或 1 圈、或 400 梯度。所以，90 度就可以声明为 90deg、或1.57rad或0.25turn、或100grad。 无论使用哪种单位进行声明，角度的值都会解释为 0 ~ 360 度范围内的度数。所以，720deg 等同于0deg，-90deg 等同于 270deg。 但是，需要特别注意，这里只表示最终得到值相同，而有时候，它们的意义和效果却完全不同。如，在为一个元素定义过渡效果时，如果指定transform: rotate(720deg)，元素会顺时针旋转两周，如果指定transform: rotate(0deg)，元素却不发生旋转。 1.5 样式表1.5.1 外部样式表外部样式表，是在网页外部的样式表文件中定义的样式。由于这些样式并不是HTML文档的一部分，而是在HTML文档的外部独立存在，故称外部样式表。 链接外部样式表在HTML文档头部，使用 link 元素来链接外部的CSS文件。link 元素为空元素，它只有开始标签，没有结束标签，要在开始标签的结尾处加上 / 来结束该元素。 在 link 元素中，通过rel 属性来定义本HTML文档与被链接文档之间的关系，rel = “stylesheet” 表明引入的文件是样式表；通过 href 属性定义样式表文件的URL，可以使用相对路径，也可以使用相对路径，相对路径是相对于本HTML文档而言的。如：12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;链接样式&lt;link rel=\"stylesheet\" href=\"style.css\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上述代码表示，为本文档引入文件名称为 style.css 的外部样式表，该样式表文件与本HTML文档位于相同目录下。 一个页面可以包含多个 link 元素，浏览器会加载多个样式表，合并它们的规则，将其全部应用于页面。但是，加载样式表会影响页面的加载速度。 导入外部样式表也可以在HTML文档头部的 style 元素中，使用 @import 指令导入一个外部样式表文件。如：123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;导入样式&lt;style&gt;@import url(style.css);&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这种方式是通过 @import 指令，把外部样式导入到当前页面。一个文档中，也可以包含多个，来导入多个样式表。 由于 @import 指令效率低下，不但会增加额外的请求次数，还会导致不可预料的问题，故不推荐使用。因此，对于大多数情况，还是推荐使用链接外部样式表的方式。 外部样式表非常适合给网站上的大多数页面或者所有页面设置一致的外观。可以在一个外部样式表中定义全部样式，并让网站上的每个页面都加载这个外部样式表，来确保每个页面都有相同的设置。 对于有很多页面的网站，外部样式表能够做到CSS代码最大限度的重用。日后，如果要改变页面的外观，只需编辑CSS文件，而无需修改HTML文件，真正实现表现和内容的分离。 使用外部样式表的另一个好处是，一旦浏览器在某个页面加载了它，在随后浏览引用它的页面时，通常无需再向Web 服务器请求该文件。浏览器会将它保存到缓存中，也就是保存到用户的计算机里，并使用这个版本的文件。这样做可以提供页面的加载速度。 如果随后对样式表作了修改，再将它传到Web 服务器，浏览器就会下载更新后的文件，而不是使用缓存的文件。 1.5.2 内嵌样式表内嵌样式（embed style），就是在HTML文档头部的 &lt;style&gt; 和 &lt;/style&gt; 之间定义的样式表。如：123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;内嵌样式&lt;/title&gt;&lt;style&gt;p &#123; color: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个段落将显示为红色&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这里的 &lt;style&gt; 标签是HTML代码，其作用是告诉浏览器，该标签内的内容是CSS代码，浏览器将按CSS规则，来解析 &lt;style&gt; 和 &lt;/style&gt; 标签之间的内容。 这种方式定义的样式规则，只对本页面有效，因此，对单个页面定义特殊样式时，这种方式比较方便。但是，一个网站往往是由很多页面构成的，这种方式定义的样式，不能应用到其他的页面，达不到CSS代码重用的目的。并且，缓存的好处也不存在了。 更重要的是，这些样式存放在HTML文件，而不是CSS文件中，导致样式定义散落在多个页面中。如果要更新样式，就不得不更新每一个页面。所以，这种方式不便于维护，也容易出错，违背了内容与表现相分离的理念，故不推荐使用。 1.5.3 内联样式表内联样式表（inline style），就是在HTML元素中，通过 style 属性定义的样式。可以为包含在 body 内部的任何元素定义 style 属性，属性的值为一条或多条声明，多条声明间用逗号隔开。如：12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;内联样式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p style = \"color: red; font-weight: bold\"&gt;这个段落将显示为红色粗体&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上述代码通过 p 元素的 style属性，为段落元素定义了一个内联样式，让段落中的文本以红色、粗体显示。 内联样式是所有方法中最直接的一种，但它会导致表现和内容的耦合，与CSS的表现和内容相分离的设计理念背道而驰，极大损害了样式表的优势。所以，通常不推荐使用 style属性，笔者更是坚决反对使用内联样式。 然而，事情并非总是一成不变的。如果某些样式确实只在某标签中使用一次，也可以使用行内样式。同样，如果某些样式仅仅在某文件中使用，也可以使用内嵌样式。但是，既然选择如此，日后维护这些样式所带来的痛苦，你也要默默承受。 1.5.4 样式表的优先级如果内联样式、嵌入样式、导入样式、链接样式同时应用于同一个元素时，样式表的优先级规则是高优先级样式会生效，即高优先级会覆盖低优先级样式。 样式表的优先级按内联样式、嵌入样式、导入样式、链接样式顺序依次降低，其实，也就是就近原则，距离元素越近的样式，越优先生效。如果这四种样式都没有定义，则会应用浏览器的默认样式。 1.5.5 样式继承与层叠所谓继承，就是有些CSS属性不仅影响当前元素，还会影响这些元素的后代。 并非所有的CSS属性都能被继承，有许多CSS属性根本不会传递给其后代，如 border 属性。给 body 增加边框，则不会影响到它的后代。当然，这也是有道理的。如果 border 属性也能被继承，则给 body 增加边框后，页面的所有元素都将会有一个边框，这显然不合适。因此，影响元素位置的那些属性，如 margin、padding、border等，都不具有继承性。 但是，无论一个属性是否具有继承性，如果将它的值显式地设置为 inherit，它就具有继承性。 所谓层叠，就是样式的冲突规则，是指一个元素的同一个属性，被多个CSS规则同时定义时，如何应用这些样式规则。 CSS的层叠规则是：如果这些规则不冲突，则它们会同时生效；如果某些规则相互冲突，则高优先级的规则会生效；如果相同优先级的规则发生冲突，则最后定义的样式规则会生效。如，对 p 元素定义了两个样式规则：12345678p &#123; font-size: 14px; font-family: Arial;&#125;p &#123; font-size: 16px; color: black;&#125; font-family 和 color 属性，两个选择器的规则没有冲突，这两个规则会同时生效。而这两个选择器同时定义了 font-size 属性，故 font-size 属性发生冲突，由于这两个选择器的优先级相同，则后定义的样式会覆盖先定义的样式，故后定义的 font-size: 16px 会生效。经过层叠后，p 元素的最终样式就变成了：12345p &#123; font-size: 16px; font-family: Arial; color: black;&#125; CSS选择器2.1 概述2.1.1 HTML DOMCSS的目的，是实现网页的表现和内容相分离，由HTML控制网页的内容，由CSS控制网页的表现。而CSS的核心是选择器，选择器根据HTML DOM来找到相应的元素，并为它们应用样式，从而实现表现与内容的分离。因此，在介绍选择器之前，有必须先了解一下HTML DOM。 DOM是Document Object Model的缩写，即文档对象模型。HTML DOM是HTML文档对象模型的简称，用来描述HTML页面的层次结构。 根据W3C的HTML DOM标准，HTML DOM由节点组成，HTML文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 把一个HTML文档中的所有元素组织在一起，就构成了一棵DOM树，文档中的每个元素、属性、文本等都代表DOM树中的一个节点，节点之间存在等级关系。看一个简单的HTML文档：123456789&lt;html&gt; &lt;head&gt; &lt;title&gt; HTML DOM &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; Hello world! &lt;/h1&gt; &lt;a href = “http://www.baidu.com”&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 文档中的每一个元素，在DOM树中都有自己的位置。每个元素要么是另一个元素的父元素，要么是另一个元素的子元素，通常是既作父元素，又作子元素。 DOM树中所有的节点彼此间都存在关系，如果一个节点是另一个节点的直接上层，则前者是后者的父节点。除文档节点之外的每个节点都有父节点。如，&lt;head&gt; 和 &lt;body&gt; 的父节点是 &lt;html&gt; 节点，文本节点 “Hello world!” 的父节点是 &lt;h1&gt; 节点。 如果一个节点是另一个节点的直接下层，则前者是后者的子节点。大部分元素节点都有子节点。如，&lt;head&gt; 节点有一个子节点：&lt;title&gt; 节点。&lt;title&gt; 节点也有一个子节点：文本节点 “HTML DOM”。 当节点具有同一个父节点时，它们就是同胞（同级子节点）。如，&lt;h1&gt; 和 &lt;a&gt; 是同胞，因为它们的父节点均是 &lt;body&gt; 节点。 节点也可以拥有后代，后代指某个节点的所有子节点，及这些子节点的子节点，以此类推。如，所有的文本节点都是 &lt;html&gt; 节点的后代，而第一个文本节点是 &lt;head&gt; 节点的后代。 节点也可以拥有祖先，祖先是某个节点的父节点，或者父节点的父节点，以此类推。如，所有的文本节点都可把 &lt;html&gt; 节点作为祖先节点。 由此可知，一个HTML文档并不是一个简单的文本文件，而是一个具有层次结构的逻辑文档，每一个HTML元素都作为这个层次结构中的一个节点存在。每个节点反映在浏览器上会具有不同的外观，而具体的外观正是由CSS来决定的。 2.1.2 选择器的分类CSS的选择器有多种形式，根据所获取元素的不同，选择器分为五大类：基本选择器、关系选择器、属性选择器、伪元素选择器、伪类选择器。 伪类选择器，按其功能又可细分为：链接伪类选择器、结构伪类选择器、否定伪类选择器、目标伪类选择器、语言伪类选择器、UI状态伪类选择器。 2.2 基本选择器基本选择器是CSS中使用最频繁、最基础，也是CSS中最早定义的选择器。基本选择器包括元素选择器、类选择器、id选择器、群组选择器、通配选择器。 选择器 语法 功能描述 版本 元素选择器 E 选择指定类型的元素 1 类选择器 E.class 选择类型为E，且class属性值包含指定类名的元素 1 id选择器 E#id 选择类型为E，且id属性值为指定id的元素 1 群组选择器 E, F 同时选择所有E元素或F元素，E和F之间用逗号隔开 1 通配选择器 * 选择所有元素 2 表中，使用E.class或E#id这种方式声明的选择器，称作交集选择器，它由两个选择器直接连接构成，其结果是选中两个选择器所匹配的交集。 其中，第一个选择器必须是元素选择器，第二个选择器必须是类选择器或 id 选择器。第一个选择器和第二个选择器之间没有空格，连续书写。如： ul.nav { … } 上述规则，首先，只选择ul元素，而不选择其它类型的元素。其次，ul元素的class属性值还必须是nav。 如果省略了第一个选择器，则就变成了普通的类选择器，会选择 class 属性值包含指定类名的任何元素。 2.2.1 元素选择器一个完整的HTML页面是由很多不同的元素组成。元素选择器，是直接使用HTML元素的名称作为选择器（如 html、p、h1、em、a、img等）。由于使用元素的名称作为选择器，在W3C标准中，又把元素选择器称为类型选择器、标签选择器。 元素选择器匹配该类型的元素，并匹配DOM树中该类型元素的每一个实例，并为它们应用样式。如：12p &#123; color: black; &#125;h1 &#123; font-size: 14px; &#125; 上述规则将匹配文档中所有的 p 元素和 h1 元素，为它们应用样式。应用上述样式后，文档中的所有段落文本为黑色，所有 h1 标题字体大小为 14px。 2.2.2 类选择器类选择器是以独立于文档元素的方式来指定样式，如果应用样式，而不考虑具体涉及的元素时，最常用的就是类选择器。 类选择器，是在类名前面加一个点（.）定义的选择器。为了提高选择器的灵活性，类选择器的名称，可以由用户自定义。 如，以下代码定义了名称为 red 的类选择器：1.red &#123; color: red &#125; 要为一个元素应用类选择器定义的样式，还需要在HTML代码中，为元素指定 class属性，并把属性的值设置为指定的类名。 类选择器的样式可以应用于任何HTML元素，一个类可以在一个文档中使用任意多次。浏览器会在文档中寻找 class属性中包含指定值的元素，为该元素应用该类选择器所定义的样式，而不管它是什么元素。如：12&lt;p class = \"red\"&gt;我是段落&lt;/p&gt;&lt;h1 class = \"red\"&gt;我是一级标题&lt;/p&gt; 浏览器会在文档中寻找 class属性中包含red的元素，则 p 元素和 h1 元素都会被选中，因此段落和 h1 的文本都会变成红色。 但有时候，仅希望给某种特定类型的元素定义类选择器，此时仅仅使用类名就不能达到需要的效果。 这时，就可以在类选择器的前面添加特定元素的限定符E，如E.class，则该类选择器只匹配类型为E，且class属性值包含指定类名的元素，两个条件中任何一个不满足，都不会匹配。如：1p.red &#123; color: red &#125; 选择器p.red解释为：“其class属性值包含red的所有p元素”。因此，该选择器就只匹配 class属性包含red的所有p元素，不匹配其它类型的元素，无论其 class属性中是否包含red。 如：12&lt;p class = \"red\"&gt;我是段落&lt;/p&gt;&lt;h1 class = \"red\"&gt;我是一级标题&lt;/p&gt; 运行上述代码，只有段落文本会变成红色。因为 h1 元素不是段落，这个规则的选择器不会与它匹配，因此 h1 元素不会变成红色文本。 在HTML中，一个元素的 class属性值中可以包含多个类名，类名之间用空格分隔，表示为该元素应用多个类选择器的样式。当元素应用多个类的样式时，类名不分先后顺序，元素的最终样式就是所有这些样式层叠后的效果。如：12.red &#123; color: red; &#125;.bold &#123; font-weight: bold; &#125; 1&lt;p class = \"red bold\"&gt;本段落的文本将显示为红色、粗体。&lt;/p&gt; 这个p元素同时应用了red和bold两个类选择器的样式，则段落文本为红色、粗体显示。 2.2.3 id选择器id选择器用于为带有特定 id 的 HTML 元素指定样式。id选择器，是选择器前面加一个井号（#）定义的选择器。 id 选择器可以应用于任何HTML元素，浏览器会在文档中寻找具有指定 id 的元素，为该元素应用样式。id 由用户自定义。如：1#intro &#123; font-weight: bold; &#125; 1&lt;p id=\"intro\"&gt;本段落的文本将显示为粗体。&lt;/p&gt; 这个p元素应用了id = “intro”的id选择器的样式，段落文本将显示为粗体。 与类选择器不同的是，id 是唯一性元素，一个 id 在文档中被使用一次，一个页面上，不允许两个元素具有相同的 id。一个HTML元素，也只允许使用一个 id，不允许以空格分隔的 id 列表。 由于 class 和 id 是不同的属性，所以，一个元素可以同时拥有 class属性 和 id属性。这时，class属性定义的样式和 id属性定义的样式，将同时对该元素起作用。但是，当 class属性定义的样式和 id属性定义的样式发生冲突时，将使用 id属性所定义的样式，因为 id 选择器的优先级高于 class 选择器的优先级。 2.2.4 群组选择器id选择器用于为带有特定 id 的 HTML 元素指定样式。id选择器，是选择器前面加一个井号（#）定义的选择器。 id 选择器可以应用于任何HTML元素，浏览器会在文档中寻找具有指定 id 的元素，为该元素应用样式。id 由用户自定义。如：1#intro &#123; font-weight: bold; &#125; 1&lt;p id=\"intro\"&gt;本段落的文本将显示为粗体。&lt;/p&gt; 这个p元素应用了id = “intro”的id选择器的样式，段落文本将显示为粗体。 与类选择器不同的是，id 是唯一性元素，一个 id 在文档中被使用一次，一个页面上，不允许两个元素具有相同的 id。一个HTML元素，也只允许使用一个 id，不允许以空格分隔的 id 列表。 由于 class 和 id 是不同的属性，所以，一个元素可以同时拥有 class属性 和 id属性。这时，class属性定义的样式和 id属性定义的样式，将同时对该元素起作用。但是，当 class属性定义的样式和 id属性定义的样式发生冲突时，将使用 id属性所定义的样式，因为 id 选择器的优先级高于 class 选择器的优先级。 2.2.5 通配符选择器通配选择器用一个星号（*）表示。单独使用时，这个选择器可以与文档中的任何元素匹配，就像一个通配符。如，让页面上的所有文本都为黑色： * { color: black; }当然也可以选择某个元素下的所有元素。在与其他选择器结合使用时，通配选择器可以对特定元素的所有后代应用样式。如，以下代码为 .demo 元素的所有后代，添加一个灰色背景： .demo * { background: gray; }虽然通配选择器的功能强大，但是出于效率考虑，很少有人使用它。由于各个浏览器对每个元素上的默认边距都不一致，为了保证页面能够兼容多种浏览器，通常在Reset样式文件中，使用通配选择器进行重置，来覆盖浏览器的默认规则： * { margin: 0; padding: 0; } 2.3 关系选择器关系选择器，顾名思义，是根据HTML元素在DOM树中的关系来选择元素，这些关系包括后代、父子、同胞、相邻同胞。于是，关系选择器就包括后代选择器、子选择器、相邻同胞选择器、同胞选择器。 选择器 语法 功能描述 版本 后代选择器 E F 选择E元素的所有后代F元素 1 子选择器 E &gt; F 选择E元素的所有子元素F 2 相邻同胞选择器 E + F 选择紧接在E元素之后的第一个兄弟元素F 2 同胞选择器 E ~ F 选择E元素之后的所有兄弟元素F 3 2.3.1 后代选择器后代选择器（E F），也称包含选择器，用来选择特定元素的后代。在CSS中，后代是根据HTML文档中的DOM上下文来决定的。当元素发生嵌套时，内层的元素就成为外层元素的后代。如元素B嵌在元素A内部，B就是A的后代。而且，B的后代也是A的后代，就像家族关系。 定义后代选择器时，外层的元素写在前面，内层的元素写在后面，中间用空格分隔。后代选择器会影响到它的各级后代，没有层级限制。如：1div p &#123; color: red; &#125; 上述选择器中，div 为祖先元素，p 为后代元素，其作用就是选择 div 元素的所有后代 p元素，不管 p 元素是 div 元素的子元素、孙辈元素或者更深层次的关系，都将被选中。换句话说，不论 p 是 div 的多少辈的后代，p 元素中的文本都会变成红色。 其实，后代选择器中的空格，是用来表示后代层级的，当然就不限于二级的。根据需要，从任一个祖先元素开始，直到想应用样式的那个元素，都可以被放到后代选择器链中。如：12345678910&lt;ul&gt; &lt;li&gt;&lt;a href=\"/home/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/new/\"&gt;新房&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/esf/\"&gt;二手房&lt;/a&gt;&lt;/li&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/sale/\"&gt;出售房源&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/buy/\"&gt;求购房源&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;&lt;a href=\"/rent/\"&gt;租房&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 上述导航菜单中，假如希望所有锚文本的字体大小是16px，就可以通过后代选择器ul a来选择 ul 元素的所有后代，因为后代选择器会影响到它的各级后代。如：123ul a &#123; font-size: 16px;&#125; 假如又希望第二级列表项的锚文本的字体大小是12px，就可以通过ul.nav ul a的这种多层后代关系的后代选择器，它只选择第二级列表项的锚文本。123ul li a &#123; font-size: 12px;&#125; 当然，这个后代选择器也可以写成ul li ul li a，以实现更精准的控制。 2.3.2 子元素选择器子选择器（E &gt; F），就是只选择元素的直接后代（即子元素），而不选择其它后代的选择器。这就是子选择器与后代选择器的区别。子选择器中，&gt; 两侧的空白符是可选的。 假如我们希望第一级列表项的链接文本的字体加粗显示。因为第一级列表项是 ul 的子元素，这时，就可以使用子选择器来实现。如：123ul &gt; li a &#123; font-weight: bold;&#125; 2.3.3 相邻同胞选择器相邻同胞选择器（E + F），选择紧跟在某个元素的后面，且具有相同父亲的元素。换句话说，E和F是同辈元素，F紧跟在E元素后面，即它们之间没有其他同胞元素。相邻同胞选择器中，+ 两侧的空白符是可选的。 如，一些博客站，博文标题后面的第一段是博文的摘要。HTML代码如下：12345&lt;article&gt; &lt;h1&gt;相邻同胞选择器&lt;/h1&gt; &lt;p&gt;相邻同胞选择器，为同一个父元素下某个元素之后的第一个兄弟…&lt;/p&gt; &lt;p&gt;例如，一些博客站，博文标题后面的第一段是博文的摘要。如果希望摘要…&lt;/p&gt;&lt;/article&gt; 上述代码中，第一个 p 元素是 h1 元素相邻同胞元素。为了突显摘要，就可以使用相邻同胞选择器为摘要应用特殊样式，如让摘要显示为绿色、楷体，并且有1px的灰色虚线框：12345h1 + p &#123; color: green; font-family: KaiTi_GB2312; border: 1px dashed #333;&#125; 2.3.4 同胞选择器同胞选择器（E～F），用于选择某元素后面的所有同胞元素。也就是说，E和F是同辈元素，且F在E元素的后面，它们之间可以有，也可以没有其他同胞元素。 如，在博客站中，博文标题后面的是正文，正文用段落组织。HTML 代码如下：12345&lt;article&gt; &lt;h1&gt;同胞选择器&lt;/h1&gt; &lt;p&gt;同胞选择器，为同一个父元素下某个元素之后所有的元素应用样式…&lt;/p&gt; &lt;p&gt;例如，一篇文章中，可以使用同胞选择器，让一级标题后面的所有段落…&lt;/p&gt;&lt;/article&gt; 上述代码中，所有的 p 元素都是 h1 元素的同胞元素。此时，就可以使用同胞选择器，让所有段落都首行缩进两个字符，并使用 1.5 倍行距。1234h1 ~ p &#123; text-indent: 2em; line-height: 1.5em;&#125; 2.4 属性选择器在HTML中，可以通过元素各种各样的属性，来给元素增加很多附加信息。如通过 width 属性，可以指定元素的宽度；通过 id 属性，可以区分不同的元素，并通过Javascript来控制这些元素的内容和状态。 以往的CSS中，大量使用类选择器来定义样式。由于类选择器并不能说明什么样式服务于什么元素。因此，对于一个大型网站，CSS代码比较庞大，若要修改某个样式，就成为非常头疼的事情。 CSS的属性选择器使上述问题迎刃而解，因为它是语义化的选择器，可以根据元素是否拥有某个属性或属性的值来选择元素。 选择器 功能描述 版本 E[attribute] 选择拥有属性 attribute 的E元素，不考虑属性的值 2 E[attribute = val] 选择属性 attribute 的值等于val的E元素 2 E[attribute ~= val] 选择属性 attribute 的值是用空格分隔的多个单词，其中一个单词的值等于 val的E元素 2 E[attribute \\ = val] 选择属性 attribute 的值是用连字符”-“分隔的单词，并以 val 开头的E元素，主要用于 lang 属性，比如 “en”、”en-us”、”en-gb” 等 2 E[attribute *= val] 选择属性 attribute 的值包含 val 子字符串的E元素 3 E[attribute ^= val] 选择属性 attribute 的值以 val 开头的E元素，val 为完整的单词或单词的一部分 3 E[attribute $= val] 选择属性 attribute 的值以 val 结尾的E元素，val 为完整的单词或单词的一部分 3 （1）E[attribute] 选择器 该选择器表示，选择拥有attribute属性的E元素，不管属性的值是什么。如果省略E，则表示选择任何类型的元素，只要它拥有attribute属性（下同）。 如，为所有包含 rel 属性的超链接应用样式，让其文本为绿色：123a[rel] &#123; color: green;&#125; 还可以根据多个属性进行选择，只需将多个属性链接在一起即可。如，将同时带有href和 title 属性的所有超链接设置为红色：123a[href][title] &#123; color: red;&#125; （2）E[attribute = val] 选择器 该选择器表示，选择设置了属性 attribute，且属性的值为val的E元素。如，将指向首页的的所有超链接设置为红色：123a[href = \"http://www.waibo.wang/\"] &#123; color: red;&#125; 在处理表单时，许多元素都使用相同的标签，如复选框、文本输入框、提交按钮等，都使用 input 标签，而实际上它们的功能却完全不同，其功能由 type 属性的值来决定。如果仅仅想为文本输入框添加边框，就可以使用这个选择器。如：123input[type = \"text\"] &#123; border: 1px solid #ccc;&#125; 该选择器也支持根据多个属性进行选择，只需将多个属性-值链接在一起即可。如，将 href 属性值为 http://www.waibo.wang/，且 title 属性值为“歪脖网首页”的所有超链接加粗显示：123a[href = \"http://www.waibo.wang/\"][title = \"歪脖网首页\"] &#123; font-weight: bold;&#125; 需要注意的是，该选择器的指定的属性值，必须与HTML标签中的属性值完全匹配才行，否则就会选择失败。如，在HTML中的class属性中，如果包含多个类名，类名之间用一个空格分隔：1&lt;p class=\"urgent warning\"&gt; urgent warning&lt;/p&gt; 如果要根据 class 属性的值来选择这个元素，必须写成：123p[class = \"urgent warning\"] &#123; font-weight: bold;&#125; 要求选择器的属性值必须与HTML标签中的属性值完全相同，urgent在前，warning在后，就连空格的个数也要完全相同，否则就会匹配失败。 （3）E[attribute ~= val] 选择器 该属性选择器表示，选择拥有属性 attribute，且属性的值是用空格分隔的列表，其中一个列表值为 val的E元素。 在HTML中，这方面最经典的例子就是 class 属性，它能接受一个或多个词作为其属性值。还是前面的示例：1&lt;p class=\"urgent warning\"&gt; urgent warning&lt;/p&gt; 如果要选择 class 属性值中包含 warning 的元素，写成下面这个样子就可以了：123p[class ~= \"warning\"] &#123; font-weight: bold;&#125; 其实，该选择器只要求属性中包含指定的值即可，属性的值是否是词的列表也无关紧要，因此，上述选择器也会匹配 class = “warning” 的段落。也就是说，p[class ~= “warning”] 和 p.warning 的作用是等价的。 （4）E[attribute |= val] 选择器 该属性选择器表示，选择拥有属性 attribute，且属性的值是用连字符”-“分隔的单词，并以 val 开头的E元素，主要用于 lang 属性，比如 “en”、”en-us”、”en-gb” 等等。 如，通过使用通用选择器，这个选择器选择任何带有 lang 属性且属性值以 en 开头的元素：123*[lang |= \"en\"] &#123; color: green;&#125; 上述规则就会选择 lang属性值等于 en，或以 en- 开头的所有元素。因此，以下示例中的前两个会被选中，而后两个不会被选中：1234&lt;h1 lang = \"en\"&gt;Hello!&lt;/h1&gt;&lt;p lang = \"en-us\"&gt;Greetings!&lt;/p&gt;&lt;h2 lang = \"fr\"&gt;Bonjour!&lt;/h2&gt;&lt;div lang = \"cy-en\"&gt;Jrooana!&lt;/div&gt; 当然，该选择器可以用于任何属性和值。假如一个文档中有一系列图像，每个图像的文件名都形如 figuer-1.gif 和figuer-2.jpg，就可以使用以下选择器匹配所有这些图像：123img[src |= \"figuer\"] &#123; border: 1px solid gray;&#125; （5）E[attribute *= val] 选择器 该属性选择器表示，选择拥有属性 attribute，且属性的值包含 val 子字符串的E元素。 假如网站在链接类名中添加 nav 子串，来区分导航链接，主导航的类名为 mainnav，页码导航的类名为 pagenav：123456&lt;div class = \"mainnav\"&gt; &lt;a href = \"#\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class = \"pagenav\"&gt; &lt;a href = \"#\" &gt;&lt;/a&gt;&lt;/div&gt; 如果想去掉所有导航链接的下划线，就可以使用该选择器：123div[class *= \"nav\"] a &#123; text-decoration: none;&#125; （6）E[attribute ^= val] 选择器 该属性选择器表示，选择拥有属性 attribute，且属性的值以 val 开头的E元素，val 为完整的单词或单词的一部分。 如，为了突显指向网站外部的链接，就可以使用 E[ attribute ^= val ] 属性选择器，来寻找所有以 http: 开头的链接，在右侧添加外部链接的小图标。1234a[href ^= \"http://\"] &#123; padding-right: 20px; background: url(img/external.gif) no-repeat right top;&#125; （7）E[attribute $= val] 选择器 该属性选择器表示，选择拥有属性 attribute，且属性的值以 val 结尾的E元素，val 为完整的单词或单词的一部分。 对于一些下载站，用户可以下载各种不同类型的文件，而文件类型是根据超链接中 href 属性值的最后几个字符来确定：123456&lt;a href = \"a.doc\"&gt;DOC文件&lt;/a&gt;&lt;a href = \"a.xls\"&gt;XLS文件&lt;/a&gt;&lt;a href = \"a.ppt\"&gt;PPT文件&lt;/a&gt;&lt;a href = \"a.pdf\"&gt;PDF文件&lt;/a&gt;&lt;a href = \"a.rar\"&gt;RAR文件&lt;/a&gt;&lt;a href = \"a.wmv\"&gt;WMV文件&lt;/a&gt; 这种情况，就可以使用该属性选择器，检测文件的扩展名，并为不同类型的文件添加不同的图标，以提高用户体验：123456789101112131415161718192021222324252627a &#123; display: block; padding: 4px 24px; font-size: 14px; color: #000;&#125;a[href $= \"doc\"],a[href $= \"docx\"] &#123; background: url('img/doc.gif') no-repeat left center;&#125;a[href $= \"xls\"],a[href $= \"xlsx\"] &#123; background: url('img/xls.gif') no-repeat left center;&#125;a[href $= \"ppt\"] &#123; background: url('img/ppt.gif') no-repeat left center;&#125;a[href $= \"pdf\"] &#123; background: url('img/pdf.gif') no-repeat left center;&#125;a[href $= \"zip\"],a[href $= \"rar\"] &#123; background: url('img/rar.gif') no-repeat left center;&#125;a[href $= \"wmv\"] &#123; background: url('img/wmv.gif') no-repeat left center;&#125; 2.5 伪元素选择器伪元素选择器，并不是基于真正的元素，而是基于元素当前所具有的特性来选取元素。由于这些元素本身并不存在于文档中，只是基于元素的抽象，因此称作伪元素。 伪元素选择器是CSS 中已经定义好的选择器，不能由用户随便起名，只能按CSS规定的标准格式使用。语法格式为：1选择器:伪元素 &#123; 属性: 值 &#125; 伪元素选择器在CSS中一直存在，但CSS3对伪元素进行了一定的调整，把选择器和伪元素之间冒号，由CSS1和CSS2.1中的一个冒号，改成了两个冒号。但是，为了向下兼容，现代浏览器仍然支持老的写法，因此，两种写法都是合法的。 E: first-letter/E::first-letterE::first-letter 伪选择器用于选择E元素中的第一个字符，第一个字符包括 E::before 插入的内容。 许多报刊或杂志的文章中，开篇第一个字都很大，通过首字放大来吸引读者的眼球。而这个首字放大的效果，就可以使用 E::first-letter 伪选择器来实现。如：123p:first-child::first-letter &#123; font-size: 3em;&#125; 12&lt;p&gt;许多报刊或杂志的文章中，…，就可以使用E::first-letter伪选择器来实现。 &lt;/p&gt;&lt;p&gt;这里首先使用 …以免所有段落的第一个字都被放大。 &lt;/p&gt; 首先，使用 p:first-child选择第一个段落，然后，再使用 E::first-letter 伪选择器。这样的话，只有第一个段落中的第一个字是正常字体的3倍，以免所有段落的第一个字都被放大。 E: first-line/E::first-lineE::first-line伪选择器用于选择E元素中的第一行文本。第一行是指在浏览器中显示的第一行文本，如果调整浏览器窗口的尺寸，第一行的内容会跟着变化。第一行的内容包括E::before和E::after插入的内容。如，让段落的第一行文本以红色显示：123p::first-line &#123; color: red;&#125; 1&lt;p&gt;E::first-line伪选择器用于…第一行的内容会跟着变化。&lt;/p&gt; E::before/E::after使用 E::before和E::after 伪元素选择器，可以很方便地为页面添加一些令人难以置信的设计效果。它们可以跟 content 属性结合使用，来创建所谓的生成内容，并将生成的内容插入到元素E的前面或后面。E::before和E::after的作用相同，只是插入位置不同而已。 尽管生成的内容不会成为DOM的一部分，但同样可以通过CSS来格式化生成的内容。可以设置生成内容的颜色、字体、背景颜色、背景图像（包括渐变）、宽度、高度、边框、圆角等样式。如果未设置样式，则生成的内容会继承元素自身的可继承属性。 使用E::before和E::after的好处是，可以直接通过CSS向页面添加内容，而不必在页面上增加HTML元素。可插入的内容包括： 1）文本 通过 content 属性来指定待插入的文本，文本会原封不动输出，即便文本中包含HTML标记也不例外。如，在一个段落的前后，分别插入指定的文本：12345678p::before &#123; color: #00f; content: \"&lt;strong&gt;段落之前插入的内容&lt;/strong&gt;，\";&#125;p::after &#123; color: #f00; content: \"，段落之后插入的内容\";&#125; 1&lt;p&gt;段落文本&lt;/p&gt; 由于生成的内容不会成为DOM的一部分，因此，这些HTML标记仅仅作为纯文本显示在页面上。 2）文本符号 生成内容中，有一种特殊形式，就是文本符号，如双引号、单引号、括号等。在一个元素前后插入文本符号的方法为： 首先，在元素样式中，通过 quotes 属性来定义文本符号的内容。quotes 属性的值必须是一对字符串，中间用一个或多个空格分开，第一个串定义了开始符号（open-quote），第一个串定义了结束符号（close-quote）。因此，以下三种声明中，只有第一个是合法的：123cite &#123; quotes: '“' '”'; &#125;cite &#123; quotes: '“'; &#125;cite &#123; quotes: '”'; &#125; 由于文本符号是字符串，所以，要用引号把字符串包围起来，可以使用双引号，也可以使用单引号。事实上，文本符号可以是任意字符串。因此，以下声明都是合法的：123cite &#123; quotes: \"&#123;\" \"&#125;\"; &#125;cite &#123; quotes: '(' ')'; &#125;cite &#123; quotes: 'start' 'end'; &#125; 然后，把 content 属性的值设置为 open-quote 和 close-quote，就可以在元素的前面和后面分别插入由 open-quote 和 close-quote 定义的文本符号。如：123cite &#123; quotes: '“' '”'; font-style: normal; &#125;cite::before &#123; content: open-quote; &#125;cite::after &#123; content: close-quote; &#125; 1&lt;p&gt;子在川上曰:&lt;cite&gt;逝者如斯夫&lt;/cite&gt;&lt;/p&gt; 上述的代码，在引文的两侧分别添加双引号。 因为不同的语言有不同的文本符号，如中文使用全角引号，英文使用半角引号。所以，使用 quotes 属性来确定使用什么文本符号是有道理的。 当然，quotes 属性可以支持任意多层嵌套引用模式。通常的做法是，先以双引号开头，内层嵌套的引用使用单引号。如：123cite &#123; quotes: '“' '”' '‘' '’'; font-style:normal;&#125;cite::before &#123; content:open-quote; &#125;cite::after &#123; content:close-quote; &#125; 1&lt;p&gt;《水调歌头·游泳》:&lt;cite&gt;子在川上曰:&lt;q&gt;逝者如斯夫&lt;/q&gt;&lt;/cite&gt;&lt;/p&gt; 上述的代码，外层引文使用双引号，内层引文使用单引号。 CSS2.1规范还规定，如果引号的嵌套层数大于已定义的引号对数，更深层次的嵌套，将使用最后一对引号。 3）外部资源 使用E::before和E::after选择器，不仅可以插入文本，也可以插入外部资源，如图片。插入外部资源时，需要在 content 属性中，通过url来指定资源的路径。 如，上一节中根据文件类型，显示相应文件类型的图标的例子，也可以使用E::before伪元素选择器来实现：12345678a &#123; display:block; padding:4px; font-size:14px; &#125;a::before &#123; padding-right:10px; &#125;a[href $= \"doc\"]::before &#123; content: url('img/doc.gif'); &#125;a[href $= \"xls\"]::before &#123; content: url('img/xls.gif'); &#125;a[href $= \"ppt\"]::before &#123; content: url('img/ppt.gif'); &#125;a[href $= \"pdf\"]::before &#123; content: url('img/pdf.gif'); &#125;a[href $= \"rar\"]::before &#123; content: url('img/rar.gif'); &#125;a[href $= \"wmv\"]::before &#123; content: url('img/wmv.gif'); &#125; 如果浏览器出于某种原因不支持所指定的资源，如插入SVG，但该浏览器不能识别SVG，此时，浏览器就会忽略该资源，不插入任何内容。 虽然CSS2.1规范规定，可以通过 url 属性来插入音频、视频或浏览器支持的其他任何资源。但目前为止，还没有任何浏览器支持。 4）元素的属性值 除了文本和外部资源，也可以插入元素的某个属性值。插入属性值时，需要在content属性中，通过 attr 来指定元素的属性名称。 如，为了方便用户查看外部链接的地址，可以把页面上的每个外部链接的 href 属性值显示在链接的后面：123a[href ^= \"http://\"]:after &#123; content: \" [\"attr(href)\"]\";&#125; 1&lt;a href=\"http://www.baidu.com/\"&gt;百度&lt;/a&gt; 注意，如果插入的属性不存在，则会在相应的位置插入一个空字符串。另外，到目前为止，各浏览器对 attr 属性值的支持有限，并非任何属性都能支持。 5）空内容 如果设置content: “”，则不插入任何内容。借助元素自身的特征，通过巧妙设置一些CSS属性，虽然在元素的前后没有插入任何内容，却可以实现很多非常有趣的效果。如：1234567891011121314151617181920212223242526272829303132#gossip &#123; width: 96px; height: 48px; background: #fff; border-color: #000; border-style: solid; border-width: 1px 1px 50px 1px; border-radius: 100%; position: relative;&#125;#gossip:before &#123; content: \"\"; width: 12px; height: 12px; top: 50%; left: 0; position: absolute; background: #fff; border: 18px solid #000; border-radius: 100%;&#125;#gossip:after &#123; content: \"\"; width: 12px; height: 12px; top: 50%; left: 50%; position: absolute; background: #000; border: 18px solid #fff; border-radius: 100%;&#125; 1&lt;div id=\"gossip\"&gt;&lt;/div&gt; 上述代码将实现一个八卦图的效果。 6）项目符号 插入的内容还可以是列表的项目符号，只要 list-style-type 属性能支持的符号类型，均可插入。这是一个非常实用的功能。 假如在写一篇文章，文章有各级标题，有时需要调整标题的顺序。如果每次调整顺序或增删标题后，都要人工重新调整编号，就极不方便。如果采用自动编号，那就方便多了。这种情况，就可以借助 content 属性，在标题前插入自动编号，省时省力。 E::placeholderE::placeholder伪选择器用于控制表单输入框占位符的外观，它允许设计师改变文字占位符的样式。默认情况下，占位符文字为浅灰色，无边框。目前所有的浏览器都不支持该选择器，需要添加浏览器私有前缀。如：1234input::-webkit-input-placeholder &#123; color: #f00; border: 1px solid #00f;&#125; 1&lt;input placeholder = \"用户名\" /&gt; 上述代码，把占位符文本的颜色设置为红色，并为它添加了一个宽度为1像素的蓝色实线边框。 E::selectionE::selection选择器用于选择被选中的文本。可以使用该选择器，为被选中的文本设计一个与众不同的效果，如改变其背景色、前景色、文字阴影等。 这里有一个文本输入框和一个p元素。当文本输入框处于被选中状态时，被选中文本的背景色将会变成绿色。123input[type = text]::selection &#123; background: #0f0;&#125; 1&lt;input type=\"text\" /&gt; 这里有一个段落，段落中被选中文本的背景色将会变成黑色，文本颜色会变成白色，并为文本添加了阴影。代码如下：12345p::selection &#123; background: #000; color: #fff; text-shadow: 1px 1px 0 rgba(255, 255, 255, 1);&#125; 1&lt;p&gt;鼠标选中这段文字后，文本的背景色将会变成黑色，文本颜色会变成白色，并为文本添加了阴影，快用鼠标选中试一试吧O(∩_∩)O~&lt;/p&gt; 2.6 伪类选择器伪类选择器，就是基于元素当前所处的状态来选取元素。由于状态通常是动态变化的，当元素处于一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可知，它是基于文档之外的抽象，所以称作伪类。 伪类选择器是CSS 中已经定义好的选择器，不能由用户随便起名，只能按CSS规定的标准格式进行使用。其语法为：1选择器:伪类名 &#123; 属性: 值 &#125; 2.6.1 链接伪类选择器在CSS中，最常用的伪类选择器，就是使用在链接的锚元素上的选择器，用于定义不同状态下的链接样式。链接伪类并不存在于HTML中，只有当用户和网站交互时，才能体现出来。 选择器 功能描述 版本 E:link 选择未被访问过的链接 1 E:visited 选择已被访问过的链接 1 E:active 选择被激活（即鼠标已经按下、还没有释放）的E元素 1 E:hover 选择鼠标悬停其上的E元素 1 E:focus 选择获得焦点的E元素 1 在HTML中，超链接是指所有带有 href 属性的a元素。可以使用链接伪类来区分未访问的链接和已访问的链接：12a:link &#123; color: blue; &#125;a:visted &#123; color: purple; &#125; 当然，对于链接伪类，不仅可以应用颜色，还可以应用更多样式。如，对于已访问的链接，除了紫色外，还可以有一条删除线。 尽管 :link 和 :visted 非常有用，但它们是静态的，第一次显示之后，它们不会再改变元素的样式。并且，它们只用于锚元素，因此被称作链接伪类或锚伪类。 而 :hover、 :focus、:active 则不同它们可以根据用户行为动态改变文档的外观，故被称为动态伪类，或用户行为伪类。 最初，动态伪类总是用来设置超链接的样式，不过，现在它们可以应用到任何元素。如在表格的行上使用 :hover 伪类，表单的文本输入框是使用 :focus 伪类，表单的提交按钮上使用 :active 伪类等。如：123456tr:hover &#123; background: #c1d5eb;&#125;input:focus &#123; outline: 1px solid #c1d5eb;&#125; 另外，还可以把链接伪类结合在一起使用，来创造更丰富的样式。如，定义已被访问链接的悬停效果：123a:visited:hover &#123; color: #888;&#125; 用哪种书写顺序并不重要，a:visited:hover 和a:hover:visited 将会得到相同的效果。但是，不要把互斥的伪类结合在一起，如，一个链接不能同时是未访问和已访问状态，因此a:link:visited 没有任何意义。 2.6.2 结构伪类选择器结构伪类选择器，可以根据元素在文档中所处的位置，来动态选择元素，从而减少HTML文档对ID或类的依赖，有助于保持代码干净整洁。 选择器 功能描述 版本 E:last-child 选择父元素的倒数第一个子元素E，相当于E:nth-last-child(1) 3 E:nth-child(n) 选择父元素的第n个子元素，n从1开始计算 3 E:nth-last-child(n) 选择父元素的倒数第n个子元素，n从1开始计算 3 E:first-of-type 选择父元素下同种标签的第一个元素，相当于E:nth-of-type(1) 3 E:last-of-type 选择父元素下同种标签的倒数第一个元素，相当于E:nth-last-of-type(1) 3 E:nth-of-type(n) 与:nth-child(n)作用类似，用作选择使用同种标签的第n个元素 3 E:nth-last-of-type 与:nth-last-child作用类似，用作选择同种标签的倒数第一个元素 3 E:only-child 选择父元素下仅有的一个子元素，相当于E:first-child:last-child或E:nth-child(1):nth-last-child(1) 3 E:only-of-type 选择父元素下使用同种标签的唯一子元素，相当于E:first-of-type:last-of-type或E:nth-of-type(1):nth-last-of-type(1) 3 E:empty 选择空节点，即没有子元素的元素，而且该元素也不包含任何文本节点 3 E:root 选择文档的根元素，对于HTML文档，根元素永远HTML 3 结构伪类选择器很容易遭到误解，需要特别强调。如，p:first-child表示选择父元素下的第一个子元素 p，而不是选择 p 元素的第一个子元素。 需要注意的是，结构伪类选择器中，子元素的序号是从 1 开始的，也就是说，第一个子元素的序号是 1，而不是 0。换句话说，当参数 n 的计算结果为 0 时，将不选择任何元素。 接下来，简单介绍 :first-child、:last-child、:nth-child、:nth-of-type、:empty 这几个选择器，其他选择器的功能在表格中已经描述清楚，不再赘述。 E:first-child 和 E:last-child:first-child 和 :last-child分别用于选择元素的子元素中，符合条件的第一个和最后一个子元素。:first-child 伪类在CSS2就已经存在，:last-child 伪类是CSS3新增的伪类。 如，对于下面的 tab 菜单，希望该 tab 菜单的第一个元素的左上角，和最后一个元素的右上角应用圆角。HTML代码如下：12345&lt;ul class = \"tabMenu\"&gt;&lt;li&gt;&lt;a href=\"# \"&gt;公司介绍&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"# \"&gt;产品中心&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"# \"&gt;新闻动态&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 在CSS3之前，直接选取 class 为 tab 元素的第一个或最后一个子元素，是不可能的。现在，通过 :first-child 和 :last-child 伪类，就可以轻松实现。CSS代码如下：123456.tabMenu li:first-child &#123; border-top-left-radius: 5px;&#125;.tabMenu li:last-child &#123; border-top-right-radius: 5px;&#125; E:nth-child(n)E:nth-child(n) 用于选择某个父元素的一个或多个特定的子元素。n 表示不确定的数字，th 是英语中序数词的后缀。因此，nth-child 就表示第 n 个子元素。该选择器的参数 n 可以是数字、公式或关键字： 1）数字：可以是任何大于 0 的正整数。如，.tab li:nth-child(2)，表示选择 class 为 .tab 的父元素下，第 2 个 li 子元素。 2）公式：格式为 (an + b)。其中，a表示周期的长度，n 是计数器（从 0 开始），b 是偏移值。如，:nth-child(n+4) 选取序号大于等于 4 的元素，:nth-child(-n+4) 选取序号小于等于 4 的元素，:nth-child(2n) 选取序号为偶数的元素，:nth-child(2n+1) 选取序号为奇数的元素，:nth-child(3n) 选取序号为3、6、9…的子元素（即“隔二选一”），:nth-child(3n+1) 选取序号为1、4、7、10…的子元素，等等。 3）关键字：只有odd 和 even 两个关键字。odd表示选取序号为奇数的元素，效果等同于 :nth-child(2n-1) 和 :nth-child(2n+1)；even表示选取序号为偶数的元素，效果等同于 :nth-child(2n)。 E:nth-of-type(n):nth-of-type(n) 与 :nth-child(n) 的作用和使用方法完全相同，唯一不同的是，它用来选择某个父元素下，指定类型的一个或多个特定的子元素。 E:empty选择空节点，即不包含任何子元素的元素，也就是内容为空白的元素。因为文本节点本身也被看作子元素，所以，包含文本节点的元素就不是空元素，哪怕是一个空格。如：1234&lt;div&gt; &lt;p&gt;我包含文本节点，我不是空元素&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 对上述HTML代码调用样式如下：12345p:empty &#123; height: 25px; background: #eee; border: 1px solid #f90;&#125; 上述HTML代码中，由于最后一个 p 元素是空节点，则会被 p:empty 选择器选中。于是，它就会表现为一个高度为 25px，背景色为灰色，带有1px 的橙色边框的矩形框。 :nth-child 与 :nth-of-type 的区别：:nth-child 和 :nth-of-type 都能选择子元素，它们到底有什么区别呢？区别其实也很简单，E:nth-child(n) 是把所有子元素作为选择对象，选择其中的第n个子元素，且这个子元素的类型必须是 E，如果不是，则选择失败。而 E:nth-of-type(n) 则先把类型为E的所有子元素选择出来，从1开始编号，然后把这些子元素作为选择对象，选择其中的第n个。假如有以下HTML代码片段：1234567&lt;div&gt;&lt;ul class=&quot;demo&quot;&gt;&lt;p&gt;zero&lt;/p&gt;&lt;li&gt;one&lt;/li&gt;&lt;li&gt;two&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; 上述代码中，.demo li:nth-child(2)是从 .demo 的所有子元素中找第二个子元素，且第二个子元素的类型必须是 li，选择结果为&lt;li&gt;one&lt;/li&gt;节点；.demo li:nth-of-type(2) 先把 .demo 的所有类型为 li 的子元素找出来，然后选择其中的第 2 个，选择结果为 &lt;li&gt;two&lt;/li&gt; 节点。 2.6.3 否定伪类选择器否定伪类选择器用来选择不满足某些条件的元素。 选择器 功能描述 版本 E:not(selector) 选择未被选择器selector所选中，且类型为E的元素 3 如果想对某个结构元素使用样式，但是又想排除这个结构下的某些子结构时，否定伪类选择器就非常有用，它可以过滤掉某些内容。 如，在美化表单时，常常会给表单中所有的input添加一个边框，而单选按钮添加边框后就非常难看。这时，否定伪类就可以派上用场。代码如下：123input:not([type = radio]) &#123; border: 1px solid #ccc;&#125; 2.6.4 目标伪类选择器一个URI，除了可以直接指向某文档外，还可以通过井号（#）后跟一个锚点或元素 id，来指向页面的某个特定元素。 目标伪类选择器，就是用来匹配页面上被URI的某个标识符指定的目标元素，并为它应用样式。 选择器 功能描述 版本 E:target 选择该文档中特定“id”的元素 3 假如在 index.htm 页面中有 3 个&lt;a&gt;元素，id 为catlog、about、contact，它们分别代表一个书签。HTML代码如下：123&lt;a id=\"catlog\" href=\"#catlog\"&gt;商品分类&lt;/a&gt;&lt;a id=\"about\" href=\"#about\"&gt;联系我们&lt;/a&gt;&lt;a id=\"contact\" href=\"#contact\"&gt;关于我们&lt;/a&gt; 假如有一个外部链接，&lt;a href=&quot;index.htm#contact &quot;&gt;关于我们&lt;/a&gt;，就表示链接的目标为index.htm 文档中 id 为contact 的书签。当用户点击该链接时，跳转到index.htm 文档后，页面会向下滚动到 contact 书签的位置。 如果页面内容非常多，常常很难看出链接跳转到了哪个书签的位置。这种情况下，就可以使用目标伪类选择器 :target，为目标元素设置特殊的样式。这样，用户进入页面后，就会一目了然。CSS代码如下：1234a:target &#123; color: #fff; background: #fa7a20;&#125; 上述代码为目标超链接元素 a 定义了特殊的背景颜色，用户进入页面后，跳转到任何一个书签时，都可以提醒用户当前所处的书签位置。 2.6.5 语言伪类选择器语言伪类选择器，用来匹配使用指定语言的元素。对使用多语言版本的网站，可以根据不同语言版本，设置不同的样式。 选择器 功能描述 版本 E:lang(language) 选择使用指定语言，即lang属性等于language的E元素 2 在HTML 中，可以通过元素的 lang属性，来定义该元素所使用的语言。如：12&lt;body lang = \"en\"&gt;&lt;p lang = \"zh-cn\"&gt; 而语言伪类选择器，就是根据元素的 lang属性，来匹配使用指定语言的元素。可以根据不同语言版本，设置不同的字体风格、定义不同的引号标记等。 如，有一个英文的段落和一个中文的段落，希望英文使用Arial字体、中文使用宋体，英文使用半角引号、中文使用全角引号。HTML代码如下：12&lt;p lang=\"en\"&gt;&lt;q&gt;Quote in English&lt;/q&gt;&lt;/p&gt;&lt;p lang=\"zh-cn\"&gt;&lt;q&gt;中文的引号&lt;/q&gt;&lt;/p&gt; 这个就可以通过语言伪类选择器，为英文段落和中文段落定义不同的字体和不同的引号样式来实现。CSS代码如下：12345678:lang(en)&#123; font-family: Arial; quotes: '\"' '\"';&#125;:lang(zh-cn)&#123; font-family: 宋体; quotes: \"“\" \"”\";&#125; 2.6.6 UI状态伪类选择器UI状态伪类选择器，用于选择处于某种状态下的UI元素，主要用于HTML表单上，根据表单元素的不同状态，定义不同的样式，来增强用户体验。 表单元素的状态包括获得焦点、失去焦点、选中、未选中、可用、不可用、有效、无效、必填、选填、只读等等。 选择器 功能描述 版本 E:focused 选择表单中获得焦点的元素 3 E:checked 选择表单中被选中的radio或者checkbox元素 3 E:enabled 选择表单中可用的元素 3 E:disabled 选择表单中不可用（即被禁用）的元素 3 E:valid 选择表单中填写的内容符合要求的元素 3 E:invalid 选择表单中填写的内容不符合要求的元素，如非法的URL或E-Mail，或与 pattern 属性给出的模式不匹配 3 E:in-range 选择表单中输入的数字在有效范围内的元素 3 E:out-of-range 选择表单中输入的数字超出有效范围的元素 3 E:required 选择表单中必填的元素 3 E:optional 选择表单中允许使用required属性，且未指定为required的元素 3 E:read-only 选择表单中状态为只读的元素 3 E:read-write 选择表单中状态为非只读的元素 3 E:default 选择表单中默认处于选取状态的单选框或复选框，即使用户将该单选框或复选框控件的选取状态设定为非选取状态，E:default选择器中指定的样式仍然有效 3 E:indeterminate 选择器表单中一组单选框中没有任何一个单选框被选取时整组单选框的样式，如果用户选取了其中任何一个单选框，则该样式被取消指定 3 在使用UI状态伪类选择器时，可以结合属性选择器，来限定特定元素的类型，甚至将UI状态伪类结合在一起使用，来创造更丰富的样式。如果不限定元素的类型，则对任何元素均有效。 E:focusedE:focused伪类选择器选择获得的元素。如，以下规则可以为任何获得焦点的 input 元素添加 1px 的橙色边框，而不管它的类型：123input:focus &#123; border: 1px solid #f60;&#125; E:checkedE:checked伪类选择器选择表单中被选中的 radio 或 checkbox 元素。假设在注册用户的页面上，有一个复选框和同意注册的文本：1&lt;input type=\"checkbox\" value=\"1\" /&gt;&lt;label&gt; 我已经阅读并同意网站注册条款&lt;/label&gt; 以下规则为选中的单选按钮或复选框紧邻的 label 元素添加样式：123input:checked + label &#123; color: green;&#125; 当用户选中复选框后，紧邻复选框的 label 元素中的文本将变成绿色。 E:enabled/E:disenabledE:enabled伪类选择器选择处于可用状态的元素，E:disenabled伪类选择器选择处于不可用状态的元素。假设页面上有两个元素，一个可用，一个不可用：12&lt;label&gt; enabled: &lt;/label&gt;&lt;input type=\"text\" /&gt;&lt;label&gt;disabled: &lt;/label&gt;&lt;input type=\"text\" disabled /&gt; 就可以针对元素的可用、不可用状态，应用不同的样式。如，对不可用的元素，可以禁用鼠标，并设置灰色背景和边框：1234567891011input[type=\"text\"] &#123; width: 200px; height: 20px; background: #fff; border: 1px solid #cbcbcb;&#125;input[type=\"text\"]:disabled &#123; cursor: not-allowed; background: #eee; border-color: #ddd;&#125; 如果一个表单元素经常在可用和不可用状态之间进行切换，通常将这两个选择器结合使用，来改变元素的样式，增加表单的易用性。 E:valid/E:invalidE:valid 伪类选择器选择输入数据有效的元素，E:invalid 伪类选择器选择输入数据无效的元素。如，对于获得焦点的 email 输入框，就可以根据用户的输入是否为有效的邮箱地址，来应用不同的样式：1&lt;label&gt;E-Mail: &lt;/label&gt;&lt;input type=\"email\" name=\"email\" /&gt; 此时，就可以根据用户的输入，来应用不同的样式。如果输入有效的邮箱地址，文本框的边框颜色为绿色，如果输入无效的邮箱地址，文本框的边框颜色为红色：123456input[type=\"email\"]:focus:valid &#123; border: 1px solid green;&#125;input[type=\"email\"]:focus:invalid &#123; border: 1px solid red;&#125; 这样的话，在页面初始加载时，由于用户还没有进行输入，邮箱邮箱地址一定是非法值，文本框就会显示红色警示边框。 随着用户不断输入，当邮箱地址合法的时候，文本框就会由红色边框，自动变成安全的绿色边框。 E:in-range/E:out-of-rangeE:in-range伪类选择器选择输入数据在有效范围的元素，E:out-of-range伪类选择器选择输入数据超出有效范围的元素。如，对于 input 类型为 number 的文本输入框，其输入的值必须在 min 和 max 的范围内。1&lt;label&gt;请输入数字（0~10）: &lt;/label&gt;&lt;input type=\"number\" min=0 max=10 /&gt; 此时，就可以根据用户的输入，来应用不同的样式。如果输入的数值未超出范围，文本框的边框颜色为绿色，一旦输入的数值超出范围，文本框的边框颜色就变为红色：123456input[type=\"number\"]:focus:in-range &#123; border: 1px solid green;&#125;input[type=\"number\"]:focus:out-of-range &#123; border: 1px solid red;&#125; 这样的话，在用户输入数值的过程中，当输入的数值在有效范围内，文本框就是安全的绿色边框。 随着用户的不断输入，当输入的数值超出有效范围时，文本框就会由安全的绿色边框，自动变成红色警示边框。 字体和文本3.1 字体CSS规范清楚的认识到，字体选择是一个常见而且很重要的特性，所以设置字体的属性就是样式表中最常见的用途之一。 字体相关的属性在CSS1就已经定义，CSS3又新增了font-stretch 和 font-size-adjust 这两个属性。 人们早已认识到字体选择很重要，并在CSS2就支持可下载字体，也定义了 @font-face 相关属性，但是并没有得到浏览器的广泛支持。直到CSS3，浏览器才开始支持 @font-face，使设计师可以在网页中使用自己喜欢的任意字体。 3.1.1 字体系列在CSS中，通过 font-family属性来指定文本所使用的字体系列。语法格式为：1font-family: [&lt;family-name&gt; | &lt;generic-family&gt;] # 其中，family-name为字体系列的名称；generic-family为通用字体系列的名称。也就是说，font-family属性的值既可以是具体的字体系列的名称，也可以是通用字体系列的名称。 CSS定义了 5 种通用字体系列，分别是serif、sans-serif、cursive、fantasy、monospace，font-family属性可用使用其中的任何一种。如果希望文档使用一种通用字体系列中的某个字体，但并不关心是哪一种具体的字体，使用通用字体系列就比较合适。如：123body &#123; font-family: sans-serif;&#125; 这样，浏览器就会从 sans-serif 字体系列中选择一种字体，并将它应用到 body 元素。由于 font-family属性具有继承性，这种字体将会应用到 body 元素中的所有元素，除非有一种更特殊的选择器将其覆盖。 选择字体时，要尽量选择能够引人注目（特别是标题），并且容易阅读的字体。当然，设计师也可以选择使用特定的字体。假如设计师希望所有 h1 标题都使用 Georgia 字体，可以使用以下声明：123h1 &#123; font-family: Georgia;&#125; 这会使浏览器对所有 h1 标题都使用 Georgia 字体。当然，这个规则是假设访问者的计算机上已经安装了该字体。并且，设计师总是希望使用任何想要的字体，遗憾的是，如果访问者的计算机上没有安装该字体，浏览器便会使用默认字体来显示 h1 标题。 不过，不必万念俱灰，通过结合特定字体和通用字体系列，可以创建与你预想相同的文档。可以使用以下规则，告诉浏览器使用 Georgia 字体（如果可用），如果 Georgia 字体不可用，就使用另外一种 serif 字体：123h1 &#123; font-family: Georgia, serif;&#125; 这时，如果访问者的计算机上没有安装Georgia字体，但安装了 Times 字体，浏览器就会使用 Times。尽管 Times 与 Georgia 并不完全匹配，但至少足够接近。 出于这个原因，强烈建议在所有 font-family 规则中，都提供一个通用字体系列。这样一来，就提供了一条后路。 如果你对字体很熟悉，也可以在 font-family属性中指定想要的字体，并按优先顺序依次排列，中间用逗号分隔。如：123body &#123; font-family: Arial, SimSun, Helvetica, sans-serif;&#125; 浏览器会根据这个列表，按顺序查找这些字体，如果访问者的计算机上安装了第一种字体，就可以正确显示。如果没有安装第一种字体，就自动切换到第二种、第三种字体，以此类推。如果所有字体都没有找到，就会从 sans-serif 字体系列中选择一种可用的字体。 利用这个特性，还可以实现英文和中文使用不同字体的效果。通常的做法是，把英文字体写在前面，中文字体写在后面。如：123p &#123; font-family: Arial, 'Microsoft YaHei'; /* Arial，微软雅黑 */&#125; 这样，浏览器会优先使用 Arial 字体显示文本，由于中文字符不识别 Arial 字体，就会在后面的字体中继续查找，找到 Microsoft YaHei 字体后，便对中文应用该字体，这样，就达到了中文和英文使用不同字体的效果。 在指定字体时，如果字体名称中包含空格或中文或其他特殊字符，则要把整个字体名称用放在引号中，可以使用单引号，也可以使用双引号。并且，字体名称不区分大小写。 对于中文，有三种指定字体的方法：一种是直接使用中文字体名称，一种是使用英文字体名称，一种是使用字体的 unicode 码。但是，在CSS文档中定义字体时，如果直接书写中文，经常会出现乱码，或者在某些浏览器下字体不生效。一个常用的解决办法，是把中文字体名称转换为对应的英文字体名称或unicode 码。如，宋体的英文字体名称为 SimSun、unicode 码为 \\5B8B\\4F53，则可以写成：123p &#123; font-family: SimSun;&#125; 也可以写成：123p &#123; font-family: \"\\5B8B\\4F53\";&#125; 上述两种写法是等价的，可以自行选择。为了方便查阅，几种常用字体的中文名称、英文名称、unicode码的对照关系见表 中文名称 英文名称 unicode 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 细明体 MingLiU \\7EC6\\660E\\4F53 标楷体 DFKai-SB \\6807 \\6977\\4F53 黑体 SimHei \\9ED1\\4F53 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 仿宋 FangSong \\4EFF\\5B8B 楷体 KaiTi \\6977\\4F53 仿宋_GB23122 FangSong_GB2312 \\4EFF\\5B8B_GB2312 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 微软正黑体 Microsoft JhengHei \\5FAE\\x8F6F\\6B63\\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 华文黑体 STHeiti \\534E\\6587\\9ED1\\4F53 华文楷体 STKaiti \\534E\\6587\\6977\\4F53 华文宋体 STSong \\534E\\6587\\5B8B\\4F53 华文仿宋 STFangsong \\534E\\6587\\4EFF\\5B8B 丽黑 ProLiHei Pro Medium \\4E3D\\9ED1 Pro 丽宋 ProLiSong Pro Light \\4E3D\\5B8B Pro 标楷体 BiauKai \\6807\\6977\\4F53 隶书 LiSu \\96B6\\4E66 幼圆 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 华文楷体 STKaiti \\534E\\6587\\6977\\4F53 华文宋体 STSong \\534E\\6587\\5B8B\\4F53 华文中宋 STZhongsong \\534E\\6587\\4E2D\\5B8B 华文仿宋 STFangsong \\534E\\6587\\4EFF \\5B8B 方正舒体 FZShuTi \\65B9\\6B63\\8212\\4F53 方正姚体 FZYaoti \\65B9 \\6B63\\59DA\\4F53 华文彩云 STCaiyun \\534E\\6587\\5F69\\4E91 华文琥珀 STHupo \\534E\\6587\\7425\\73C0 华文隶书 STLiti \\534E\\6587\\96B6\\4E66 华文行楷 STXingkai \\534E\\6587\\884C\\6977 华文新魏 STXinwei \\534E\\6587\\65B0\\9B4F 虽然CSS提供了备选字体的机制，但是，在CSS3之前，所有的字体都只能是Web安全字体（即预先安装在主流个人计算机操作系统中的字体的子集）。直到CSS3中@font-face的出现，这个问题才彻底得到解决。 虽然 font-family属性具有继承性，但有几个元素不会继承父元素的字体设置，其中有表单的select、textarea 和input 元素。不过，可以强制它们继承父元素的字体设置。代码如下：123input, select, textarea &#123; font-family: inherit;&#125; 3.1.2 字体大小在CSS中，通过 font-size属性来设置元素中所包含文本的字体大小。如果一个元素没有显式定义font-size属性，则会自动继承父元素的 font-size属性的计算结果。 定义 font-size 时，可以使用预定义关键字、绝对尺寸、相对尺寸： 1）预定义关键字 预定义关键字有 xx-small、x-small、small、medium、large、x-large、xx-large，尺寸按顺序依次增大，类似于衣服的尺寸。 使用预定义关键字有两大缺陷：一是只有 7 种选择，可选择范围太小；二是跟衣服的尺寸一样，不同厂商对每个关键字对应的字体大小的精确值可能各不不同，导致在不同浏览器下，文本的大小可能不同。因此，不推荐使用预定义关键字来定义字体的大小。 2）绝对尺寸 绝对尺寸有px（像素）、pt（点，1pt 相当于 1/72in）、in（英寸）、cm（厘米）、mm（毫米）等。如：123456789101112131415.px &#123; font-size: 14px;&#125;.pt &#123; font-size: 10pt;&#125;.in &#123; font-size: .15in;&#125;.cm &#123; font-size: .4cm;&#125;.mm &#123; font-size: 4mm;&#125; 12345&lt;p class=\"px\"&gt;字体大小： 14px&lt;/p&gt;&lt;p class=\"pt\"&gt;字体大小： 10pt&lt;/p&gt;&lt;p class=\"in\"&gt;字体大小： .15in&lt;/p&gt;&lt;p class=\"cm\"&gt;字体大小： .4cm&lt;/p&gt;&lt;p class=\"mm\"&gt;字体大小： 4mm&lt;/p&gt; 上述代码定义了 5 种字体大小，都使用绝对单位。使用绝对长度单位后，在固定分辨率的显示器下，显示出来的都是固定大小。 如果以 px 为单位设置字体大小，使用IE浏览器的用户，就不能在浏览器上通过设置“文字大小”来对文本进行放大或缩小。如果文本太小，就会影响阅读，使用户体验大打折扣。 3）相对尺寸 相对尺寸有 em、%、rem，它们都是相对于某个参考基准的字体大小，来计算当前字体的大小，只是参考基准不同而已。 em 的参考基准是父元素。那么，如何计算要指定的 em 值呢？实际上，1em 总是等于父元素 font-size属性的值，这就是 em 的工作原理。据此，可以通过以下公式来确定百分比的值： 目标元素的字体大小 / 父元素的字体大小 = 值 因此，在使用 em 定义字体大小时，最好在 html 或 body 元素上建立一个基准。假设在 body 中设置的基准大小为 12px： body { font-size: 12px;}如果希望 body 中所有段落的字体大小为 18px，根据上述公式： 18 / 12 = 1. 5 因此，只需将将段落的 font-size 设置为 1.5em 就可以了，这条规则就表示段落文本的字体大小为父元素文本大小的1.5 倍： body p { font-size: 1.5em;}% 的参考基准也是父元素，100% 也总是等于父元素 font-size属性的值，即 1em 就等于 100%。也就是说，在用 % 定义字体大小时，只需将 em 的值换算成相应的百分数即可。因此，以下两条声明会得到相同的结果（假设两个段落具有相同的父元素）： p.one { font-size: 1.5em;}p.one { font-size: 150%;}需要注意的是，尽管 font-size 是可以继承的，但在使用 % 和 em 定义字体大小时，子元素继承的是计算结果的值，而不是 % 和 em 的数字。并且，% 和 em 还可以累积。考虑以下代码： p { font-size: 12px;}em { font-size: 200%;}strong { font-size: 200%;} 12px 200% 200% 上述代码中，p 为父元素，em 为 p 的子元素，strong 为 em 的子元素。em 元素的基准是 p 元素，而 strong 元素的基准是 em 元素。计算结果如下： em：12 × 200% = 24px strong：24 × 200% = 48px 在这种多层嵌套的情况下，如果某一个计算结果不是整数，浏览器可能就会取整，子元素再继承取整后的值。如果嵌套很深，下层的字体大小就越来越偏离实际计算值。并且，由于参考基准总是随着元素发生变化，嵌套越深，计算起来也就越困难。 鉴于此，CSS3中新增的一个相对单位 rem（root em的简称），它总是以文档的根元素（即 html 元素）为参考基准，来设置其它元素的字体大小，即 1rem 相当于 html 元素 font-size属性的值。考虑以下代码： html { font-size: 10px;}p { font-size: 1.4rem;}上述声明中，p 元素的字体大小将是 html 字体大小的1.4倍，则计算得到 p 元素的字体大小就是1.4 × 10px = 14px。 这样一来，无论嵌套多少层，参考基准始终不变，计算字体大小就变得容易多了。不过，需要注意的是，rem 是CSS3新增的一个相对单位，IE9 以下版本的老浏览器却不支持它，这也是很多编程人员尚未使用 rem 的原因。 在定义字体大小时，笔者建议在 html 元素中定义绝大多数元素所需要的字体大小，并让所有子元素继承 html 的字体大小。如果某个子元素需要要改变字体大小，则使用相对尺寸 em 或 % 或 rem 重新定义。 这样做的好处是，一方面，绝大多数元素都不必定义字体大小，减少不必要的定义；另一方面，如果完成所有的文字排版后，又要统一调整页面文字大小，就可以只修改 html 中的字体大小，其它所有文字的字体大小会自动变化，修改起来就很容易。 在某些特殊场景下，需要把 font-size 的值设置为0，来隐藏某些文本。但是，在IE6和IE7中，font-size: 0 的文本却变成了小黑点，并没有完全隐藏。解决这个问题的最简单办法，就是在 font-size: 0 的同时，把 text-indent 属性设置为一个很大的负值，让这些文本显示在屏幕之外，自然就被隐藏起来。 3.1.3 字体粗细在CSS中，通过 font-weight属性 用来设置字体的粗细值，取值为 lighter | normal | bold | bolder，默认为 normal。lighter 为细体，normal 为正常粗细，bold 为粗体，bolder 为特粗体。如：123456789101112.lighter &#123; font-weight: lighter;&#125;.normal &#123; font-weight: normal;&#125;.bold &#123; font-weight: bold;&#125;.bolder &#123; font-weight: bolder;&#125; 1234&lt;p class=\"lighter\"&gt;字体粗细： lighter&lt;/p&gt;&lt;p class=\"normal\"&gt;字体粗细： normal&lt;/p&gt;&lt;p class=\"bold\"&gt;字体粗细： bold&lt;/p&gt;&lt;p class=\"bolder\"&gt;字体粗细： bolder&lt;/p&gt; 上述代码定义了 4 种不同粗细的字体，按顺序依次变粗。 为了实现更细致的控制，CSS也允许使用数字来设置字体的粗细。数字必须是100的整数倍，取值在100~900 之间，值越大字体越粗。400 等同于 normal，700 等同于 bold。 浏览器会自动为一些元素（如，strong、h1～h6 和b）添加粗体格式，有些元素还继承了父元素粗体格式，可以通过 font-weight: normal 来取消这些元素的粗体格式。 3.1.4 字体风格在CSS中，通过 font-style属性 来设置文本的字体风格，可选值有 normal | oblique | italic，默认为 normal。normal 表示正常文本；oblique 表示正常文本的倾斜版本；italic 表示斜体，斜体是一种单独的字体风格。 3.1.5 字体变形有时候，希望一篇文章中的英文单词或英文字母，无论是小写还是大写，统一变成大写，就可以使用 font-variant属性实现。 font-variant属性用来使英文字母变为小型大写字母，可选值有 normal | small-caps，默认值为 normal。normal 为正常的字体；small-caps 让字母变成小型大写字母，这意味着所有的小写字母均会被转换为大写，但字体更小。如：123456.normal &#123; font-variant: normal;&#125;.small-caps &#123; font-variant: small-caps;&#125; 12&lt;p class=\"normal\"&gt;This is a paragraph&lt;/p&gt;&lt;p class=\"small-caps\"&gt;This is a paragraph&lt;/p&gt; 上述代码定义了 2 个段落，第一个段落文本正常显示，第二个段落文本变为大写并缩小显示。 font-variant属性只把段落中的小写字母变为大写，并缩小显示，而段落中的大写字母依然保持原样，没有进行转换。这样一来，转换出来的大写字母，比实际的大写字母尺寸要小，显得不太协调。所以，在转换对象中，建议不要包含大写字母。 3.1.6 字体拉伸font-stretch属性用来将字体在水平方向上进行拉伸或压缩，让一种字体的字符更宽或更窄。如果水平压缩，则字体变窄，如果水平拉伸，则字体变宽。 就像 font-size 属性的预定义关键字（如xx-large）一样，该属性也有一系列预定义关键字，这些关键字可以是normal、或condensed、或expanded，默认值为 normal，表示不进行拉伸或压缩。 这些关键字的值按照以下顺序，字体依次由窄到宽：ultra-condensed、extra-condensed、condensed、semi-condensed、normal、semi-expanded、expanded、extra-expanded、ultra-expanded。 3.1.7 字体调整设计师也会经常遇到一种情况，就是精心设计好的页面，如果改变字体的种类，页面上使用该字体的文本尺寸将发生变化，从而导致原来安排好的页面产生混乱，这是设计者不愿意看到的结果。 一种字体的 x-height（即，小写字母 ‘x’ 的高度）与 font-size 高度的比值，称作该字体的 aspect值，它决定了文本的显示尺寸。 在相同的 font-size 取值下，字体拥有的 aspect 值越大，文本的显示尺寸就越大，就越容易阅读。 如，Verdana 字体的 aspect 值是0.58，Times 字体的 aspect 值是 0.46。也就是说，当 font-size 为 100px 时，Verdana 字体的 x-height 是 58px，而 Times 字体的 x-height 是 58px，这就意味着 Verdana 字体比 Times 字体更易阅读。 在指定字体时，出于安全考虑，人们通常会为一个元素指定多种字体，希望当首选字体不可用时，让浏览器自动使用备选字体。 如，以下样式将 Verdana 字体作为段落的首选字体，当 Verdana 字体不可用时，则使用 Georgia 字体，当 Georgia 字体不可用时，则使用 Times 字体：123p &#123; font-family: Verdana, Georgia，Times;&#125; 由于 Georgia 和 Times 字体比 Verdana 字体的 aspect 值要小，当使用备选字体时，必然会影响文本的易读性，甚至导致页面布局产生混乱。 为了避免这种情况，在CSS 3中，新增加了 font-size-adjust属性。目前，仅得到 Firefox 浏览器的支持。 实际应用中，只需把 font-size-adjust属性的值，设置为首选字体的 aspect 值，就可以保证使用备选字体后，文本的显示尺寸不发生变化。 设置 font-size-adjust属性后，浏览器将不再使用所设置的 font-size 属性的值来显示文本，而是根据 font-size-adjust属性、font-size 属性的值，及备选字体的 aspect 值，重新计算文本的 font-size 值，并用这个计算值来显示文本。计算公式如下： c = ( a / a’ ) s 其中： c = 实际使用的 font-size 值 a = font-size-adjust属性的值，即首选字体的 aspect 值 a’ = 备选字体的 aspect 值 s = font-size 属性的值 也就是说，假设首选字体 Verdana 不可用时，浏览器将使用 Times 字体，只需为使用 Times 字体的元素设置 font-size-adjust属性，并设置为首选字体的 aspect 值，就可以保证使用备选字体后，文本的显示尺寸不发生变化：1234p &#123; font-family: Verdana, Times; font-size-adjust: 0.58;&#125; 设置 font-size-adjust属性后，在渲染页面时，浏览器将执行以下步骤，来计算备选字体实际所使用的 font-size 值： 1）查得 font-size-adjust属性的值为 0.58。 2）查得备选字体 Times 的 aspect 值为 0.46。 3）将 0.58 除以 0.46，得到近似值 1.26。 4）再将 100 乘以1.26，得到 font-size 的计算值 126px。 然后，浏览器将使用 font-size 的计算值 126px 来显示备选字体，也就是说，100px 的Verdana字体跟 126px 的 Times 字体的显示尺寸相当。 除了让备选字体和首选字体具有相同的显示尺寸外，还有一种情况，就当两种字体并存且都可用时，也可以通过font-size-adjust属性，让它们具有相同的显示尺寸。 假设在一个段落中有两个 span 元素，为了方便对比，在每个 span 元素中包含一个小写字母 ‘b’：1&lt;p&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;/p&gt; 两个 span 元素的字体大小都是 100px，而它们使用的字体不同，第一个 span 元素使用 Verdana 字体，第二个 span 元素使用 Times 字体：123456789p &#123; font-size: 100px;&#125;span:nth-child(1) &#123; font-family: Verdana;&#125;span:nth-child(2) &#123; font-family: Times;&#125; 即便使用相同的 font-size，由于 font-family 的不同，文本在浏览器中的显示尺寸也会不同，右侧 Times 字体的文本，显然比左侧 Verdana 字体的文本要小。 同理，可以把一个元素的 font-size-adjust属性，设置为期望字体的 aspect 值，就可以保证它和期望字体具有相同的显示尺寸。 如，希望第二个 span 元素中文本，与第一个 span 元素中文本的显示尺寸相同，就要把第二个元素的 font-size-adjust属性，设置为 Verdana 字体的 aspect 值：1234span:nth-child(2) &#123; font-family: Times; font-size-adjust: 0.58;&#125; 使用 font-size-adjust属性调整后，两种字体就具有相同的显示尺寸，就能保证在改变字体时，不会影响文本的易读性，也不会导致页面混乱。 3.1.8 @font-face多年以来，人们一直被迫使用一组单调乏味的Web安全字体。当网页中需要使用一些优雅的字体时，设计师最常用的办法，就是把文字做成图片。但是，由于图片难以修改，也不利于网站SEO，因此不可能大范围使用该字体。 值得庆幸的是，CSS3的 @font-face 为设计师打开了一个全新的世界，它提供了一种自定义网页字体的方法，使设计师可以大胆使用任意自己想要的字体。 事实上，@font-face规则在CSS2中就已经存在，但随后在CSS2.1中被删除。真的，不骗你，早在1998年，IE4就对它提供了部分支持。现在，它又回来了，已经被重新引入到CSS3的字体模块中！ @font-face是一个CSS功能，它允许网页中使用自定义的网络字体，这些自定义的字体被放置在服务器上，从而摆脱对访问者计算机上字体环境的依赖。 简单的说，有了@font-face，只需将字体上传到服务器端，无论访问者计算机上是否安装该字体，网页都能够正确的显示。 @font-face 能够让加载服务器端的字体，并让浏览器找到对应的字体，得益于一套成熟的语法规则：123456@font-face &#123; font-family: &lt;fontName&gt;; src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; font-style: &lt;style&gt;; font-weight: &lt;weight&gt;;&#125; 其中，font-family 属性用来指定网络字体的名称，它可以是任意的字符串，建议最好使用字体本身的名称。font-* 属性分别表示该网络字体的风格和粗细。source 属性用来指定网络字体文件的存放路径，可以是相对路径或绝对路径；formart 属性用来指定网络字体的格式字符串，不同格式字符串对应的字体格式和后缀名见表 格式字符串 字体格式 后缀名 “woff” WOFF 格式 .woff “truetype” TrueType格式 .ttf “opentype” OpenType格式 .ttf, .otf “embedded-opentype” Embedded OpenType格式 .eot “svg” SVG Font格式 .svg, .svgz 要在网页中使用自定义的网络字体，必须先将字体文件上传到服务器的某个地方，然后，再使用 @font-face 规则定义网络字体。 定义网络字体时，font-family 和 src 都是必需的属性，通过 font-family 指定字体的名称，通过 src 指定字体资源文件的存放路径：1234@font-face &#123; font-family: DroidSans; src: url(DroidSans.woff);&#125; 上述代码定义了一个网络字体，字体名称为DroidSans，字体文件为DroidSans.woff，并与CSS文件保存在相同目录中。 不过，这里定义的字体并不会有任何实际效果，因为还没有真正将它应用到网页中。要将网络字体 DroidSans 应用到网页中，还需在CSS选择器中，将 font-family 属性的值设置为 @font-face规则中定义的字体名称。如：123h1 &#123; font-family: DroidSans;&#125; 定义网络字体后，页面上任何引用该字体的元素，都将按该规则来渲染文本。因此，页面上的所有 h1 标题，都将使用自定义的DroidSans字体进行渲染。并且，对于 h1 标题，浏览器默认还会使用粗体显示。 然而，此时呈现的粗体，并不是真正的粗体，而是伪粗体，这是因为一个网络字体文件只对应一种风格、一种粗细。因此，要使用真正的粗体，还需要单独创建一个@font-face规则，在该规则中对 font-family 进行重命名，并提供粗体对应的字体文件，同时将 font-weight 属性设置为 bold：12345@font-face &#123; font-family: DroidSans_bold; src: url(DroidSans_bold.woff); font-weight: bold;&#125; 同理，如果要使用斜体加粗体，还要单独创建另一个@font-face规则，并提供粗斜体对应的字体文件，同时将 font-style 属性设置为 italic，font-weight 属性设置为 bold。当然，如果某种Web 字体没有粗体、斜体、或粗斜体版本，而我们又对文本添加了这些样式，浏览器就会显示伪样式。 一个现实的问题是，虽然具有许多不同格式的Web字体，但各种浏览器仅支持这些格式的不同子集。因此，为了得到更多浏览器的支持，一个折中的办法是提供多种字体，并在@font-face规则中定义多个url，中间用逗号隔开。如果浏览器无法识别第一个字体，它会依次尝试后面的字体，直到找到一个可用的字体为止。如，下面的写法几乎可以让所有浏览器都有一个可用的字体：12345678@font-face &#123; font-family: 'webFont'; src: url('webFont.eot'); /* IE9 兼容模式*/ src: url('webFont.eot?#iefix') format('embedded-opentype'), /* IE6~IE8 */ url('webFont.woff') format('woff'), /* 现代浏览器 */ url('webFont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webFont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125; 当然，需要注意的是，字体文件可能比较大，并且每增加一个样式和粗细版本都会引入一个新的字体文件，每个文件都需要额外的HTTP请求，从而影响性能。所以，在使用网络字体前，需要仔细斟酌，判断是否真的有必要在自己的网站上使用它，以及如何正确使用它。 除了将网络字体应用于文本外，还可以使用网络字体在网页上绘制图标。网上有很多字体图标资源，比如在Bootstrap中，可以使用Glyphicon Halflings 或Font Awesome等字体图标。 下面以Glyphicon Halflings 字体为例，来说明一下如何在网页中使用字体图标。假设在网页上有 5 个span 元素，使用Glyphicon Halflings字体，在每个 span 元素中生成一个播放器按钮图标：1&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt; 首先，下载Glyphicon Halflings的字体文件。Glyphicons Halflings 一般是收费的，但他们的作者允许 Bootstrap 免费使用（向作者致敬）。因此，可以从Bootstrap官网下载编译后的Bootstrap版本，在 fonts 目录中就包含四种格式的Glyphicon Halflings字体文件。 然后，在CSS中，通过@font-face规则定义网络字体，并在 span 元素中使用该字体。同时，根据网站的配色风格，设定合适的文本颜色：123456789101112@font-face &#123; font-family: 'Glyphicons Halflings'; src: url('bootstrap/fonts/regular.eot'); src: url('bootstrap/fonts/regular.eot?#iefix') format('embedded-opentype'), url('bootstrap/fonts/regular.woff') format('woff'), url('bootstrap/fonts/regular.ttf') format('truetype'), url('bootstrap/fonts/regular.svg#regular') format('svg');&#125;span &#123; color: #444; font-family: 'Glyphicons Halflings';&#125; 字体图标的原理，基本都是使用字符或实体字符来生成字体图标。因此，就可以使用伪元素，在元素的前面或后面，插入特定的字符或实体字符，就能得到相应的图标。不同的字体，插入的字符可能不同，Glyphicon Halflings字体中，播放器按钮对应的字符如下：123456789101112131415span:nth-child(1):before &#123; content: \"\\e069\";&#125;span:nth-child(2):before &#123; content: \"\\e071\";&#125;span:nth-child(3):before &#123; content: \"\\e072\";&#125;span:nth-child(4):before &#123; content: \"\\e075\";&#125;span:nth-child(5):before &#123; content: \"\\e077\";&#125; 使用字体图标的好处是，如果要改变网站的配色风格，只需修改字体的颜色即可，非常方便。如果使用图像，要重新制作所有图标，非常麻烦。并且，字体图标还可以自由缩放而不会失真，而图像在缩放时可能会失真。 3.2 文本CSS提供了许多强有力的文本格式化工具，可以用来设定字体、颜色、字号、行距的呢过，它还有许多其他属性，可以给标题、列表、段落等添加视觉效果。 3.2.1 文本缩进在CSS中，使用 text-indent属性，可以让元素第一行缩进一个给定的宽度，可能是最常见的文本格式化效果。语法格式为：1text-indent: &lt;length&gt; | &lt;pecentage&gt; 也就是说，可以使用长度值或百分比来设置文本缩进，长度值可以使用绝对单位或相对单位。当使用相对单位 em 时，缩进的宽度为字符宽度的倍数，字符宽度根据当前元素的 font-size 属性计算得到。 当然，这个属性最常见的用途，是让段落的首行缩进一个给定的宽度。如，以下规则会使所有段落的首行缩进 2 个字符的宽度：123p &#123; text-indent: 2em;&#125; 当使用百分比时，缩进宽度根据元素父元素的宽度计算得到。换句话说，如果将缩进值设置为 20%，则所影响元素的第一行会缩进其父元素宽度的 20%。 不过，在使用百分比时，需要注意的是，text-indent属性具有继承性，而子元素继承的是 text-indent属性的计算结果，而不是百分比的值。考虑如下代码：1234&lt;article&gt; 使用百分比时，…，则缩进父元素宽度的 20%。 &lt;p&gt;在使用百分比时，…，它可能会出现预料不到的效果。&lt;/p&gt;&lt;/article&gt; 12345678article &#123; width: 500px; text-indent: 10%; border: 1px solid #ccc;&#125;p &#123; width: 400px;&#125; 上述代码中，article元素的宽度为500px，并设置文本缩进为 10%。根据继承性，p 元素会继承 article 元素的 text-indent属性。 子元素 p 与父元素 article 的文本缩进宽度相同，因为子元素继承的是 text-indent属性的计算结果 50px，而不是百分比的值 10%。 除了使用正值产生缩进效果外，还可以把 text-indent属性设置为负值，来实现一些很有用的效果，比如悬挂缩进的效果：123p &#123; text-indent: -2em;&#125; 上述规则会使所有段落的首行悬挂缩进 2 个字符的宽度。当然，有时候，希望文本不可见，也可以使用 text-indent属性把文本显示到屏幕之外。 不过，在为 text-indent属性设置负值时要当心，如果对段落设置了负缩进，那么首行的某些文本可能会超出窗口的左边界。为了避免出现这种问题，建议针对负缩进再设置适当的外边距或内边距。 一般来说，可以为所有块级元素应用 text-indent属性，但无法将该属性应用于行内元素、及图像之类的替换元素。但是，如果一个块级元素的首行中有一个图像，图像也会随该行的其余文本而移动。 3.2.2 水平对齐在一个块级容器中，当一行中的行内级框的总宽度，小于容器的宽度时，通过 text-align属性来指定这些行内级框在行中的水平分布。 事实上，text-align属性是通过指定行框与哪个点对齐，来决定行内级框在行中如何进行水平分布。可选值有 left | center | right | justify | start | end，默认值为start。不同取值的含义见表 属性值 含义 left 左对齐，所有行内级框的左边缘与容器的左边缘重合 center 居中对齐，所有行内级框的中线与容器的中线重合 right 右对齐，所有行内级框的右边缘与容器的右边缘重合 justify 两端对齐，所有行内级框的左右两端都在容器的内容边界上 start 起始边界对齐，所有行内级框的起始边缘与容器的起始边缘重合 end 结束边界对齐，所有行内级框的结束边缘与容器的结束边缘重合 当取值为 start 和 end 时，对齐的位置跟文本流的书写方向有关，书写方向不同，其对齐的位置也不同。对于从左到右的内容，start和left等价，end和right等价；对于从右到左的内容，start和right 等价，end和left等价。大多数情况下，文本流的默认书写方向为从左到右，而希伯来语和阿拉伯语等的默认书写方向为从右到左。 text-align属性只能应用于块级元素，它的最典型应用，就是指定段落中每一行内容的水平对齐方式。 段落是一个块级容器，容器中的每一行内容都会生成一个行框，就可以把段落看做是这些行框的堆叠。由于并非每一行的内容都能填满容器的宽度，因此，就可以通过 text-align属性，来指定每一行中内容的水平对齐方式。假设有四个段落，代码如下：1234&lt;p&gt;&lt;span&gt;The text-align property … aligned.&lt;span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;The text-align property … aligned.&lt;span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;The text-align property … aligned.&lt;span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;The text-align property … aligned.&lt;span&gt;&lt;/p&gt; 为了便于观察，把段落的文本显示包含在行内元素 span 中。通过限制 p 元素的宽度，使文本在两行内显示，并为 span 元素添加背景，为 p 添加边框：1234567p &#123; width: 400px; border: 1px dashed #ccc;&#125;span &#123; background: #ddd;&#125; 为上述段落应用不同的 text-align属性值，让第一个段落左对齐，第二个段落居中对齐，第三个段落右对齐，第四个段落两端对齐:123456789101112p:nth-child(1) &#123; text-align: left;&#125;p:nth-child(2) &#123; text-align: center;&#125;p:nth-child(3) &#123; text-align: right;&#125;p:nth-child(4) &#123; text-align: justify;&#125; 并不是每一个文本行都到达容器内容区的边界。对于左对齐的段落，每一行的左边缘，都与容器内容区的左边界对齐，空白分布在容器的右侧。右对齐则恰好相反。居中的段落，文本行的中心与容器的中心对齐，空白在容器的左右两侧均匀分布。取值 justify 时，每一个文本行的左右两端都在容器的内边界上，没有空白。 text-align: justify是通过调整单词或字符间距，使各行的长度恰好相等，来实现两端对齐。由于 text-align: justify 对最后一行文本无效，因此，对单行文本也无效。 3.2.3 水平对齐text-align-last属性用于定义块级容器中，行内元素的最后一行内容的水平对齐方式，可选值有 auto | left | center | right | justify | start | end | start | end，默认值为 auto。 除 auto外，其它取值与 text-align 属性取值的含义相同。auto 表示使用 text-align 的设定（例外情况，text-align 取值为 justify 时，text-align-last属性的值为 start）。 目前，只有 IE 浏览器支持 text-align-last属性。继续上一节的例子，现在让最后一行文本居中对齐，其他文本行右对齐：123456p &#123; width: 400px; text-align: right; text-align-last: center; border: 1px dashed #ccc;&#125; 3.2.4 行高在CSS中，通过 line-height属性来定义行高，行高是指相邻两行文本基线之间的垂直距离。 那什么是基线呢？对任何一个行内非替换元素，其内容区都会存在四条假想的线，分别是底线（bottom）、基线（baseline）、中线（middle）、顶线（top），它们就类似于书写英文时的四线三格。 尽管在字体大小发生改变时，这些线相互之间的距离也会随之改变，但无论如何，这四条线的位置是确定的。底线就是 g、j、y 等字母的底边线，基线就是 a、c、x 等字母的底边线，中线是小写字母 x 垂直中线（即基线往上 0.5ex 的位置），顶线是 b、h、j 等字母的顶边线。 如果在一个块级元素上声明 line-height 值，这个值将会应用到块中的所有内容，而不论内容是否包含在行内元素中，即对匿名行内框也依然有效。所以，常常为一个段落元素声明 line-height 值，来指定段落每行文本的行高。 由于 line-height属性具有继承性，因此，可以只在父元素中定义 line-height 规则，而不必在所有子元素中显式地声明 line-height。 line-height属性可以用百分比、长度值、数值进行定义，其值可以是正值，也可以是负值： 1）百分比：根据元素本身的 font-size 计算值的百分比计算行高。如，段落的 line-height属性值为 200%，段落元素的 font-size 为 14px，则行高为 200% * 14px = 28px。 2）长度值：设置固定的行高，可以使用绝对单位或相对单位。若使用相对单位em，则根据元素本身的 font-size 计算值的倍数计算行高。如，段落的 line-height属性值为 2em，段落元素的 font-size 为 14px，则行高为 200% * 14px = 28px。 3）数值：根据元素本身的 font-size 计算值的倍数计算行高。如，段落的 line-height属性值为 2，段落元素的 font-size 为 14px，则行高为 2 * 14px = 28px。 当使用百分比或长度单位时，子元素继承的是计算出来的行高的值，这就导致子元素无法根据自身的 font-size 自动调整行高，当子元素使用的字号比父元素大时，子元素可能出现文本重叠现象，故这种方法将被淘汰。 使用数值时，尽管子元素也会继承，但继承的是该数值本身，而不是计算出来的行高。这样一来，子元素就可以根据自身的 font-size 来调整行高，不会出现文本重叠现象。所以，使用数字，是设置行高最理想的方法。 无论使用百分比、长度值、数值中的哪种方式，都可以在 font 属性中，使用缩写方式来定义 line-height，其写法是 line-height 的值紧跟在字体大小和一个斜杠后面。如：123body &#123; font: 14px/2 arial;&#125; 上述写法就等价于：12345body &#123; font-size: 14px; line-height: 2; font-family: arial;&#125; 根据CSS规范，line-height属性只会影响行内元素，而不会直接影响块级元素，但却会影响块框的布局。在块级元素上声明 line-height属性，是为该块级元素中的行内框设置一个最小行高，而不是实际行高。 3.2.5 垂直对齐在CSS中，行框的高度总是足以容纳它包含的所有行内级框，当一个行内级框 B 的高度小于包含它的行框高度时，则由 vertical-align属性 来决定B在行框中垂直对齐的位置。因此，vertical-align属性只对行内级元素有效，对块级元素无效。并且，该属性不能被子元素继承。 在垂直对齐时，行内非替换元素的行内级框是由 line-height 的高度定义的框，即在内容区的上下各添加半行距后的框；其他行内级元素的行内级框是由 margin-box 定义的框。因此，对一个行内级框来说，top 是指框的上边界，bottom 是指框的下边界，text-top 是指内容区的上边界，text-bottom 是指内容区的下边界。 由于替换元素没有 baseline，因此，就把它的 bottom 作为 baseline，即 baseline 和 bottom 的位置相同。 middle 是指框高度一半的位置，对于替换元素，就是 height 的一半的位置，而非替换元素则是基于 baseline 往上移动 0.5ex，即小写字母 x 的正中心。但是，很多浏览器往往把 ex 这个单位定义为0.5em，导致 middle 其实不一定是 x 的正中心。vertical-align属性可以使用长度值、百分比、或预定义关键字，来定义行内级框的垂直对齐方式。该属性的默认值是 baseline，也就是说，默认情况下，所有行内级框的基线都与父元素的基线对齐。 使用长度值和百分比时，通过让行内级框的基线相对父元素的基线，升高或降低指定的距离，来决定行内级框在行框中的位置。距离可以是正值，也可以是负值。正值使行内级框相对父元素的基线升高，负值则降低。 使用长度值时，可以使用绝对单位或相对单位，来指定升高或降低的距离，0cm 等同于 baseline。假设在一个段落中，包含一个 span 元素：1&lt;p&gt;xgh&lt;span&gt;&lt;span&gt;xgh&lt;/p&gt;&lt;/code&gt; 假设设置段落的字体大小为 120px，span 元素的字体大小为 40px、vertical-align 的值为 20px：1234567p &#123; font-size: 120px;&#125;span &#123; font-size: 40px; vertical-align: 20px;&#125; 由于vertical-align 的值为 20px，所以，行内框 span 的基线相对父元素的基线升高 20px。 使用百分比时，升高或降低的距离是根据行内元素的 line-height 进行计算，0% 等同于 baseline。 如果把 span 元素的 line-height 设置为 1，vertical-align 设置为 50%，则得到的行高为 40px，进而得到升高的距离为 50% * 40px = 20px，也会得到相同的效果。 span { line-height: 1; font-size: 40px; vertical-align: 50%;}使用预定义关键字时，是根据预定义的对齐准则，来决定行内级框在行框中的位置。预定义关键字有 baseline | sub | super | top | text-top | middle | bottom | text-bottom，默认值为baseline。根据W3C规范，不同取值的含义见表 属性值 含义 baseline 基线对齐。行内框的基线与父元素的基线对齐 sub 下标对齐。将行内框的基线下降到父元素适合下标的位置 super 上标对齐。将行内框的基线上升到父元素适合下标的位置 top 顶部对齐。行内框的顶线与行框的顶线对齐。 text-top 文本顶部对齐。行内框的顶线与父元素的text-top对齐 middle 居中对齐。行内框的中线与父元素的中线对齐 bottom 底部对齐。行内框的底线与行框的底线对齐 text-bottom 文本底部对齐。行内框的底线与父元素的text-bottom对齐 基线对齐要求一个行内级框的基线与行框的基线对齐，而对于图像和表单输入元素和其他替换元素，由于它们本身没有基线，则将它们的底线与行框的基线对齐。这就使得浏览器总把替换元素的底线放在基线上，即便该行中没有其他文本。 上标对齐和下标对齐时，是行内元素的基线（图片和文本输入框的底线）相对于行框的基线上移或下移。而行内元素基线相对于行框的基线移动的距离，CSS规范中未明确规定，由浏览器自行决定，可能会因为浏览器的不同而不同。从上图的运行结果看，在Google Chrome浏览器下，移动的距离约为 1ex。 middle居中对齐，是行内元素的中线与行框的中线对齐。前面已经介绍，元素的中线与基线的距离为小写字母x高度（即ex）的一半，而大部分浏览器简单的认为1ex = 1em，因此会将基线以上二分之一em处（其实不一定是x的正中心），作为文本的中线。前面已经介绍，一个框的高度是由line-height决定的，如果增加行高，框的高度会增加，顶线就会上移，底线会下移。无论底线下移多少，bottom对齐，始终是元素的底线与行框的底线对齐；top对齐，始终是元素的顶线与行框的顶线对齐。增加行高时，行框的高度会增加，但内容区的高度始终保持不变，text-top对齐就是行内元素的顶线与行框文本的顶线对齐。 垂直对齐的预定义关键字看似简单，其实很难理解，处理起来也很棘手。下面通过一个简单实例，来看看每个预定义关键字的效果。假设在一个段落中，有 8 个 span 元素：1&lt;p&gt;xgh&lt;span&gt;baseline&lt;/span&gt;…&lt;span&gt;top&lt;/span&gt;&lt;/p&gt; 为段落定义 1.8 倍的行距，并让每个子元素 span 以不同的方式垂直对齐。由于子元素 span 会继承父元素的 line-height 属性，因此，把 span 元素的行距重置为1：123456789101112131415161718p &#123; line-height: 1.8; font-size: 90px; font-family: \"Times New Roman\"; border: 1px solid #444;&#125;span &#123; line-height: 1; color: #00f; font-size: 20px;&#125;span:nth-child(1) &#123; vertical-align: baseline;&#125;…span:nth-child(8) &#123; vertical-align: top;&#125; 3.2.6 字符间距letter-spacing属性用来增加或减少字符或汉字之间的距离，默认值为0。该属性接受一个的正长度值或负的长度值；设置一个正的长度值时，字符之间的间隔会增加；设置一个负的长度值时，字符之间的间隔会减少，让字符挤得更紧，甚至出现重叠。 对于字数较少，却又要突出表现的内容，如诗词等，可以根据需要，增加适当的字符间距，让内容稍微稀疏一点，会比较美观。如，对于下面这首古诗：1234&lt;h1&gt;静夜思&lt;/h1&gt;&lt;h2&gt;唐•李白&lt;/h2&gt;&lt;p&gt;床前明月光，疑是地上霜。&lt;/p&gt;&lt;p&gt;举头望明月，低头思故乡。&lt;/p&gt; 希望 h1 标题和正文的内容稀疏明朗，就可以使用 letter-spacing属性来实现。CSS代码如下：123456h1 &#123; letter-spacing: 10px;&#125;p &#123; letter-spacing: 3px;&#125; 3.2.7 单词间距word-spacing属性用来增加或减少单词之间的距离，默认值为0。该属性接受一个正的长度值或负的长度值；设置一个正的长度值时，单词之间的间隔会增加；设置一个负的长度值时，单词之间的间隔会减少，让单词挤得更紧，甚至出现重叠。 因为该属性把由空白符包围的一个字符串看作一个单词，而汉字之间没有空格，所以该属性对中文无效。但是，如果在汉字中人为添加空格，则会把空格前后的汉字按单词处理，该属性会生效。 在上一节字符间距的例子中，整个古诗被设置为在容器中居中显示。细心的读者可能已经发现，h1 标题和 h2 标题的中线，并没有完全对齐。 没有对齐的原因，跟我们的实现方式有关，因为使用 letter-spacing 属性让标题稀疏明朗，而 letter-spacing 属性则是通过在每个字符的后面插入指定的空间，来调整字符间距的。所以，h1 标题的最后一个字符‘思’的后面被插入了一个 10px 的空间，而 h2 标题并未插入任何内容，其结果就导致 h1 标题和 h2 标题的中线不能完全对齐。 要解决这个问题，可以人为在 h1 标题的汉字之间插入一个空格，再通过 word-spacing 属性来调整单词间距，让 h1 标题完美居中。如：1&lt;h1&gt;静 夜 思&lt;/h1&gt; 在 h1 标题的汉字之间插入空格后，经过调整后，h1 标题和 h2 标题的中线已经完全对齐。这个问题，本身是一个细小的问题，常常被设计师所忽视。 然而，在一个严谨的设计师眼里，往往没有小问题，所有问题都是大问题。并且，对于任何问题，都会刨根问底，找到问题背后的根源。因为只有这样，才能彻底解决问题。 3.2.8 文本转换英文字母的大小写转换，是CSS提供的非常实用的功能之一，文本的大小写转换在空格处理之后进行。文本转换对中文无效，因为中文不存在大小写。 在CSS中，使用 text-transform属性来对文本进行大小写转换，取值为 none | capitalize | uppercase | lowercase | full-width，默认为 none。 none 表示无转换，保持原样；capitalize 表示将每个单词的首字母转换成大写，其它字符不变；uppercase 表示将文本的所有字符转换成大写；lowercase 表示将文本的所有字符转换成小写；full-width 表示将所有字符转换成全角形式（全角占两个字节，半角占一个字节），如果字符没有全角形式，将保持原样，其典型用途是将拉丁字符及数字排版为表意字符形式。如： 假设使用 text-transform属性，定义了四种不同的文本转换类型。如：123456789101112.capitalize &#123; text-transform: capitalize;&#125;.uppercase &#123; text-transform: uppercase;&#125;.lowercase &#123; text-transform: lowercase;&#125;.full-width &#123; text-transform: full-width;&#125; 把上述四种文本转换类型，应用到特定的文本，即可实现相应的文本转换特效。如：1234&lt;p class=\"capitalize\"&gt;text-transform: capitalize&lt;/p&gt;&lt;p class=\"uppercase\"&gt;text-transform: uppercase&lt;/p&gt;&lt;p class=\"lowercase\"&gt;text-transform: lowercase&lt;/p&gt;&lt;p class=\"full-width\"&gt;text-transform: full-width&lt;/p&gt; 由于不同的浏览器，对单词的理解可能不同。比如，对于文本“text-transform”，Google Chrome浏览器会把它整体看作一个单词，而Firefox浏览器把它看作是“text”和“ransform”两个单词，中间用连字符连接。 因此，在 text-transform属性取值为 capitalize 时，在Google Chrome中得到的结果是 “Text-Transform”，而在Firefox中得到的结果是“Text-transform”。而CSS规范并没有明确规定使用哪一种转换方式，所以它们都是正确的结果。 此外，取值 full-width 是CSS3的新增的属性值，目前仅得到Firefox浏览器的支持。 使用 text-transform属性的好处是，如果你需要将哪些元素变成大写，则无需修改元素的内容，只需使用CSS就可以完成。这也是CSS优越性的再一次体现。 3.2.9 文本装饰在CSS中，使用 text-decoration属性，可以在文本上方、下方、或中间添加装饰线，可选值为 none | underline | overline | line-through | blink，默认值为 none。none 无装饰，underline 下划线 ，overline 上划线，line-through 文字中间贯穿线，blink 闪烁。装饰线的颜色与文本的颜色相同。 默认情况下，文本都是没有装饰线的，但超链接是个例外，它默认就带有下划线。当然，可以把 text-decoration属性的值设置为 none，去掉超链接的下划线，当鼠标悬停后，再添加下划线，来提醒用户当前文本为链接文本。如：123456a &#123; text-decoration: none;&#125;a:hover &#123; text-decoration: underline;&#125; 文本装饰线的另一个常见用法，就是修订文本，在被删除文本上增加删除线。还有团购网站，在原价上增加删除线，做删除状。其实，还可以使用 text-decoration属性，为文本同时添加多条装饰线。如：123p &#123; text-decoration: underline overline line-through;&#125; 上述规则会为段落文本同时增加上划线、下划线和中间贯穿线。 3.2.10 文本阴影在CSS3之前，除非使用图片，否则无法给文本添加阴影效果。现在，使用text-shadow属性，可以为文本添加一个或多个阴影及模糊效果。语法格式为：1text-shadow: x-offset y-offset blur color; 各参数的含义见表 参数 含义 x-offset 必选参数，长度值，表示阴影在x轴的偏移量。可以是正值，也可以是负值。为正值时，阴影向右偏移，阴影在文本的右侧；为负值时，阴影向左偏移，阴影在文本的左侧 y-offset 必选参数，长度值，表示阴影在y轴的偏移量。可以是负值，也可以是负值。为正值时，阴影向下偏移，阴影在文本的下方；为负值时，阴影向上偏移，阴影在文本的上方 blur 可选参数，长度值，表示阴影的模糊距离，即阴影从开始变淡到完全消失的距离，不允许负值。值越大，阴影的边缘越模糊。如果不指定，则使用默认值0，表示不具有模糊效果 color 可选参数，表示阴影的颜色。如果不指定，则使用文本的颜色 不管是偏移，还是模糊，都不会改变元素本身的尺寸。因此，发生偏移、模糊后，阴影可能会超出元素本身，延伸到元素的边界之外。 除了单阴影外，还可以使用逗号分隔的阴影列表，为文本设置多重阴影效果。通过多重阴影的叠加，可以实现很多有趣的效果。如，word中的空心文字、阳文、阴文这些文本特效，都可以通过多重阴影来实现。 在文本的上、下、左、右四个方向各添加1px的黑色阴影，可以实现空心文字效果；在文本的左上和右下各添加 1px的错位补色阴影，可以实现阳文文字效果；把阳文的左上和右下的阴影颜色颠倒，即可实现阴文文字效果。CSS代码如下：123456789.stroke &#123; text-shadow: -1px 0 #000, 0 1px #000, 1px 0 #000, 0 -1px #000;&#125;.outset &#123; text-shadow: -1px -1px #fff, 1px 1px #333;&#125;.inset &#123; text-shadow: 1px 1px #fff, -1px -1px #333;&#125; 在网页中，只需把这三种不同的阴影，应用到特定的文本，即可实现相应的文本特效。HTML代码如下：123&lt;p class=\"stroke\"&gt;空心文本&lt;/p&gt;&lt;p class=\"outset\"&gt;阳文文本&lt;/p&gt;&lt;p class=\"inset\"&gt;阴文文本&lt;/p&gt; 在指定文本阴影时，阴影的颜色可以接受任意合法的CSS颜色值，如预定义颜色名、十六进制数值、RGB值、RGB百分比、RGBA值、HSL值、HSLA值。 需要注意的是，浏览器必须同时支持RGB和HSL颜色模式，及 text-shadow属性，才能渲染出阴影效果。考虑到浏览器的兼容性，一般会这样声明：12text-shadow: 4px 4px #404442;text-shadow: 4px 4px hsl(140, 3%, 26%, 0.4); 也就是先定义一个使用十六进制颜色的阴影，作为对老浏览器的备用颜色。然后，再为现代浏览器定义一个使用RGBA、HSL和HSLA颜色的阴影。 3.2.11 文本方向对于英文或中文等语言，默认是从左到右、从上到下进行阅读。然而，并非所有语言都是如此，还有许多从右向左阅读的语言，如阿拉伯语和希伯来语等。 于是，CSS2.1引入了 direction属性，用来定义文本流的书写方向，可选值有 ltr | rtl，默认值为 ltr。ltr（left-to-right）表示文本流从左到右书写，rtl（right-to-left）表示文本流从右到左书写。 direction属性影响块级元素中文本的书写方向，但不会影响拉丁文的字母数字字符，它总是从左到右书写，但会影响拉丁文的标点符号。对于行内元素，只有当 Unicode-bidi 属性设置为 embed 或 bidi-override 时才有效。不支持双向文本的浏览器可以忽略这个属性。 这里定义两个类，一个类的 direction属性设置为 ltr，一个类的 direction属性设置为 rtl。CSS代码如下：123456.ltr &#123; direction: ltr;&#125;.rtl &#123; direction: rtl;&#125; 然后，把这两个类应用到两个段落，让第一个段落中的文本从左到右书写，让第二个段落中的文本从右到左书写。HTML代码如下：12&lt;p class=\"ltr\"&gt;left-to-right direction.&lt;/p&gt;&lt;p class=\"rtl\"&gt;right-to-left direction.&lt;/p&gt; 3.2.12 处理空白符white-space属性用来设置文本内空白符（如空格、回车、tab字符等）的处理方式，可选值有 normal | pre | nowrap | pre-wrap | pre-line，默认值为 normal。该属性出自 CSS1，在 CSS 2.1中新增了属性值 pre-wrap 和 pre-line。不同取值的含义见表 属性值 含义 normal 忽略空白符[1]，但保留换行符，即碰到容器边界时自动换行 pre 保留所有空白符[2]，即便文本超出容器边界也不换行。其行为类似HTML中的&lt;pre&gt;标签 nowrap 忽略空白符，但始终在同一行内显示所有文本，直到文本结束或者遇到标签 pre-wrap 保留所有空白符，但保留换行符，即文本碰到容器边界时自动换行 pre-line 合并空白符序列[3]，但保留换行符，即文本碰到容器边界时自动换行 [1] 忽略文本开头、结尾及换行符（回车）前面的空白符，并把换行符转换为空格，一行中多个连续的空白符，会被合并成一个空格。[2] 所有空白符保持原样，不作任何处理。[3] 一行中多个连续的空白符，会被合并成一个空格。 white-space属性可以与 overflow 属性结合使用，来控制文本超出容器边界时的处理方式。在 overflow 属性为默认值的情况下，文本超出容器后，容器会出现滚动条。 可以把 white-space属性设置为 nowrap，把 overflow 属性设置为 hidden，让超出容器的文本自动隐藏。如：1234567div &#123; width: 200px; font-size: 14px; overflow: hidden; white-space: nowrap; border: 1px solid #ccc;&#125; 也可以把 white-space属性设置为 nowrap，把 overflow 属性设置为 ellipses，让超出容器的文本显示为省略号。 3.2.13 单词折行word-wrap属性用来设置是否允许长单词或 URL 地址在容器的边界处自动换行，取值为 normal | break-word，默认值为 normal。 normal 表示只允许在半角空格或连字符的地方换行，如果没有半角空格或连字符，则长单词或 URL 地址会撑大容器或溢出到容器的外面；break-word 则表示允许长单词或 URL 地址在容器边界处自动换行，显示到下一行。 为了演示不同取值的效果，就可以使用 word-wrap属性，定义两个不同的类。为了方便查看效果，为它们定义了固定宽度和边框。CSS代码如下：123456789101112.normal &#123; word-wrap: normal;&#125;.break-word &#123; word-wrap: break-word;&#125;.normal, .break-word &#123; width: 100px; height: 50px; border: 1px solid #444; display: inline-block;&#125; 把上述两个不同的类，应用到特定的段落，就可以看到长单词或 URL 地址在容器的边界处自动换行的不同效果。HTML代码如下：12&lt;p class=\"normal\"&gt;welcom to www.baidu.com&lt;/p&gt;&lt;p class=\"break-word\"&gt;welcom to www.baidu.com&lt;/p&gt; 左侧容器的 word-wrap属性取值为 normal，URL没有换行，而溢出到容器的外面。右侧容器 word-wrap属性取值为 break-word，在碰到容器边界处，URL会自动换行，但是，它并不是按单词换行，而是直接将URL截断换行，这显然会增加阅读的难度。 3.2.14 单词换行word-break属性用来规定自动换行的处理方式，它不仅可以让浏览器在半角空格或连字符的后面换行，也可以实现在任意位置换行，可选值有 normal | keep-all | break-all，默认值为 normal。 normal 表示根据语言自身的换行规则，确定换行方式，中文将容器边界处的汉字换到下一行，西方文字则将整个单词换到下一行；keep-all 表示不允许把单词截断，只能在半角空格或连字符处换行；break-all 允许把单词截断，在单词内换行。 为了演示不同取值的效果，就可以使用 word-wrap属性，定义两个不同的类。为了方便查看效果，为它们定义了固定宽度和边框。CSS代码如下：12345678910111213.keep-all &#123; word-break: keep-all;&#125;.break-all &#123; word-break: break-all;&#125;.keep-all, .break-all &#123; width: 180px; height: 50px; border: 1px solid #444; font-size: 16px; display: inline-block;&#125; 把上述两个不同的类，应用到特定的段落，就可以看到单词在容器的边界处自动换行的不同效果。HTML代码如下：12&lt;p class=\"keep-all\"&gt;welcom to www.waibo-wang&lt;/p&gt;&lt;p class=\"break-word\"&gt;welcom to www.waibo-wang&lt;/p&gt; 左侧容器的word-break属性取值为keep-all，其中的长单词waibo-wang在连字符处进行换行。右侧容器右侧容器的word-break属性取值为break-all，在长单词内部进行换行，单词被截断。 white-space、word-wrap、word-break的区别：white-space: nowrap让一段文本不换行，在一行内显示。word-wrap: normal 使一个单词或URL不折行，在一行内显示。word-wrap: break-word在容器边界自动换行，会把整个长单词看成一个整体放到下一行，而不会把单词截断。word-break: break-all在行末宽度不够显示整个单词时，会把单词截断。 3.2.15 文本溢出text-overflow属性用来设置容器内的文本溢出时，如何处理溢出的内容，取值为 clip | ellipsis，默认值为 clip。 clip 表示文本溢出时，简单的把溢出的部分裁剪掉；ellipsis 表示文本溢出时，在溢出的地方显示一个省略标记（…）。 在使用 text-overflow属性时，一定要给容器定义宽度，否则，文本只会撑开容器，而不会溢出。 事实上，text-overflow属性只能定义文本溢出时的效果，并不具备其它样式功能。所以，无论 text-overflow属性取值是 clip，还是 ellipsis，要让 text-overflow属性生效，必须强制文本在一行内显示（white-space: nowrap），同时隐藏溢出的内容（overflow: hidden）。 如果省略 overflow: hidden，文本会横向溢出容器的外面；如果省略 white-space: nowrap，文本在横向到达容器边界时，会自动换行，即便定义了容器的高度，也不会出现省略号，而是把多余的文本裁切掉；如果省略 text-overflow: ellipsis，多余的文本会被裁切掉，就相当于 text-overflow: clip。 下面给出未设置 text-overflow属性、text-overflow属性取值为 clip 和 ellipsis 时的效果对比。CSS代码如下：123456789101112131415161718p &#123; width: 304px; height: 18px; line-height: 14px; font-family: Arial; font-size: 14px; border:1px solid #444;&#125;.clip &#123; text-overflow: clip;&#125;.ellipsis &#123; text-overflow: ellipsis;&#125;.clip, .ellipsis &#123; overflow: hidden; white-space: nowrap;&#125; HTML代码如下：123&lt;p&gt;未设置 text-overflow属性时，文本完整显示，可能会溢出容器&lt;/p&gt;&lt;p class=\"clip\"&gt;text-overflow属性取值clip时，文本溢出时，只是简单的把溢出的部分裁剪掉&lt;/p&gt;&lt;p class=\"ellipsis\"&gt;text-overflow属性取值ellipsis时，文本溢出时，在溢出的地方显示一个省略号&lt;/p&gt; 上述代码定义了三个 p 容器，第一个未定义 text-overflow、overflow、white-space 属性，第二个定义 text-overflow属性取值为 clip，第二个定义 text-overflow属性取值为 ellipsis。为了方便看清楚容器的边界，为li定义了高度，同时添加了边框。第一个段落的内容完整显示但溢出到容器的外边，第二个段落只是简单的把溢出的部分裁剪掉，第三个段落在溢出的地方显示了一个省略号。 3.2.16 Tab宽度在程序中，制表符（即 tab 字符，在 C、Pyhthon 等语言中，用 \\t 表示）用来控制跳到下一个制表位，常用来控制文本的缩进。制表符的宽度，对于任何一款代码编辑器来说，都是很必须的功能。而在网页中，制表符的宽度也同样是必须的功能。 默认情况下，浏览器通常将HTML中制表符替换为8个空格来显示。8个空格明显太宽了，不能满足大多数人的要求，并且不够灵活。 因此，在CSS3中，新增了 tab-size属性，用来设置对象中的制表符的宽度，其值可以是一个整数或长度值。整数表示制表符的宽度为字符宽度的倍数，默认值是8，即表示制表符的宽度为8个字符的宽度；长度值表示制表符的宽度为指定的宽度值。 只有当一个元素的 white-space 属性的值为 pre 或 pre-wrap 或 pre-line 时，tab-size属性才会有效。而像 pre、textarea 这些元素，其 white-space 属性的默认值就是 pre，所以，可以直接使用 tab-size属性，而无需设置 white-space 属性。 盒模型盒模型是CSS中一个重要概念，用来控制元素在页面上如何显示，是网页设计中经常用到的一种思维模型。 在CSS1中，W3C初步制定了元素的基本外形特征，如宽度、高度、边框、内边距、外边距、浮动等属性。 到了CSS2，才提出了盒模型的概念，盒模型是从CSS角度，去看一个元素被渲染后的抽象形态，用来描述一个元素自身的构成部分。 在CSS3中，可以灵活控制盒子的解析模式、背景、外观等，为盒子添加圆角边框和图像边框，还能为元素添加盒阴影。 4.1 概述在盒模型中，把页面上的任何一个元素都看做一个盒子，每个盒子由内容（content）、内边距（padding）、边框（border）、外边距（margin）这 4 个区域组成。内边距、边框、外边距是可选的，并且，都被分解为上、右、下、左 4 个部分。 内容区域处于中央，围绕着内容区域的是内边距区域、边框区域和外边距区域，并把每个区域的边缘被称作边界。 一个元素共有 4 个区域，每个区域都各有上、右、下、左 4 条边界： 内容区域的外边缘称作内容边界（content edge）或内边界（inner edge）。把 4 条内容边界所形成的区域称作 content-box； 内边距区域的外边缘称作内边距边界（padding edge）。如果 padding 的宽度为 0，则内边距边界与内容边界相同。把 4 条内边距边界所形成的区域称作 padding-box； 边框区域的外边缘称作边框边界（border edge）。如果 border 的宽度为 0，则边框边界与内边距边界相同。把 4 条边框边界所形成的区域称作 border-box； 外边距区域的外边缘称作外边距边界（margin edge）或外边界（outer edge）。如果 margin 的宽度为 0，则外边距边界与边框边界相同。把 4 条外边距边界所形成的区域称作 margin-box。4.2 内边距内边距是元素的边框和内容之间的空白区域，用来控制元素边框和内容之间的距离。 设置内边距的最简单办法就是使用 padding属性，其值可以是百分比、长度值，默认值是 0，不允许负值。 内边距是可选的，默认值是 0。所以，如果没有显式声明 padding属性，元素就不会出现内边距。但是，浏览器却为许多元素提供了默认的样式，内边距也不例外。所以，为了在所有浏览器下表现一致，常常需要设计师将元素的 padding属性设置为 0，来覆盖浏览器的默认样式。该项工作可以针对具体元素进行，也可以使用通用选择器对所有元素进行设置：123* &#123; padding: 0;&#125; 不过，请记住，通用选择器不区分元素，因此对某些元素（如，select 控件中的 option）产生不利影响。并且，通用选择器会影响效率。所以，使用全局 reset 来显式地将内边距设置为 0 可能会更安全。如：123body, p, h1, h2, h3, ul, ol &#123; padding: 0;&#125; 使用长度值设置内边距时，可以接受任何长度值，包括绝对长度和相对长度。如，让所有 h1 元素的各边都有 10px 的内边距：123h1 &#123; padding: 10px;&#125; 有时候，可能希望一个元素各边上的内边距不同，这也很简单。如果希望 h1 元素的上内边距为10px、右内边距为20px、下内边距为30px、左内边距为40px，只需应用以下规则：123h1 &#123; padding: 10px 20px 30px 40px;&#125; 这些值的顺序很重要，必须遵循上、右、下、左的模式，即从上（top）开始，围着元素顺时针旋转。所以，如果要得到想要的效果，必须正确安排各个值的顺序。 不过，如果只增加内边距，要真正看到所设置的内边距可能有些困难。由于默认情况下，背景色会延伸到边框的外边界，因此可以为元素添加背景色，在内边距区域就能看到背景色，可以间接看到内边距：1234h1 &#123; background: #ccc; padding: 10px 20px 30px 40px;&#125; 使用百分比设置内边距时，元素的左右内边距和上下内边距，都是相对于父元素的 width 进行计算。假如在容器 div 中有一个 h1 标题：1&lt;h1&gt;带有内边距的 h1 标题&lt;/h1&gt; 现在，把容器的宽度设置为 400px，把 h1 标题的 padding属性的值设置为 5%，则得到内边距的值为 400px * 5% = 20px，为了便于观察，为 h1 标题增加了 1px 的虚线边框：1234567div &#123; width: 400px;&#125;h1 &#123; padding: 5%; border: 1px dashed #444;&#125; 当内边距设置为百分比时，如果父元素的 width 以某种方式发生改变，则内边距的值也会随之改变。如，在父元素的 width 的也设置为百分比时，改变浏览器窗口大小，h1 的内边距也会随之改变。 内边距的值也可以混合使用长度值和百分比，并且，可以使用各种类型的长度值，一个规则并不限制只能使用一种长度类型：123h1 &#123; padding: 10px 10% 2em 20mm;&#125; 有时候，为内边距输入的值可能会重复。为了方便，CSS允许为 padding属性提供 1~4 个值，让浏览器根据提供的参数值个数来决定作用对象。规则如下： 1）如果提供一个值，将用于全部的四4个方向。 2）如果提供两个值，第一个用于上、下，第二个用于左、右。 3）如果提供三个值，第一个用于上，第二个用于左、右，第三个用于下。 4）如果提供四个值，将按上、右、下、左的顺序作用于四边。 有时候，确实需要仅仅设置元素单边上的外边距。幸运的是，CSS提供了 padding-top属性、padding-right属性、padding-bottom属性、padding-left属性，这些属性专门用来设置元素的单边内边距。 这些属性的名字一目了然，使用其中任何一个属性，将只设置该边上的内边距，而不影响其他内边距。一个规则中可以使用多个单边属性。如，使用单边属性把 h1 元素的上内边距为10px、右内边距为20px、下内边距为30px、左内边距为40px：123456h1 &#123; padding-top: 10px; padding-right: 20px; padding-bottom: 30px; padding-left: 40px;&#125; 当然，对于这种情况，使用 padding属性可能更容易一些：123h1 &#123; padding: 10px 20px 30px 40px;&#125; 上述两种规则是等价的，无论使用哪种，得到的结果都一样。一般情况下，如果想为多个边设置内边距，使用 padding属性会更容易一些。不过，从显示结果的角度看，使用哪种方法都不重要，所以应该选择一种更容易的方法。 说明：当使用em 来定义元素的宽度、高度、内边距、外边距、边框宽度时，它的值是相对于元素自身的字体大小，而不是相对于父元素的字体大小。 4.3 外边距外边距会在元素外创建额外的空白区域，这个区域不能放置其他元素。因此，大多数情况下，普通流中都是通过外边距来控制元素之间的距离，使元素间出现间隔。 外边距默认是透明的，在这个区域中可以看到父元素的背景。也不能通过任何属性，来为外边距设置颜色，或让其不透明。但是，可以通过 margin属性来设置外边距的宽度，其值可以是百分比、长度值、或 auto。 由于外边距也是可选的，默认值是 0。所以，如果没有显式声明 margin属性，元素就不会出现外边距。同样，浏览器也为外边距提供了默认的样式，需要设计师进行重置。如：123body, p, h1, h2, h3, ul, ol &#123; margin: 0;&#125; 使用长度值设置外边距时，可以接受任何长度值，包括绝对长度和相对长度。如，在段落元素周围应用一个 10px 的空白区域：123p &#123; margin: 10px;&#125; 使用百分比设置外边距时，元素的左右外边距和上下外边距，都是相对于父元素的 width 进行计算。如果父元素的 width 以某种方式发生改变，外边距的值也会随之改变。 外边距的值也可以混合使用长度值和百分比，并且，可以使用各种类型的长度值。如果希望一个元素各边上的外边距不同，同样遵循上、右、下、左的模式，也允许提供 1~4 个值，作用规则与 padding 相同：123p &#123; margin: 10px 10% 2em 20mm;&#125; CSS也为外边距提供了单边的属性，使用其中任何一个属性，将只设置该边上的外边距，而不影响其他外边距：123456p &#123; margin-top: 10px; margin-right: 20px; margin-bottom: 30px; margin-left: 40px;&#125; 一个元素的外边距可以是正值，也可以是负值。当元素之间是父子关系时，通过设置子元素的外边距为负值，可以将子元素从父元素中分离出来，或者与其他元素重叠。如，在一个容器 div 中，有两个段落：1234&lt;div&gt; &lt;p&gt;这个段落的外边距为正值&lt;/p&gt; &lt;p&gt;这个段落的外边距为负值&lt;/p&gt;&lt;/div&gt; 现在，把第一个段落的外边距设置为正值，第二个段落的外边距设置为负值。为了方便查看，为容器和段落都设置了虚线边框：12345678910111213div &#123; width: 300px; border: 1px dashed #ccc;&#125;div p &#123; border: 1px dashed #ccc;&#125;div p:nth-child(1) &#123; margin: 10px;&#125;div p:nth-child(2) &#123; margin: 10px -30px;&#125; 负外边距导致第二个段落超出了容器，跑动了容器的外面，似乎它的尺寸比容器宽了 60px。然而，根据数学计算，这个段落的 width 计算值加上其左右外边距，刚好等于容器 div 的 width，它并没有比容器更宽。 在把一个元素的 margin属性设置为负数时，一定要倍加小心，因为元素可能部分或完全脱离页面，或覆盖页面上的其他内容。 当然，有时候可以利用这个特性，把一个元素的 margin属性设置为一个很大的负数，使它移动到屏幕之外，来隐藏这个元素。然后，在需要的时候，恢复其 margin属性，让它正常显示出来。 4.4 边框在CSS1中，就支持为元素添加边框，并可以设置边框的样式、颜色、及粗细。不过，当时的边框太过单一，只支持简单的线条边框。 在CSS3中，为了实现丰富的边框效果，对边框属性进行了扩展，除了线条边框外，也可以把图像作为边框，同时还可以创建圆角边框，也可以使用盒阴影来为元素添加一个或多个边框阴影。 线条边框使用 border属性定义，图像边框使用 border-image 属性来定义，圆角边框使用 border-radius 属性定义，盒阴影使用 box-shadow 属性定义。 4.4.1 线条边框为元素定义线条边框，最简单的办法就是使用 border属性。border为复合属性，语法格式为：1border: &lt;border-style&gt; || &lt;border-width&gt; || &lt; border-color&gt; 也就是说，border属性可以分解为边框样式（border-style）、边框宽度（border-width）、边框颜色（border-color）这 3 个属性，接下来分别进行介绍。 border-styleborder-style属性是一个非常重要的边框属性，如果没有显式定义 border-style属性，或把 border-style属性设置为 none，元素将没有边框，并忽略 border-color属性 和 border-width属性。 border-style属性的取值为预定义关键字，CSS内置了 10 种不同的边框样式，每个样式都由一个预定义关键字来定义。 属性值 样式说明 none 无边框，不占据页面空间，同时忽略 border-color属性和 border-width属性 hidden 隐藏边框，它有边框，只是不可见 dotted 点状线 dashed 虚线 solid 实线 double 双线，两条单线与其间隔的和等于指定的 border-width属性的值 groove 3D凹槽 ridge 3D凸槽 inset 3D凹边 outset 3D凸边 如果一个元素的边框、背景、内容发生重叠，则边框绘制在元素的背景之上，内容之下。 如果border-width属性设置为0，则忽略border-style属性。可以为给定的边框定义多个样式。如，以下规则定义的上边框为点状线、右边框为单实线、下边框为双实线、左边框为虚线：1border-style: dotted solid double dashed; 可以看出，border-style属性的 4个参数值也采用 top-right-bottom-left 的顺序，其作用规则与 padding 相同。 有时候，你可能只想为元素的一边设置边框样式，而不是同时设置所有的 4 个边。这就要用到单边边框的样式属性，按上、右、下、左的顺序，对应的属性依次为border-top-style、border-right-style、border-bottom-style、border-left-style。 border-widthborder-width属性用来设置边框的粗细程度，可以使用长度值或预定义关键字 thin | medium | thick，默认值为 medium。长度值表示具体的数值，如2px 或 0.5em，不允许负值。 如果未显式声明 border-width属性，则边框的宽度或者为零（使用reset css时），或者为浏览器的默认值（很可能不是零，尤其是那些通常没有重置的表单元素）。 如果 border-style属性的值为 none，则无论是否显式定义边框的宽度，其宽度都会被自动设置为 0。由于 border-style属性的默认值是 none，因此，如果希望边框出现，就必须显式声明一个边框样式。 border-width属性需要 4 个参数值，也采用 top-right-bottom-left 的顺序。如：1border-width: 1px 2px 3px 4px; 上述规则就表示上边框的宽度为 1px、右边框的宽度为 2px、下边框的宽度为 3px、左边框的宽度为 4px。 也可以使用单边属性，按上、右、下、左的顺序，border-width对应的属性依次为border- top-width、border- right-width、border-bottom-width、border-left-width。 border-colorborder-color属性用来设置边框的颜色，其值可以是任意合法CSS的颜色，如预定义的颜色名、十六进制数值、RGB、RGBA、HSL、HSLA。在CSS2中， 还引入了边框颜色值 transparent，这个值使边框透明，用于创建有宽度但不可见的边框。 如果 border-width属性的值等于 0 或 border-style属性的值为 none，则忽略该属性。border-color属性需要 4 个参数值，也采用 top-right-bottom-left 的顺序。如：1border-color: red black green blue; 上述规则就表示上边框的颜色为红色、右边框的样式为黑色、下边框的样式为绿色、左边框的样式为蓝色。 边框颜色按上、右、下、左的顺序，border-color属性对应的独立属性依次为 border-top-color、border-right-color、border-bottom-color、border-left-color。 默认情况下，一个元素的边框颜色为元素内容的前景色。因此，如果没有显式声明边框颜色，边框的颜色将与元素的文本颜色相同。如果该元素不包含任何文本，如只包含图像，那么它的边框颜色，就是其父元素的文本颜色（因为 color 属性具有继承性）。 单边复合属性在定义单边属性时，如果每次都要使用诸如 border-top-width、border-top-color 这样的属性，就会带来诸多不便。于是，CSS也专门为单边定义了复合属性，按上、右、下、左的顺序，对应的单边属性依次为 border-top、border- right、border-bottom、border-left，它们的语法相同，格式如下：1border-top: &lt;border-style&gt; || &lt;border-width&gt; || &lt; border-color&gt; 有了这些属性，就可以创建出一些复杂的边框。如，以下规则为容器的 4 个边创建了 4 种不同的边框：12345678div &#123; width: 200px; height: 60px; border-top: 10px dotted #006dcc; border-right: 10px solid #da4f49; border-bottom: 10px dashed #5bb75b; border-left: 10px double #faa732;&#125; 实际上，在声明单边属性时，具体值的顺序并不重要，浏览器可以根据值的类型自动识别，并应用到相应的属性。所以，以下三个规则会得到相同的边框效果：123div &#123; border-top: 10px dotted #006dcc; &#125;div &#123; border-top: dotted 10px #006dcc; &#125;div &#123; border-top: #006dcc dotted 10px; &#125; 并且，如果希望某个值使用默认值，也可以省略其值。如，以下规则就表示希望边框使用与容器中的文本相同的颜色：1div &#123; border-top: 10px dotted; &#125; 需要注意的是，这些单边属性只能应用到一个特定的边，因此，只需声明一个宽度值、一个颜色值和一个边框样式值。否则，将导致整个声明无效。 4.4.2 图像边框为了实现丰富多彩的边框效果，在CSS3中，新增了 border-image属性，这个新属性允许指定一幅图像作为元素的边框。该属性的优点是，可以根据一些简单的规则，把一幅图像划分为 9 个单独的部分，浏览器会自动使用合适的部分作为边框的对应部分。 需要注意的是，只有当 border-style属性取值为 none 时，border-image属性才会有效。所以，如果定义的边框图像显示不出来，首先需要检查border-style属性的值是否为 none。 border-image是复合属性，其语法格式为：123border-image: &lt;‘border-image-source’&gt; || &lt;‘border-image-slice’&gt; [/&lt;‘border-image-width’&gt;|/&lt;‘border-image-width’&gt;? /&lt;‘border-image-outset’&gt;]? || &lt;‘border-image-repeat’&gt; 也就是说，border-image属性可以分解为 border-image-source、border-image-slice、border-image-width、border-image-outset、border-image-repeat 这 5 个属性，下面分别进行介绍。 border-image-sourceborder-image-source属性用于指定边框图像的URL地址，取值为 none | url，默认值为 none。url 可以是相对路径，也可以是绝对路径，跟CSS1中 background-image属性相似。当该属性的取值为 none，或 url 无效时，边框将使用 border-style 属性的值。 border-image-sliceborder-image-slice属性的作用是按照指定宽度，对边框图像进行切片。其语法格式为：1border-image-slice : [&lt;number&gt; | &lt;percentage&gt;]&#123;1,4&#125; &amp;&amp; fill? 该属性需要 4 个参数值，依次指定 top、right、bottom、left 这 4 个方向上的切割宽度。其值可以长度，也可以是百分比。长度为纯数字，无需指定单位，默认使用 px 为单位；百分比，top、bottom 相对于边框图像的高度，right、left 相对于边框图像的宽度。4个参数值可以使用简写方式，规则与 border-width 相同。fill 为可选值，用来设置中间的第九块是否为非透明块，默认为透明块。 假设有一个 81px 的正方形图像，包含 9 个菱形图案，每个菱形图案的尺寸为27px * 27px。 在 border-image-slice: 27 的情况下，4 个方向上的切割宽度均为 27px， 经过 4 次切割后，边框图像被切成 9 个切片，即左上角（top-left）、右上角（top-right）、右下角（bottom-right）、左下角（bottom-left）4 个橙红色菱形，上（top）、右（right）、下（bottom）、左（left）为 4 个橙黄色菱形，加中间的透明区域。 之所以要切成 9 片，是因为盒模型中，一个盒子有内容区域、加上边框的4个角和4条边，正好 9 个区域。 这 9 个切片中，4 个角上的每个切片，将分别用作元素边框的 4 个角、4 条边上的每个切片，将分别用作元素边框的 4 条边、中间的切片用作元素内容区域的背景（如果设置 fill）。 border-image-widthborder-image-width属性用来定义边框图像的显示区域，即切片的最大显示宽度。 如果该属性定义的值大于 border-image-slice属性的值，则 4 个角和 4 个边的切片，在水平和垂直方向都会被拉伸到该属性指定的值；如果该属性定义的值小于 border-image-slice属性的值，则使用该属性的值。 如， border-image-slice属性的值为 27，而 border-image-width属性的值为 54px。由于边框宽度大于 border-image-slice属性的值，切片会被拉伸。代码如下：1234567div &#123; width: 300px; height: 120px; border-image-slice: 27; border-image-width: 54px; border-image-source: url(img/border.png);&#125; 说明：border-image-width属性定义的是边框图像的显示区域，即切片的最大显示宽度，跟元素的边框宽度没有关系，元素边框的宽度由 border-width属性定义。所以，当设置的 border-image-width大于边框宽度时，边框图像会对元素自身和周围的元素产生影响。 border-image-outsetborder-image-outset属性的作用是让边框图像外凸，延伸到盒子外面。其语法格式为：1border-image-outset : [ &lt;length&gt; | &lt;number&gt; ]&#123;1,4&#125; 该属性需要 4 个参数值，依次指定 top、right、bottom、left 这 4 个方向上向外延伸的量，默认值为 0。值可以长度，也可以是数字。长度表示延伸的宽度，数字表示延伸相应边框的 border-width计算值的倍数。4个参数值可以使用简写方式，规则与margin相同。 假设页面上有两个盒子，左边的盒子未指定边框图像外凸，右边的盒子指定边框图像外凸 27px（即一个切片的宽度）：1234567891011div &#123; width: 128px; height: 128px; border-image-source: url(images/border.png); border-image-slice: 27; border-image-width: 27px; border-image-repeat: repeat;&#125;.outset &#123; border-image-outset: 27px;&#125; 1&lt;div&gt;&lt;/div&gt;&lt;div class=\"outset\"&gt;&lt;/div&gt; 需要注意的是，边框图像外凸后，就会延伸到盒子的外面。如果外凸的宽度过宽，边框图像可能会覆盖周围的元素。 但是，由于边框图像并不是元素盒模型中的内容，因此，即便边框图像延伸到元素的边界之外，甚至覆盖其它元素，也不会对页面布局产生任何影响。 border-image-repeatborder-image-repeat属性用来定义边框图像的 9 个切片中，top、right、bottom、left对应的 4 个切片是以拉伸方式显示，还是以平铺方式显示。 由于每条边只使用一个切片，所以，当边框的长度大于单个切片的长度时，单个切片就不能填满边框，就需要拉伸或平铺。不同取值的含义见表 属性值 含义 stretch 默认值，切片拉伸以填满整个边框区域 repeat 切片重复以填满整个边框区域 round 切片重复以填满整个边框区域。当不能用整数个切片填满整个边框区域时，对每个切片进行缩放，以保证每个切片完整 space 切片重复以填满整个边框区域，当边框区域的尺寸不是切片尺寸的整数倍时，多余的空间由每个切片均分 该属性需要 2 个参数。如果提供 2 个参数，第一个用于 top 和 bottom，第二个用于 left 和 right；如果只提供 1 个参数，则同时用于 top、right、bottom、left。 假设页面上有四个盒子，盒子的宽度和高度分别为 380px 和 118px，即 n 个切片尺寸 + 10px，每个盒子的 border-image-repeat 属性分别取值 stretch、repeat、round、space：12345678910111213141516171819div &#123; width: 380px; /* 10个切片的宽度 + 10px */ height: 118px; /* 4个切片的高度 + 10px */ border-image-slice: 27; border-image-width: 27px; border-image-source: url(img/border.png);&#125;.stretch&#123; border-image-repeat: stretch;&#125;.repeat&#123; border-image-repeat: repeat;&#125;.round&#123; border-image-repeat: round;&#125;.space&#123; border-image-repeat: space;&#125; 1234&lt;div class=\"stretch\"&gt;border-image-repeat: stretch&lt;/div&gt;&lt;div class=\"repeat\"&gt;border-image-repeat: repeat&lt;/div&gt;&lt;div class=\"round\"&gt;border-image-repeat: round&lt;/div&gt;&lt;div class=\"space\"&gt;border-image-repeat: space&lt;/div&gt; 当 border-image-repeat属性取值 stretch 时，由于切片不重复，会将单个切片进行拉伸到整个边框的尺寸；当取值 round 时，每个切片保持完整；取其它值时，切片就会进行重复，以填满边框区域。 4.4.3 圆角边框在Web页面上，圆角效果是美化页面的常用手法之一，圆角给页面添加曲线之美，让页面不那么生硬。但是，为了设计圆角，设计师常常需要花费很多的时间和精力。 在CSS3中，专门针对圆角效果增加了一个 border-radius属性，通过该属性，便可以轻松实现圆角效果，设计师不必再为圆角而伤透脑筋。 border-radius属性的值为边框的圆角半径，可以使用任意合法的CSS长度值，如em、pt、px、百分比等。 定义 border-radius 后，浏览器将用 1/4 椭圆来绘制元素相应的角，4 个角上对应的圆角属性分别是 border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius，其语法格式为：1border-*-radius : [ &lt;length&gt; | &lt;percentage&gt; ]&#123;1,2&#125; 也就是说，定义border-*-radius属性时，需要提供两个参数值，第一个参数用于椭圆的横轴半径，第二个参数用于椭圆的纵轴半径。 如果只提供1个值，表示横轴半径与纵轴半径相等。如果某个值为0，则使用方角，不使用圆角。使用百分比时，横轴半径根据元素的 width 计算得到，纵轴半径根据元素的 height 计算得到。 如，把一个元素的横轴半径设置为55pt，纵轴半径为25pt，对应的CSS代码为：1border-top-left-radius: 55pt 25pt; 这样给元素设置单个圆角效果，费时费力，而且难以维护，也容易出错。其实，完全可以借助复合属性 border-radius，来实现 4 个属性相同的效果。语法格式为：1border-radius : &lt;length&gt;&#123;1,4&#125; [/ &lt;length&gt;&#123;1,4&#125; ]? 也就是说，border-radius属性需要 2 组参数，并以 / 分隔。第1组参数用于椭圆的横轴半径，第2组参数用于椭圆的纵轴半径。如果省略第2组参数，则使用第1组参数的拷贝。每组参数中，允许设置1~4个值，分别根据所提供值的个数来决定作用对象，遵循以下规则： 1）如果提供一个，将用于全部的四个角。 2）如果提供两个，第一个用于左上、右下，第二个用于右上、左下。 3）如果提供三个，第一个用于左上，第二个用于右上、左下，第三个用于右下。 4）如果提供四个，将按左上、右上、右下、左下的顺序作用于四个角（顺时针顺序）。 如，border-radius: 2em 1em 4em / 0.5em 3em，提供了2组参数，第1组参数提供3个值，第2组参数提供2个值。其作用就相当于：1234border-top-left-radius: 2em 0.5em;border-top-right-radius: 1em 3em;border-bottom-right-radius: 4em 0.5em;border-bottom-left-radius: 1em 3em; 事实上，只要一个元素通过border-radius属性定义了圆角，而无论它是否定义边框，浏览器都会按圆角进行渲染。对于图像、或具有背景的元素，很容易看到这个效果。 利用这个特点和图形几何特性，可以很轻松实现许多有趣的效果，如圆形、半圆形、扇形、椭圆形等。 1）圆形 如果椭圆的横向半径和纵向半径相等，椭圆就会变成圆。如果一个元素为正方形，就利用这个特性，把圆角的半径设置为宽度或高度一半，即可把正方形按圆形显示。当然，如果把圆角的半径设置为 50% 会更方便，因为半径会随元素的尺寸自动调整。如：12345img &#123; width: 100px; height: 100px; border-radius: 50%;&#125; 1&lt;img src=\"img.jpg\"&gt; 2）半圆形 制作半圆形跟制作圆形的方法相同，只是需要元素的宽度和高度，与不同方位的圆角半径进行适当配合。 如果元素的宽度是高度的 2 倍，且圆角半径等于元素的高度值，就可以得到上半圆或下半圆；如果元素的高度是宽度的 2 倍，且圆角半径等于元素的宽度值，就可以左半圆或右半圆。如：12345img &#123; width: 140px; height: 70px; border-radius: 70px 70px 0 0;&#125; 3）扇形 通过border-radius 制作的扇形，实际上就是制作四分之一圆形。如果把圆形的 3 个半径设置为 0，让圆形只剩下四分之一，就会得到扇形。通过改变圆角的位置，就可以制作出左上、右上、右下、左下四种扇形的效果。如：12345img &#123; width: 100px; height: 100px; border-radius: 100% 0 0 0;&#125; 4）椭圆形 根据几何特性，椭圆实际上就是圆形受到挤压后得到的形状。椭圆有两种，一种是水平椭圆（长轴在横轴方向），一种是垂直椭圆（长轴在纵轴方向）。因此，椭圆的横轴半径始终等于元素的宽度，纵轴半径始终等于元素的高度。如：12345img &#123; width: 200px; height: 100px; border-radius: 200px / 100px;&#125; 4.4.4 盒阴影默认情况下，一个盒子是没有阴影的，可以使用 box-shadow属性为盒子添加一个或多个阴影。语法格式为：1box-shadow: [inset] x-offset y-offset blur-radius spread-distance color 每个阴影由可选的 inset 关键字、2-4 个长度值、可选的颜色值来规定。如果省略可选的长度值，则使用默认值 0。各参数的含义见表 参数 含义 inset 可选值，表示阴影的投影方式。如果不设置，则默认投影方式是外阴影；如果设置为其唯一值inset，其投影方式是内阴影 x-offset 必选参数，表示阴影的水平偏移量。可以是正值，也可以是负值。取正值时，阴影向元素的右侧偏移，阴影在元素的右边；取负值时，阴影向元素的左侧偏移，阴影在元素的左边 y-offset 必选参数，表示阴影的垂直偏移量。可以是正值，也可以是负值。取正值时，阴影向元素的底部偏移，阴影在元素的底部；取负值时，阴影向元素的顶部偏移，阴影在元素的顶部 blur-radius 可选参数，表示阴影的模糊半径，默认值为0，不允许负值。如果取值为0，则阴影的边缘是清晰的。否则，值越大，阴影的边缘越模糊 spread-distance 可选参数，表示阴影的扩张距离。正值使外阴影向外扩大，内阴影向内缩小；负值使使外阴影向内缩小，内阴影向外扩大 color 可选参数，表示阴影的颜色。如果不指定，则使用浏览器的默认颜色，但各浏览器的默认颜色不尽相同 这些参数中，通过关键字 inset 来控制阴影的类型，并通过调整其它 5 个参数，来得到不同的阴影效果。假设页面上有两个 span 元素：1&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt; 接下来以这两个元素为例，对 box-shadow属性的这些参数进行说明。并且，始终让这两个 span 元素并排显示，第一个元素使用外阴影，第一个元素使用内阴影。为了方便对比效果，为这两个元素设置边框和背景颜色：12345678span &#123; width: 120px; height: 60px; margin: 20px; display: inline-block; border: 10px solid blue; background-color: orange;&#125; 参数 x-offset 和 y-offset 用来控制阴影的偏移量，通过取正值或负值，来控制阴影的偏移方向。如：123456span:nth-child(1) &#123; box-shadow: 10px 10px 0 0 rgba(0,0,0,0.4);&#125;span:nth-child(2) &#123; box-shadow: inset 10px 10px 0 0 rgba(0,0,0,0.4);&#125; 如果偏移量为 0，则阴影与元素本身重合，就看不到阴影。于是，就可以让 x-offset 和 y-offset中的任一个值为 0，再把另一个的偏移设置为正值或负值，来实现某个方向上的单侧阴影效果。如，y-offset为 0，x-offset为正值，就得到右侧阴影效果：123456span:nth-child(1) &#123; box-shadow: 10px 0 0 0 rgba(0,0,0,0.4);&#125;span:nth-child(2) &#123; box-shadow: inset 10px 0 0 0 rgba(0,0,0,0.4);&#125; 参数 blur-radius 用来控制阴影的模糊半径，即阴影从开始变淡到完全消失的距离。如果取值为0，则阴影不具有模糊效果，阴影的边缘是清晰的。否则，阴影会慢慢变虚，值越大，阴影的边缘越模糊。一个阴影在四个方向上的模糊效果完全相同，不能设置单侧的模糊效果。如：123456span:nth-child(1) &#123; box-shadow: 0 0 20px 0 red;&#125;span:nth-child(2) &#123; box-shadow: inset 0 0 20px 0 red;&#125; 参数spread-distance 用来控制阴影的扩张距离，即阴影的宽度。一个阴影在四个方向上的扩张效果完全相同，不能设置单侧的扩张效果。如：123456span:nth-child(1) &#123; box-shadow: 0 0 0 10px rgba(0,0,0,0.4);&#125;span:nth-child(2) &#123; box-shadow: inset 0 0 0 10px rgba(0,0,0,0.4);&#125; 如果同时设置了模糊半径和扩展半径，则会产生具有光晕效果的阴影。如：123456span:nth-child(1) &#123; box-shadow: 0 0 20px 10px red;&#125;span:nth-child(2) &#123; box-shadow: inset 0 0 20px 10px red;&#125; 除了单阴影外，还可以使用逗号分隔的阴影列表，为元素添加多重阴影。多重阴影将按照声明的先后顺序，最先声明的阴影显示在最顶层，后声明的阴影依次显示在底层。并且，上层阴影会遮盖下层的阴影。如：12345678910div &#123; width: 200px; height: 60px; border-radius: 10px; border: 1px solid #ccc; box-shadow: 0 0 0 5px red, 0 0 0 10px yellow, 0 0 0 15px blue, 0 0 0 20px green;&#125; 似乎很难直接看出阴影的层次关系，但只要分析不同颜色阴影的宽度，层次关系便一目了然。先看看最后声明的绿色阴影，它声明的宽度是 20px，而可见宽度只有 5px。这是因为黄色阴影在绿色阴影的上一层，将绿色阴影遮掉了 15px。因此，绿色阴影就只剩下 5px 了。其他阴影，以此类推。 事实上，不仅可以为一个元素声明多重阴影，而且，在多重阴影中，还可以同时存在外阴影和内阴影。看看W3C提供的实例：123456789101112div &#123; width: 100px; height: 100px; margin: 10px; padding: 50px; border: 12px solid blue; background-color: orange; border-top-left-radius: 60px 90px; border-bottom-right-radius: 60px 90px; box-shadow: 64px 64px 12px 40px rgba(0,0,0,0.4), 12px 12px 0px 8px rgba(0,0,0,0.4) inset;&#125; 外阴影绘制在元素边框的外面，内阴影绘制在元素内边距的里面。并且，外阴影绘制在元素的背景之下，内阴影绘制在元素的边框之下、背景之上。由于元素的背景图像在背景颜色之上。因此，按从上到下的顺序，一个元素的整体层次关系依次为：边框、内阴影、背景图片、背景颜色、外阴影。 元素的 border-radius 会影响阴影的外形，并且阴影和元素具有相同的圆角半径，而 border-image 不会影响阴影的外形。 外阴影把元素的 border-box 看作一个非透明盒进行投影。如果扩张距离为0，则阴影的形状和尺寸，跟元素的 border-box完全相同。阴影可以看作是元素的 border-box，在自身边框外的一个拷贝。 内阴影把元素内边距边界以外的任何东西，都看作一个非透明盒进行投影。如果扩张距离为0，则阴影的形状和尺寸，跟元素的 padding-box 完全相同。阴影可以看作是元素的padding-box，在自身内边距内的一个拷贝。 由此可知，box-shadow属性只会为盒子添加阴影，而不会影响盒子的尺寸。因此，无论是偏移、模糊、还是扩张，都不会改变元素本身的尺寸。于是，让一个外阴影发生偏移、模糊、扩张后，阴影可能延伸到元素的边界之外，也可能覆盖其它元素，但不会对页面布局产生任何影响。 4.5 背景背景是创建更有趣味的网页的常用一种手法，无论是直接使用背景颜色，还是使用背景图像，都能给网页带来丰富的视觉效果。 在CSS1中，就提供了对背景的控制，并提供了 5 个background相关的属性，用来设置背景颜色、背景图像、背景图像的平铺方式、背景附着。 在CSS3中，提供了更丰富的背景效果，支持纯色背景、图像背景、渐变背景等，并对背景提供了更精细的控制，可以控制背景的尺寸、起始位置、显示范围等，同时还支持多重背景和渐变。 定义背景时，可以使用复合属性 background，也可以使用独立属性。复合属性的语法格式为：1background: &lt;color&gt; || &lt;position&gt; [/&lt;size&gt;]? || &lt;repeat&gt; || &lt;attachment&gt; || &lt;origin&gt; || &lt;clip&gt; 也就是说，background属性可以分解为color、position、size、repeat、attachment、origin、clip 这 7 个属性，这些属性的功能及所对应的CSS版本见表 属性 功能描述 background-color 设置背景的颜色 1 background-image 设置背景图像 1 background-repeat 设置背景图像的平铺方式 1 background-position 设置背景图像的位置 1 background-attachment 设置背景图像是随对象内容滚动，还是固定不动 1 background-size 设置背景图像的尺寸 3 background-origin 设置背景图像的起点位置 3 background-clip 设置背景的显示范围 3 4.5.1 背景颜色背景颜色是背景应用中最基础的属性，使用 background-color属性，几乎可以为任何元素定义背景颜色，该属性不能被继承，其默认值是 transparent，即透明背景。也就是说，如果一个元素没有显式定义背景颜色，那么其背景是透明的，就可以透过该元素看到其祖先元素的背景。 background-color属性接受任意合法的CSS颜色值，如预定义的颜色名、十六进制数值、RGB值、RGB百分比、RGBA值、HSL值、HSLA值。如：1234h1 &#123; background-color: gray; &#125; /* 灰色背景 */h2 &#123; background-color: #ccc; &#125; /* 灰色背景 */p &#123; background-color: rgba(0,152,50,0.7); &#125; /* 70%不透明度的背景 */div &#123; background-color: transparent; &#125; /* 完全透明背景 */ 默认情况下，元素的背景颜色会延伸边框的外边界。因此，对于间断的边框，如虚线或点线，元素的背景会出现在边框的可见部分。如：123456div &#123; width: 200px; height: 60px; border: 10px dashed #444; background-color: rgba(0,152,50,0.7);&#125; 元素的背景颜色延伸到了边框的下面，透过虚线边框的间隙，可以看到背景颜色。 不过，在CSS2中规定，背景颜色只延伸到内边距，而不是边框。在CSS2.1中，对此作了更正，并明确指出元素的背景是内容、内边距和边框区域的背景。所以，一些较老的浏览器可能会有不同的表现。 另外，考虑到浏览器的兼容性，如果使用RGBA、HSL和HSLA来定义背景颜色，一般会先定义一个十六进制颜色的背景作为对老浏览器的备用颜色，然后再定义RGBA、HSL和HSLA颜色的背景。 4.5.2 背景图像除了背景颜色，也可以使用背景图像来实现各种复杂、有趣的背景效果。CSS中，使用 background-image属性来定义背景图像的路径，取值为 none | url，默认值为 none。 url 可以是相对路径，也可以是绝对路径。使用相对路径时，url 是相对于 css 所在的文件，而不是要设置样式的HTML文件。如，下面代码表示，使用 css 文件所在目录下的 img 文件夹下的图像 bg.gif 作为背景图像：12345div &#123; width: 200px; height: 200px; background-image: url(img/bg.gif);&#125; 默认情况下，背景图像会在水平方向和垂直方向重复，以填满整个容器。假如有一幅图案 bg.gif，其尺寸为 100px * 100px。 由于容器 div的尺寸为 200px * 200px，如果把图案 bg.gif 作为容器 div 的背景，则背景会在水平方向和垂直方向各重复两次。 4.5.3 背景重复默认情况下，如果一幅背景图像不足以占满整个容器时，就会在水平方向和垂直方向重复，以填满整个容器。然而，有时候却希望背景图像只出现一次，或只在某个方向上重复。 这时，就可以通过 background-repeat属性来定义背景图像如何重复，即背景图像的平铺方式，可选值有 repeat | repeat-x | repeat-y | space | round | no-repeat，默认值为 repeat。不同取值的含义见表 属性值 含义 repeat 默认值，图像在水平方向和垂直方向都重复以填满容器 repeat-x 图像只在水平方向重复以填满容器 repeat-y 图像只在垂直方向重复以填满容器 space 图像向两端对齐重复以填满容器，多余空间用空白代替 round 图像向两端对齐重复以填满容器，多余空间通过图像拉伸来填充 no-repeat 不重复，图像只显示一次 默认情况下，背景图像的填充区域为元素的 padding-box 区域，而背景图像平铺之后，其填充区域将是元素的 border-box 区域。 background-repeat属性需要 2 个参数，如果提供 2 个参数，第一个用于水平方向，第二个用于垂直方向。如果只提供 1 个参数，则同时用于水平方向和垂直方向。特殊值 repeat-x 和 repeat-y除外，因为 repeat-x 相当于 repeat no-repeat，repeat-y 相当于 no-repeat repeat，即 repeat-x 和 repeat-y 就等价于提供了 2 个参数值。 为了清楚了解 background-repeat属性在不同取值下的表现，这里针对每个取值定义了一个类，然后把它们分别应用到一个容器。 HTML代码如下：123456&lt;div class=\"no-repeat\"&gt;&lt;/div&gt;&lt;div class=\"repeat-x\"&gt;&lt;/div&gt;&lt;div class=\"repeat-y\"&gt;&lt;/div&gt;&lt;div class=\"repeat\"&gt;&lt;/div&gt;&lt;div class=\"space\"&gt;&lt;/div&gt;&lt;div class=\"round\"&gt;&lt;/div&gt; CSS代码如下：123456789101112131415161718192021222324div &#123; width: 100px; height: 120px; border: 1px dashed #888; background-image: url(bg.png);&#125;.repeat-x &#123; background-repeat: repeat-x;&#125;.repeat-y &#123; background-repeat: repeat-y;&#125;.repeat &#123; background-repeat: repeat;&#125;.space &#123; background-repeat: space;&#125;.round &#123; background-repeat: round;&#125;.no-repeat &#123; background-repeat: no-repeat;&#125; 上述代码中，容器的宽度为 100px、高度为 120px，背景图像的宽度和高度都是 40px。为了能够清楚可见背景图像的范围，这里给容器增加了 1px 的虚线框，给背景图像增加了 1px 的黑色边框。 图像都是按原始尺寸进行重复，来填满容器。在水平方向上，当容器的宽度不是背景图像宽度的整数倍时：如果取值为 space，多余空间用空白填充；如果取值为 round，背景图像会被缩放；如果为其他值，最后一幅图像可能不完整。垂直方向同理。 4.5.4 背景位置除了背景背景平铺外，CSS还提供了另一个强大的功能，即背景定位技术，能够精确控制背景在对象中的位置。 默认情况下，背景图像都是从元素 padding 区域的左上角开始出现的，但设计师往往希望背景能够出现在任何位置。通过 background-position属性，可以很轻松的控制背景图像在对象的背景区域中的起始显示位置。其语法格式为：1background-position: xpos ypos | x% y% | x y CSS1中，background-position属性需要 2 个参数值，第一个值用于横坐标，第二个值用于纵坐标，默认值为 0% 0%，即背景图像的左上角与对象背景区域的左上角对齐。如果只提供一个值，则用于 x 轴方向，y 轴方向使用默认值 center，即垂直居中。 上述语法格式表明，背景图像有 3 种定位方式： 1）xpos ypos：表示使用预定义关键字定位，水平方向可选关键字有 left | center | right，垂直方向可选关键字有 top | center | bottom。 关键字定位，应用的是对齐规则，而不是坐标规则。xpos 为 left 表示图像的左边与对象的左边对齐，为 right 表示图像的右边和对象的右边对齐；ypos 为 top 表示图像的顶部和对象的顶部对齐，为 bottom 表示图像的底部和对象的底部对齐；xpos、ypos等于 center表示图像在水平和垂直方向的中心，和对象在水平和垂直方向的中心对齐，即。 依然使用前面的背景图案 bg.gif，其尺寸为 100px 100px，对象的尺寸为 200px 200px，背景图像的位置使用预定义关键字定位。如：12345678div &#123; width: 200px; height: 200px; border: 1px dashed #ccc; background-repeat: no-repeat; background-position: center center; background-image: url(img/bg.gif);&#125; 上述定位，就表示背景图像的中心，与背景区域的中心对齐，即背景图像位于对象的中央位置。 2）x% y%：表示使用百分比定位，是将图像本身（x%, y%）的那个点，与背景区域的（x%, y%）的那个点重合。最终得到背景图像起始位置坐标的计算公式为： x = (对象的宽度 - 图像的宽度) * x%; y = (对象的高度 - 图像的高度) * y%; 还是上面的例子，改为百分比定位，要使背景图像居中，只需把背景图像的位置设置为50% 50% 即可。使用上面的公式，得到背景图像起始位置的坐标为： x：(200px - 100px) 50% = 100px 50% = 50px y：(200px - 100px) 50% = 100px 50% = 50px 得到的结果与上例相同，限于篇幅，就不再截图了。当然，百分比的值也可以是负值，计算公式依然不变。还是上面的例子，把百分比改为 -50% -50%。此时，得到背景图像起始位置的坐标为： x：(200px - 100px) (-50%) = 100px (-50%) = -50px y：(200px - 100px) (-50%) = 100px (-50%) = -50px 此时的背景图像只显示了原本图像的 1/4，这是因为背景图像的起始位置向左、向上移动后，只有1/4 的图案落到了背景区域。由于背景被设置为不重复，所以，就只显示了原本图像的 1/4。 3）x y：表示使用长度值定位，是将背景图像的左上角，放置在对象的背景区域中（x, y）所指定的位置，即 x, y 定义的是背景图像的左上角，相对于背景区域左上角的偏移量。 偏移量长度可以是正值，也可以是负值。x 为正值表示向右偏移，负值表示向左偏移；y 为正值表示向下偏移，负值表示向上偏移。背景图像发生移动后，就有可能超出对象的背景区域。此时，超出的部分将不会显示，只会显示落入背景区域的部分。 如果把上面的例子改为长度值定位，要使背景图像居中，只需把背景图像的位置设置为50px 50px 即可。它就表示背景图像的左上角顶点，相对于对象背景区域的左上角顶点在 x轴右移 50px，在 y 轴下移 50px。得到的结果依然是背景图像位于对象的中央。 在CSS3中，background-position属性支持 4 个参数值，前两个值用于横坐标，后两个值用于纵坐标。这意味着我们可以相对于上左下右任意一个角落定位，而不是之前只能相对于左上角定位。可以用长度值、或百分比来指定背景图像的起始位置。 如果只提供一个值，则第二个值为center。如果提供两个值，第一个长度或百分比表示水平偏移，第二个长度或百分比表示垂直偏移。长度或百分比，表示背景图像的左上角相对于背景位置区域左上角的偏移。如，下面几个声明给出了背景的起点相对于背景区域左上角的偏移：1234567background-position: left 10px top 15px; /* 10px, 15px */background-position: left top ; /* 0px, 0px */background-position: 10px 15px; /* 10px, 15px */background-position: left 15px; /* 0px, 15px */background-position: 10px top ; /* 10px, 0px */background-position: left top 15px; /* 0px, 15px */background-position: left 10px top ; /* 10px, 0px */ 4.5.5 背景附着在CSS中，通过 body 元素 background-image 属性来定义整个窗体的背景图像，通过其他元素自身的 background-image 属性来定义元素自己的背景图像。 定义背景图像之后，默认情况下，当窗体的内容滚动时，窗体的背景图像会跟着一起移动，其他元素的背景图像则不同，始终相对于元素固定不动，不会跟着元素内容一起移动。 CSS提供了 background-attachment属性，可以灵活控制背景图像是跟着元素的内容一起移动，还是固定不动。其可选值有 scroll | fixed | local，默认值为 scroll。 其中，fixed 只对 body 元素有效，local 只对 body 之外的其他元素有效，scroll 则对任何元素都有效。不同取值的含义见表 属性值 含义 fixed 背景图像相对于窗体固定。任凭页面内容滚动，背景图像始终静止不动 scroll 背景图像相对于元素固定。当窗体的内容滚动时，窗体的背景图像会跟着移动；当一般元素的内容滚动时，背景图像不会跟着移动，因为背景图像总是要跟着元素本身，但会随元素的祖先元素或窗体一起移动 loca 背景图像相对于元素的内容固定。当元素的内容滚动时，背景图像总是要跟着内容一起移动 先来看看一般元素的效果。假设把一个容器 div 的 background-attachment 属性值设置为 scroll，因为要查看容器滚动时的效果，要把容器的 overflow 属性设置为 scroll，还要限制容器的尺寸，以便在内容溢出时能产生滚动条。代码如下：12345678div &#123; width: 160px; height: 160px; overflow: scroll; background-attachment: scroll; background-repeat: no-repeat; background-image:url(img/bg.gif);&#125; 1&lt;div&gt;定义背景图像之后， …，不会随着元素自身滚动条的滚动而移动。&lt;/div&gt; 元素内容的滚动条已经向下滚动到达元素的底部，而背景图像并没有随着元素内容的滚动而移动。 现在，把 div 的 background- attachment属性值设置为 local。 元素内容的滚动时，背景图像跟着内容一起移动。另外，对于一般元素，无论其 background-attachment属性是什么值，如果该元素的祖先元素或窗体发生滚动，则该元素连同其背景图像，会作为一个整体，跟着一起移动。 先来看看一般 body 元素的效果。如果把 body 元素的 background- attachment 属性值设置为 scroll，当窗体的内容滚动时，窗体的背景图像会跟着一起移动。这个比较简单，就不再举例。 现在看看 body 的固定背景，假如为 body 元素定义了背景图像，背景图像在整个窗体的中央，位置固定，且不重复。CSS代码如下：123456body &#123; background-position: 50% 50%; background-repeat: no-repeat; background-attachment: fixed; background-image: url(img/bg.gif);&#125; 整个窗体的滚动条已经向下滚动，到达页面的中间，而窗体的背景图像始终静止不动，保持在整个窗体的中央。 4.5.6 背景尺寸在CSS3之前，我们不能指定背景图像的显示大小，一般是按图像的原始尺寸显示。在CSS3中，通过 background-size属性，可以设置背景图像的显示尺寸。 background-size属性的值可以是预定义关键字 cover | contain，也可以是使用长度值、百分比或 auto 定义背景图像的尺寸，长度和百分比不允许负值。 使用预定义值时，cover 表示背景图像完全覆盖容器的背景区域，如果图像过大或过小，则会将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器；contain 表示背景图像始终只填充容器的背景区域，如果图像过大或过小，也会对背景图像等比缩放。但是，当宽度与容器的宽度相等，或高度与容器的高度相等时，则停止缩放。所以，停止放大后，某个方向可能没有完全覆盖，则会显示背景颜色。 使用长度、百分比或 auto 定义尺寸时，需要提供两个参数。如果提供两个，第一个为背景图像的宽度，第二个为背景图像的高度；如果只提供一个，该值为背景图像的宽度，第 2 个值默认为 auto，即高度为 auto，背景图像按提供的宽度等比缩放。 这里对每个取值定义了一个类，然后分别应用到一个容器，来看看 background-size属性在不同取值下的表现。代码如下：12345678910111213141516div &#123; width: 180px; height: 120px; border: 10px dashed #888; background-repeat: no-repeat; background-image: url(img/bg.gif);&#125;.cover &#123; background-size: cover;&#125;.contain &#123; background-size: contain;&#125;.size &#123; background-size: 50% 50%;&#125; 123&lt;div class=\"cover\"&gt;&lt;/div&gt;&lt;div class=\"contain\"&gt;&lt;/div&gt;&lt;div class=\"size\"&gt;&lt;/div&gt; 属性取值 cover 时，背景图像要进行等比放大，以填满整个容器，为了适应容器的宽度，高度已经溢出到了边框的下面；取值 contain 时，背景图像进行等比放大，宽度到达容器的高度后，图像不再进行放大，故容器宽度有空白；使用尺寸时，图像为原始尺寸的 50%。 4.5.7 背景起始位置默认情况下，背景图像从元素的 padding 区域的左上角开始显示。然而，有时候却希望背景图像从边框的左上角、或内容区的左上角开始显示。 这时，就可以通过 background-origin属性来设置背景图像的起始显示位置，可选值有 border-box | padding-box | content-box，默认值为 padding-box。 border-box 表示背景图像从 border 区域的左上角开始显示，当为边框设置透明度后，背景图像和边框相叠加，透过边框可以看见背景图像。padding-box 表示背景图像从 padding区域的左上角开始显示。content-box 表示背景图像从 content区域的左上角开始显示。当内边距为0时，padding-box 与 content-box 的效果相同。 这里对每个取值定义了一个类，然后分别应用到一个容器，来看看 background-origin属性在不同取值下的表现。代码如下：123456789101112131415161718div &#123; width: 120px; height: 90px; padding: 20px; border: 10px dashed #888; background-color: yellow; background-repeat: no-repeat; background-image: url(img/bg.gif);&#125;.border-box &#123; background-origin: border-box;&#125;.padding-box &#123; background-origin: padding-box;&#125;.content-box &#123; background-origin: content-box;&#125; 123&lt;div class=\"border-box\"&gt;&lt;/div&gt;&lt;div class=\"padding-box\"&gt;&lt;/div&gt;&lt;div class=\"content-box\"&gt;&lt;/div&gt; 这里把边框设置为很粗的虚线，并把背景色设置为黄色，以便能够清楚看到背景色或背景图像延伸到边框下的情况。 默认情况下，背景图像从元素的 padding 区域的左上角开始显示。然而，有时候却希望背景图像从边框的左上角、或内容区的左上角开始显示。 这时，就可以通过 background-origin属性来设置背景图像的起始显示位置，可选值有 border-box | padding-box | content-box，默认值为 padding-box。 border-box 表示背景图像从 border 区域的左上角开始显示，当为边框设置透明度后，背景图像和边框相叠加，透过边框可以看见背景图像。padding-box 表示背景图像从 padding区域的左上角开始显示。content-box 表示背景图像从 content区域的左上角开始显示。当内边距为0时，padding-box 与 content-box 的效果相同。 这里对每个取值定义了一个类，然后分别应用到一个容器，来看看 background-origin属性在不同取值下的表现。代码如下：123456789101112131415161718div &#123; width: 120px; height: 90px; padding: 20px; border: 10px dashed #888; background-color: yellow; background-repeat: no-repeat; background-image: url(img/bg.gif);&#125;.border-box &#123; background-origin: border-box;&#125;.padding-box &#123; background-origin: padding-box;&#125;.content-box &#123; background-origin: content-box;&#125; 123&lt;div class=\"border-box\"&gt;&lt;/div&gt;&lt;div class=\"padding-box\"&gt;&lt;/div&gt;&lt;div class=\"content-box\"&gt;&lt;/div&gt; 这里把边框设置为很粗的虚线，并把背景色设置为黄色，以便能够清楚看到背景色或背景图像延伸到边框下的情况。 background-origin 属性只能控制背景图像的表现，不能控制背景色的表现，背景色始终是从元素的边框开始显示。 4.5.8 背景裁剪区域默认情况下，背景颜色的显示范围为 border-box 区域，不重复的背景图像的显示范围为 padding-box 区域，而重复的背景图像的显示范围为 border-box 区域。然而，有时候却希望控制背景的显示范围。 这时，就可以通过 background-clip属性用来定义元素背景的裁剪区域，即背景的显示范围，可选值有 border-box | padding-box | content-box，默认值为 border-box。 CSS中的裁剪区域跟 canvas 中的裁剪区域含义相同，设置裁剪区域后，只有落到裁剪区域内的内容会被显示，而落到裁剪区域外的内容不会被显示出来。 这里对每个取值定义了一个类，然后分别应用到一个容器，来看看 background-clip属性在不同取值下的表现。代码如下：123456789101112131415161718div &#123; width: 120px; height: 90px; padding: 20px; border: 10px dashed #888; background-color: yellow; background-repeat: no-repeat; background-image: url(img/bg.gif);&#125;.border-box &#123; background-clip: border-box;&#125;.padding-box &#123; background-clip: padding-box;&#125;.content-box &#123; background-clip: content-box;&#125; 123&lt;div class=\"border-box\"&gt;&lt;/div&gt;&lt;div class=\"padding-box\"&gt;&lt;/div&gt;&lt;div class=\"content-box\"&gt;&lt;/div&gt; background-clip属性可以同时控制背景图像和背景色的显示范围，而background-origin 属性则不同，它只能控制背景图像，不能控制背景色。 4.5.9 多重背景在CSS3之前，一个元素只能设置一个背景图像。而CSS3中，可以为一个元素添加多个背景图像。定义多图像背景时，只需在 background-image 或 background 属性列出需要使用的所有背景图像，并用逗号隔开。而且，每个背景图像都具有 background 中的任何属性，如可以设置背景位置、设置背景重复、设置背景尺寸等，多个属性值按顺序依次对应。如果某个属性只提供了一个参数值，则所有背景的该属性都使用这个参数值。 默认情况下，背景图像从元素的左上角开始显示，并会在水平方向和垂直方向重复。如果多重背景图像之间存在交集（即背景相互重叠），前面定义的背景图像会覆盖在后面定义的背景图像之上。 所以，定义多背景时，还需要设置背景图像的显示位置和平铺方式。否则，背景重叠的区域会发生覆盖，影响甚至看不出多重背景的效果。如：123456789div &#123; width: 200px; height: 200px; border: 1px dashed #ccc; background-color: yellow; background-repeat: no-repeat; background-position: left top, right bottom; background-image: url(img/bg.gif), url(img/bg2.gif);&#125; 上述代码中，为容器定义了两幅背景图像，一幅图像在左上角，一幅图像在右下角，并把背景颜色设置为黄色。 背景图像没有覆盖到的地方，显示黄色背景颜色。这是因为，如果一个元素同时定义了背景颜色和背景图像，它们会同时生效。当 background-image 属性取值为 none 或指定的 url 无效时，则会显示背景颜色；当背景图像可用时，背景图像将覆盖在背景颜色之上，如果背景图像不能占满整个容器，背景图像没有覆盖的地方也会显示背景颜色。 在定义多重背景时，除了使用独立属性外，也可以复合属性。使用复合属性时，使用逗号来分隔每组背景参数。 使用这种方法的好处是，开发者既可以指定备用背景颜色，也可以为老浏览器指定背景图像。如：123456div &#123; … background: yellow url(img/bg.gif) no-repeat left top; /* 备用颜色和图像 */ background: url(img/bg.gif) no-repeat left top, url(img/bg2.gif) no-repeat right bottom;&#125; 这跟前面的代码几乎是相同的，只是使用了复合属性，而且还为IE8 及其他老浏览器同时提供了背景颜色和背景图像。并且，在现代浏览器中，显示效果也跟前面完全相同。 4.5.10 渐变背景渐变背景也是CSS3 的新特性，通过它可以在不使用图像的情况下，创建从一种颜色到另一种颜色的过渡。使用渐变的好处是，可以减少对图像的依赖，进而降低浏览网页时的带宽消耗，提高网站的访问速度。 渐变，就是两种或多种颜色之间的平滑过渡。在创建渐变时，可以指定多个中间颜色值，这些值称为色标。每个色标包含一种颜色和一个位置，浏览器自动从一个色标的颜色，平滑过渡到下一个色标的颜色。 在CSS3中，只需将 background-image 属性的值设置为渐变，就可以在任何使用背景图像的地方，用渐变来代替背景图像。不过，根据渐进增强的原则，最好为不支持渐变的浏览器提供一个备用选项。并且，备用选项应该出现在渐变规则的前面。 CSS支持三种类型的渐变，一种是线性渐变，一种是径向渐变，一种是重复渐变。线性渐变中，颜色沿着一条直线过渡；径向渐变中，颜色以一个点为中心，以圆形或椭圆形向所有方向扩张变化；重复渐变是多个线性渐变或径向渐变的重复。 线性渐变制作线性渐变效果，首先指定一个渐变的方向、起始颜色、结束颜色。具有这三个参数，就可以制作出一个最简单、最普通的线性渐变效果。如果要制作一个复杂的多色渐变效果，就需要在同一个渐变方向添加多个色标。线性渐变的语法格式为：12linear-gradient([[&lt;angle&gt; | to side-or-corner&gt; ],]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+)&lt;side-or-corner&gt; = [left | right] || [top | bottom] 第一个参数指定渐变的方向，即渐变的直线路径方向，第二个参数表示渐变的起点，第三个参数表示渐变的终点。 渐变方向为可选参数，它决定渐变颜色的停止位置，默认值为 to bottom，表示从上向下的垂直渐变。渐变方向有两种表示方法，一种是角度，一种是预定义关键字： 1）角度 角度表示法是通过圆弧的角度来表示方向，正值按顺时针旋转，负值按逆时针旋转。其中，0deg 表示从下向上， 90deg 表示从左向右、180deg 表示从上向下、270deg 表示从右向左。 2）预定义关键字 使用预定义关键字时，方向可以指向矩形的某个边或某个角，如，to top 表示从下向上、to right 表示从左向右、to bottom 表示从上向下、to left 表示从右向左、to top right 表示从左下角向右上角。关键字与角度的对应关系为 to right 对应 90deg 或 -270deg，to top right 对应 45deg 或 -315deg，依次类推。 参数 color-stop，用来定义渐变路径上色标的列表，列表用逗号隔开。每个色标包含一种颜色和一个位置，中间用空格隔开，如 blue %0，表示渐变的起点，其颜色为蓝色。由于列表中的第一个参数始终是渐变的起点，最后一个参数始终是渐变的终点。所以，可以省略位置信息，对于省略位置信息的点，浏览器认为它们均匀分布，并根据列表中点的个数，自动计算每个色标的位置。 起点也可以是负值，表示渐变从实际可见区域之外的某个地方就开始了。终点也可以是大于 100% 的值，表示渐变到实际可见区域之外的某个地方才结束。无论如何，浏览器只会渲染可见区域，即 0% ~ 100% 之内的区域，而不会渲染非可见区域。 接下来，通过对一个 200px * 100px的矩形容器应用线性渐变的一些实例，来深入理解线性渐变各个参数的用法和含义。 例1 定义垂直方向的线性渐变，只定义两种颜色，表示从一种颜色向第二种颜色渐变。以下几种不同定义方式的效果完全相同：12345linear-gradient(yellow, blue);linear-gradient(to bottom, yellow, blue);linear-gradient(to bottom, yellow 0%, blue 100%);linear-gradient(180deg, yellow, blue);linear-gradient(to top, blue, yellow); /* 注意色标位置的变化 */ 垂直方向渐变第一个定义，只提供了两种颜色，由于省略渐变方向，则使用默认值 to bottom，由于省略渐变颜色停止点的位置，则第一个参数始终是渐变的起点，最后一个参数始终是渐变的终点。第 2~4 个定义，只是使用默认参数，把第一个定义所缺少的参数进行补全而已，所以它们的效果是等价的。 例2 使用角度定义包含两个渐变点线性渐变，省略渐变起点和终点的位置信息：123linear-gradient(135deg, yellow, blue);linear-gradient(-215deg, yellow, blue);linear-gradient(-45deg, blue, yellow); /* 注意色标位置的变化 */ 对角线方向渐变省略渐变点的位置信息后，浏览器自动把第一个参数作为渐变的起点，把最后一个参数作为渐变的终点。 例3 定义包含三个渐变点的线性渐变，省略了方向参数、以及渐变起点和终点的位置信息：1linear-gradient(yellow, blue 20%, #0f0); 三种颜色的垂直方向渐变渐变以黄色为起点，平滑过渡到 20% 的位置后，再从蓝色平滑过渡到最终的绿色。 例4 使用预定义关键字，定义沿矩形对角线方向、包含三个渐变点的线性渐变：1linear-gradient(to top right, red, white, blue) ; 三种颜色的对角线方向渐变矩形左下角的颜色为红色，右上角的颜色为蓝色。由于省略了各个渐变点的位置信息，并提供了 3 个值，浏览器计算得到点的位置分别为 0%、50%、100%，于是，50% 处为白色，即从左上角到右下角的对角线两侧为白色。 径向渐变径向渐变的颜色不再沿一条直线路径变化，而是以一个点为中心，以圆形或椭圆形向所有方向扩张变化。语法格式为：123456radial-gradient( [ [ &lt;shape&gt; || &lt;size&gt; ] [ at &lt;position&gt; ]? , | at &lt;position&gt;, ]? &lt;color-stop&gt; [ , &lt;color-stop&gt; ]+) 径向渐变的语法稍微有点复杂，这里从一个简单的例子入手，先有个感性的认识，然后再介绍各个参数的含义和用法。 本例定义了一个 200px * 100px的矩形框，该矩形框的 background-image 属性被设置为一个径向渐变，故使用径向渐变作背景。CSS代码如下：12345div &#123; width: 200px; height: 100px; background-image: radial-gradient(circle 5em at top left, yellow, blue);&#125; 径向渐变上述径向渐变的代码表示，该渐变以圆形向所有方向扩张，扩张结束时的半径为 5em，渐变的中心点（即圆心）为矩形的左上角顶点，渐变起点的颜色为黄色，终点的颜色为蓝色。 接下来，看看径向渐变语法格式中的 &lt;position&gt;、&lt;shape&gt;、&lt;size&gt; 这 3 个参数的含义和用法。的含义和用法跟线性渐变类似，不再赘述。 1）&lt;position&gt; 用来定义径向渐变中心点的位置，其值与 background-position 属性类似，用于定义渐变的中心点的位置。如果省略该参数，则使用默认值 center，表示渐变的中心点与对象的中心点重合。 2）&lt;shape&gt; 用来定义径向渐变的形状，取值为 circle 或 ellipse。省略该参数时，根据参数 size 所提供的值的个数来决定其默认形状。如果 size 的值为单个长度值，则默认值为 circle；其它情况下，默认值为ellipse。 3）&lt;size&gt; 用来定义径向渐变的结束形状尺寸，为可选参数。该参数的值可以是长度值、或百分比、或扩展关键字。如果省略，则使用默认值 farthest-corner。 如果 &lt;shape&gt; 设置为 circle 或者省略，则 &lt;size&gt; 可能被显式设置为：&lt;length&gt;，不允许负值，表示显式定义圆的半径。 如果 &lt;shape&gt; 设置为 ellipse 或者省略，则 &lt;size&gt; 可能被显式设置为：[&lt;length&gt; | &lt;percentage&gt;]{2}，不允许负值，表示显式定义椭圆的尺寸。第一个值表示椭圆的水平半径，第二个值表示椭圆的垂直半径。使用百分比的值时，相对于渐变区域的尺寸。 在CSS中，一切皆是框，即任何元素都被看作是一个矩形框，扩展关键字就是通过渐变中心点到矩形框的四条边或四个顶点之间的距离，来确定渐变结束形状的半径。扩展关键字有 closest-side | closest-corner | farthest-side | farthest-corner，默认值为 farthest-corner。 background-position 属性扩展关键字取值及含义属性值|含义:–|:–closest-side |圆形渐变，把渐变中心到四条边的最小距离，作为圆的半径；椭圆形渐变，把渐变中心到上下两条边的最小距离，作为椭圆的垂直半径，到左右两条边的最小距离，作为椭圆的水平半径closest-corner |使渐变的结束形状，经过距渐变中心最近的角farthest-side |与 closest-side 相反，取最大值作为半径farthest-corner |使渐变的结束形状，经过距渐变中心最远的角使用上面的定义进行扩展后，径向渐变的语法就变成：123456789&lt;radial-gradient&gt; = radial-gradient( [ [ circle || &lt;length&gt; ] [ at &lt;position&gt; ]? , | [ ellipse || [ &lt;length&gt; | &lt;percentage&gt; ]&#123;2&#125; ] [ at &lt;position&gt; ]? , | [ [ circle | ellipse ] || &lt;extent-keyword&gt; ] [ at &lt;position&gt; ]? , | at &lt;position&gt; , ]? &lt;color-stop&gt; [ , &lt;color-stop&gt; ]+)&lt;extent-keyword&gt; = closest-corner | closest-side | farthest-corner | farthest-side 接下来，通过对一个 200px * 100px的矩形容器应用径向渐变的一些实例，来深入理解径向渐变各个参数的用法和含义。 例1 定义形状为椭圆形的径向渐变，以下几种不同定义方式的效果完全相同：123radial-gradient(yellow, green);radial-gradient(ellipse at center, yellow 0%, green 100%);radial-gradient(farthest-corner at 50% 50%, yellow, green); 两色椭圆形径向渐变第一个定义，只提供了渐变起点和终点的颜色，将以对象的中心点为径向渐变的中心点，由于 size 的默认值为 farthest-corner。因此，如果对矩形元素应用背景，得到的默认渐变形状就是椭圆形；如果对正方形元素应用背景，得到的默认渐变形状就是圆形。第二个和第三个定义，只是把第一个定义所缺少的参数，使用默认参数进行补全而已。所以，这三个定义是等价的。 例2 定义形状为圆形的径向渐变：1radial-gradient(circle, yellow, green); 两色圆形径向渐变本例把例1中的径向渐变的 shape 参数显式设置为 circle，故得到的渐变就是圆形。由于未定义 size 参数，故使用渐变中心到四条边的最大距离（本例中，为矩形的中心点到左右两侧的距离，即矩形宽度的一半），作为圆的半径。 例3 定义形状为椭圆形、包含三种颜色的径向渐变：1radial-gradient(red, yellow, green); 三色椭圆形径向渐变本例与例1完全相同，故得到的形状、半径也相同，不同的是本例定义了三个颜色停止点，但未定义每种颜色的位置，故浏览器按颜色停止点的数目，自动计算每个颜色停止点的位置。 例4 定义形状为椭圆形、包含三种颜色的径向渐变：12radial-gradient(closest-side at 20px 30px, red, yellow, green);radial-gradient(20px 30px at 20px 30px, red, yellow, green); 三色椭圆形径向渐变本例中，渐变的 size 参数使用了扩展关键字 closest-side，故使用渐变中心到四条边的最小距离作为椭圆的半径。由于渐变中心点的坐标为（20px, 30px），故得到椭圆的水平半径为 20px，垂直半径为 30px。 例5 定义形状为圆形、包含三种颜色的径向渐变：12radial-gradient(closest-side circle at 20px 30px, red, yellow, green);radial-gradient(20px 20px at 20px 30px, red, yellow, green); 三色圆形径向渐变本例与例4的唯一不同，就是把渐变的形状改成了圆形，由于使用了 closest-side，故使用渐变中心到四条边的最小距离作为圆的半径，得到圆的半径为 20px。 重复渐变除了linear-gradient 和radial-gradient 外，CSS3还支持repeating-linear-gradient 和 repeating-radial-gradient，它们表示重复线性渐变和重复径向渐变。 浏览器渲染时，会在两个方向上无限重复 color-stop，其位置也会按最后一个color-stop 的位置与第一个color-stop 的位置之差的整数倍进行移动。如，repeating-linear-gradient(red 10px, blue 50px) 就相当于 linear-gradient(…, red -30px, blue 10px, red 10px, blue 50px, red 50px, blue 90px, …)。 需要注意的是，在重复渐变时，最后一个 color-stop 和第一个color-stop 永远是每个组的边界，当一个渐变不是以相同的颜色开始和结束时，这会导致边界处的颜色急剧变化。 重复渐变的语法，跟线性渐变和径向渐变的语法完全相同。这里通过三个例子，来看看重复渐变的效果。 例1 repeating-linear-gradient(red, blue 20px, red 40px); 本例中，渐变从红色开始，向 20px 处的蓝色渐变，再向 40px 处的红色渐变。由于是一个重复的线性渐变，会不断重复这个渐变效果。重复线性渐变 例2 repeating-radial-gradient(red, blue 20px, red 40px); 重复径向渐变 例3 repeating-radial-gradient(circle closest-side at 20px 30px, red, yellow, green 100%, yellow 150%, red 200%);重复径向渐变 4.6 盒尺寸在CSS中，通过 width 和 height 属性来定义一个盒子的宽度和高度，可以用长度值或百分比来设置，不允许负值。使用百分比时，根据父元素的宽度进行计算盒子的宽度，根据父元素的高度进行计算盒子的高度。 如果一个盒子没有显式定义 width 属性，则宽度的计算结果跟定位类型相关：静态定位或相对定位的盒子，其宽度为父元素宽度的100%；绝对定位和浮动的盒子，其宽度根据所包含内容自动扩展，最大宽度为包含块宽度的100%。 由于历史原因，在计算一个盒子的尺寸时，浏览器对盒模型存在两种不同的解析模式，一种是标准模式（strict mode），另一种是怪异模式（quirks mode）。 所谓标准模式，是指浏览器遵从W3C标准解析执行；怪异模式则是使用浏览器自己的方式解析执行，因为不同浏览器解析执行的方式不同，故称为怪异模式。IE的早期版本，包括IE6都使用怪异模式，而现代浏览器都使用标准模式。 在标准模式下，一个盒子的尺寸是指 content-box 区域的尺寸；而在怪异模式下，一个盒子的尺寸是指border-box 区域在内。无论哪种模式，一个盒子所占据的页面空间，都是 margin-box 区域的尺寸。如：1234567.box &#123; width: 200px; height: 200px; margin: 30px; padding: 50px; border: 20px solid black;&#125; 在标准模式下，由于 padding 和 border 不占据盒子的尺寸，所以，盒子 content 区域的尺寸，始终等于盒子的 width 和 height 属性的值，即 200×200，而盒子所占用的空间会随 padding、border 和 margin 向外扩展。 盒子在水平方向所占用的空间 = 盒尺寸 + padding + border + margin = width + padding + border + margin = 200 + (50 + 20 + 30) * 2 = 200 + 200 = 400。垂直方向的计算方法相同。 在怪异模式下，盒子的尺寸始终等于盒子的 width 和 height 属性的值，即 200×200。所以，盒子的 padding 和 border 会吞噬content 区域，导致content 区域的宽度 = width – border – padding = 200 – (20 + 50) 2 = 200 – 70 2 = 200 – 140 = 60。 盒子在水平方向所占用的空间 = 盒尺寸 + margin = width + margin = 200 + (30) * 2 = 260。垂直方向的计算方法相同。 在CSS3之前，设计师常常被这两种不同的盒模型所困扰，在一个浏览器下好好的布局，到了另一个浏览器下却变得支离破碎。 为了解决这个问题，CSS3 新增了一个盒模型属性 box-sizing，使这种不统一的局面得到改善。 设计师可以通过 box-sizing属性，来自行选择一个盒子的解析模式。box-sizing属性的可选值有content-box | border-box，默认值为 content-box。content-box 表示使用标准模式来解析计算盒尺寸，border-box 表示使用怪异模式解析计算盒尺寸。 虽然IE 对盒模型的解释不符合W3C的规范，但它更符合常理。它的好处是，无论如何修改元素的边框或内边距的大小，都不会影响元素生成框的总尺寸，也就不会破坏页面的整体布局。 而在标准模式下，一旦修改元素的边框或内边距的大小，就不得不重新计算元素生成框的尺寸，从而影响整个页面的布局，这无疑增加了页面布局的难度。所以，使用 border-box 会使页面布局更加方便，它将会成为盒模型的主流。 4.7 处理溢出在CSS中，如果设置了一个盒子的宽度与高度，则盒子中的内容就可能超过盒子本身的宽度或高度。此时，可以使用 overflow 属性来控制内容溢出时的处理方式。 overflow属性的可选值有 visible | hidden | scroll | auto，除了body 和 textarea 的默认值为auto外，其它元素的默认值为visible。 如果不设置 overflow属性，则默认值就是 visible。所以，一般而言，除非你想覆盖它在其它地方被设定的值，并没有什么理由把 overflow属性设置为 visible。 假设有一个设置了固定宽度和高度的盒子，其内容的尺寸，超过了盒子本身的尺寸：12345div &#123; width: 20em; height: 4em; border: 1px solid #ccc;&#125; 由于并没有设置 overflow属性，表示使用其默认值 visible，让溢出的内容可见。此时，溢出的内容就会渲染到盒子的外面。 由于溢出的内容并不改变盒子的形状，尽管盒子外面的内容是可见的，但它不会把周围其他容器中内容挤下去。所以，溢出的内容不会影响页面布局，但溢出的内容可能与周围其他容器中内容重叠。 注意：在IE6和更低版本中，拥有布局的元素会自动扩展，以便适应内容的尺寸。在IE6下，元素的高度根据自动扩展。根据CSS规范，这种扩展实际上是错误的，这种错误意味着Window上的IE中的 height实际上更像是min-height，这种行为常常会破坏布局。 如果把 overflow属性设置为 hidden，情况则与 visible 相反，它会把超出盒子的内容全部隐藏掉。 这种情况下，由于盒子不会出现滚动条。所以，对用户来说，被隐藏的内容就彻底看不到（除非去查看源代码）。 如果把 overflow属性设置为 scroll，它将会隐藏渲染到盒子之外的内容，但会在盒子内部提供一个滚动条，从而可以查看剩下的内容。 这种情况下，无论内容是否溢出，都会在水平和垂直方向同时出现滚动条。此时，也可以使用 overflow-x 或 overflow-y 属性，来单独设置水平方向和垂直方向溢出时的处理方式，其语法与 overflow 完全相同。其实，overflow 的作用就相当于overflow-x + overflow-y。 如果把 overflow属性设置为 auto，则只在需要的时候出现滚动条，即当内容溢出时自动出现滚动条，未溢出时不出现。 4.8 框的生成在盒模型中，一切皆为框，即页面上的每个元素会生成一个矩形框。默认情况下，一个元素的类型，决定了该元素生成框的类型。块级元素生成块级框，行内级元素生成行内级框，没有被任何元素所包含的文本生成匿名框。 也可以通过元素的 display 属性，来改变框的显示类型。可以把块级元素的 display 属性设置为 inline 或 inline-block，让它生成行内级框；也可以把行内块级元素的 display 属性设置为 block，让它生成块级框。 4.8.1 块级元素和块框块级元素（block-level element），就是那些在源文档中被格式化成块的元素。每个块级元素都会形成一个新的内容块，左右不能放置其他元素。典型的块级元素有div、p、h1~h6、ul、ol、table，等等。 如果一个元素的 display 属性值为 block、list-item、table、flex，它就会生成一个块级框，用来包含后代框和其他生成的内容。 每个块级框被渲染为完整的一行，即便一行的空间足以容纳多个块级框也是如此。假设在一个 div 容器中，包含三个块级子元素：12345&lt;div class = \"wrapper\"&gt; &lt;div&gt;div&lt;/div&gt; &lt;p style = \"width: 100px;\"&gt;p&lt;/p&gt; &lt;h1 style = \"width: 100px;\"&gt;h1&lt;/h1&gt;&lt;/div&gt; 假设把 .wrapper 容器的宽度设置为 300px，把 p 元素和 h1 元素的宽度都设置为 100px。为了便于观察，并为div、p、h1都设置了 10px 的外边距和 1px 的虚线边框：123456789.wrapper &#123; width: 300px; height: 120px; border: 1px solid #ccc;&#125;div, p, h1 &#123; margin: 10px; border: 1px dashed gray;&#125; .wrapper 容器和三个子元素都分别生成一个块级框，由于 div、p、h1 子元素都是块级元素，它们分别独占一行。虽然一行的空间足以同时容纳 p 元素和 h1 元素， 但它们生成的块级框也是各自独占一行。 有些块级元素，除了生成块级框外，还会生成其他的框，如 display 属性值为 list-item 列表元素，会生成额外的框来放置列表的项目符号。假设有一个有序列表：12345&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt;&lt;/ol&gt; 为了方便查看效果，为 ol 和 li 元素都设置 1px 的灰色边框：123456ol &#123; border: 1px solid #ccc;&#125;li &#123; border: 1px dashed gray;&#125; 有序列表 ol 元素本身是块级元素，其子元素 li 也是块级元素。因此，ol 元素会生成一个块级框，每个 li 子元素也会生成一个块级框。在为每个 li 子元素生成块级框时，还会生成额外的框，用来放置列表的项目符号。 除了 table 框和替换元素的框，一个块级框同时也是一个块容器框。一个块容器框要么只包含块级框，要么创建一个行格式化上下文，并只包含行内级框。 并不是所有的块容器框都是块级框，非替换的行内块（inline-block），以及非替换的表格单元格都是块容器框，但它们都不是块级框。如果一个框既是块级框，同时又是块容器框，则被称作块框。 4.8.2 行内元素和行内框行内级元素（inline-level element），就是那些在源文档中不会形成新块的元素，这些元素的左右可以放置其他元素。典型的行内级元素有 span、em、strong、a，等等。 根据元素自身的特点，行内级元素又被分为非替换元素和替换元素。 非替换元素的内容直接包含在文档中，浏览器在渲染页面时，会读取元素的内容，并直接显示在页面上。说白了，非替换元素的内容就是文本。如：1&lt;span&gt;这里是span元素的内容&lt;/span&gt; 替换元素仅仅是内容的占位符，它只个空元素，并没有实际内容。浏览器在渲染页面时，会根据元素及相关属性，来判断要显示的内容。替换元素的一个典型例子就是 img 元素。如：1&lt;img src = \"logo.jpg\" /&gt; 在渲染页面时，浏览器发现是 img 元素，就会读取其 src 属性的值，并按照 src 属性的指示，读取图像文件 logo.jpg 的内容，显示在 img 元素所在的位置。如果查看HTML代码，却看不到图像的实际内容。 大多数的表单元素，如 input、textarea、select 等，都是替换元素。通过CSS的content属性插入的对象，是匿名替换元素。 如果一个元素的 display 属性的取值为 inline、inline-block、inline-table、inline-flex，它就会生成一个行内级框：display 属性值为 inline 的非替换元素生成的行内级框，称作行内框；行内级替换元素、行内块元素（inline-block）、行内表格元素（inline-table）、行内弹性盒（inline-flex），生成的行内级框，称作原子行内级框（Atomic Inline-level Box）。 行内框的内容允许被拆分，并在多行显示。假设在一个段落中，有一个 span 元素和一个 a 元素：1234&lt;p&gt;&lt;span&gt;我是 display 属性值为 inline 的非替换元素，&lt;/span&gt;&lt;a href=\"#\"&gt;我是超级链接&lt;/a&gt;&lt;/p&gt; 由于默认情况下，span 元素和 a 元素都是 display 属性值为 inline 的非替换元素，它们都会生成行内框。当一行内无法容纳所有行内级框时，在容器的边界处会发生换行。换行时，行内框的内容允许被拆分，在多行显示。如，a 元素的内容被拆分在多行显示。 而原子行内级框具有原子性，其内容永远作为一个整体，在同一行内显示，不允许被拆分。这就是它之所以被称为原子行内级框的理由。当然，这是有道理的，想想你有什么理由要把一幅图像、或一个文本输入框、或一个表格拆分开来进行显示。 如果把 a 元素的 display 属性设置为 inline-block，它就会生成原子行内级框。 一个行内非替换元素内容区的宽度，仅由其内容决定，而其高度由 font-size 属性决定，并且等于 font-size 属性的值。width 和 height 属性对行内非替换元素无效，因此无法通过 width 和 height 属性，来改变其宽度和高度。假设一个行内级元素 span 的 font-size为 24px，则其内容区的高度就是 24px。1&lt;span&gt;Inline element&lt;/span&gt; 1234span &#123; font-size: 24px; border: 1px dashed #ccc;&#125; 一个行内非替换元素所生成的行内框的高度，仅仅由其 line-height 属性决定，并等于 line-height 属性的值，垂直方向的外边距、边框、内边距都不能增加行内框的高度。 line-height 属性只能应用于行内框，不能应用于原子行内级框。把 line-height 与 font-size 之差，称作行距（leading），浏览器把行距分成两半，称为半行距（half-leading），分别加到行内框内容区的顶部和底部。 如果 line-height 大于 font-size，则行距为正值，使行内框的高度增加。假设把上述 span元素的 line-height 属性值设置为 36px：12345span &#123; font-size: 24px; line-height: 36px; border: 1px dashed #ccc;&#125; 由上述规则可知，行内框的高度为 36px，内容区的高度为 24px，行距 = line-height - font-size = 12px，半行距为 6px，分别加到其内容区的顶部和底部。 如果 line-height 小于 font-size，则行距为负值，使行内框的高度减小。假设把上述 span元素的 line-height 属性值设置为 12px：12345span &#123; font-size: 24px; line-height: 12px; border: 1px dashed #ccc;&#125; 由上述规则可知，行内框的高度为 12px，内容区的高度为 24px，行距 = line-height - font-size = -12px，半行距为 -6px，分别加到其内容区的顶部和底部。 如果 line-height 小于 font-size，则行内框的高度小于内容区的高度，使内容溢出到行内框的外面。在堆叠的行中，这种情况会导致相邻两行的内容发生重叠。 原子行内级框的情况则完全不同，不仅可以通过 width 和 height 属性来设置框内容区的宽度和高度，而且可以通过垂直方向的外边距、边框、内边距，来增加框的高度。 假设有一幅图像，其固有尺寸是 20px*20px，通过width 和 height 属性，将其显示尺寸设置为40px*40px：1&lt;img src=\"img/biggrin.gif\"&gt; 12345img &#123; width: 40px; height: 40px; border: 1px dashed #ccc;&#125; 此时，图像的显示尺寸将是 40px*40px，而不是其固有尺寸 20px*20px。 当然，如果没有显式声明的 width 和 height 属性，内容区的宽度则由其内容决定。也可以只设置 width 或 height 属性中的某一个，这样的话，另一个值将会根据内容的尺寸自动调整。 假设为上述的图像添加 40px 的垂直内边距和 10px的边框，由于内边距和边框都会增加框的高度，则得到框的高度就是 140px。 因此可以说，除了在行内显示外，原子行内级框的表现，更像一个块级框。然而，无论是行内框，还是原子行内级框，水平方向的外边距、边框、内边距对它们都有效，都会增加它们的宽度。 4.8.3 匿名文本和匿名框一个元素可以按照HTML元素的嵌套方式包含其他元素，大多数情况下，框都是由显式定义的元素所生成的。 然而，当把文本直接添加到一个块容器元素中（不是包含在行内元素）时，即便没有为这些文本显式定义元素，它们也会生成框。 没有被元素显式包含的文本，称作匿名文本，因为没有与之关联的元素。把匿名文本所生成框，称作匿名框。匿名框分为两种，一种是匿名块框，另一种是匿名行内框。 当把文本直接添加到一个块容器元素中，而该块容器元素中还有其他块级元素时，这些文本就会生成匿名块框。如，以下HTML代码片段：1234&lt;div&gt; Some text &lt;p&gt;More text&lt;/div&gt; 看上去，似乎是 div 包含行内内容和块级框。然而，根据CSS规范，如果一个块级容器框内（如，上面 div 生成的框），有一个块级框（如，上面 p 生成的框），则会强制这个块级容器框中的所有框，都是块级框。 因此，上述代码会生成一个块级框，来包围“Some text”文本，并把所生成的块级框称作“匿名块框”。 当把文本直接添加到一个块级容器中，而该块级容器中没有其他块级元素时，这些文本就会生成匿名行内框。匿名文本中的空白字符，根据 white-space 属性，如果能被合并，则不会生成任何匿名行内框。如，下面的HTML代码片段：1&lt;p&gt;Some &lt;em&gt;emphasize&lt;/em&gt; text&lt;/p&gt; 为了格式化这个段落，p 元素会生成一个块级框，其中包含三个行内框，分别是 em 元素生成的行内框，以及匿名文本“Some”和“text”生成的匿名行内框。 由于匿名框没有与任何元素相关联，因此不能被任何选择器选中。所以，匿名框只能从父元素继承那些可以继承的属性，那些不能继承的属性则使用默认值。假设本例的CSS代码如下：1234567p &#123; color: red; border: 1px solid #444;&#125;em &#123; color: #000;&#125; 由于 color 属性具有继承性，而 border 属性不具有继承性。因此，匿名行内框中的文本是红色的，且没有边框。 4.8.4 元素的display属性使用 display属性，可以改变一个框的显示类型，显示类型就决定了一个元素生成框的类型，同时也会影响一个框的行为。 可以把行内元素的 display属性设置为 block，它将生成一个块级框，并表现得像块级元素一样。并且，浏览器会把它作为一个块级框来摆放，它会独占一行，并且可以像处理 div 一样设置样式，如设置其宽度、高度、垂直外边距、垂直内边距。比如，把链接元素 a 的 display属性设置为 block，则整个元素都会成为链接的一部分，用户的鼠标指针停留在元素框的任何位置，都能激活这个链接。 同样，也可以把行内元素的 display属性设置为 inline，让它成为行内元素，此时，width、height 等属性将失效。 不过，需要注意的是，display属性只能改变元素的显示角色，而没有改变一个元素的本质。换句话说，可以让一个段落生成行内框，但并不能让这个段落元素真正变成一个行内元素。行内元素可以是一个块级元素的后代，反过来则不行。 在CSS2.1中，还可以把一个元素的 display属性设置为 inline-block，让它生成一个行内级框，它同时具有块级框和行内框的特征，它像行内框一样在行内水平依次排列，但仍然可以向块级框的一样设置样式，如设置宽度、高度、垂直内边距、垂直外边距。如果未定义行内块的 width 属性，元素框收缩以适应内容。也就是说，元素框的宽度刚好足够包含其内容，而没有多余的空间。 也可以把元素的 display属性设置为 none，让元素根本没有框，这样的话，该框及其所有内容就不再显示，也不占据文档中的空间。 还可以通过 visibility 属性设置元素的可见性。设置为 visible 时，让对象可见；设置为 hidden 时，把对象隐藏，让其不可见。 display:none 与 visibility:hidden的区别当为一个元素设置 display: none 或 visibility: hidden时，元素都不会被显示在页面上，但它们之间却有本质上的区别。display: none 的元素，会不留痕迹的从页面上消失，也不占用页面上的空间；而 visibility: hidden 的元素，则只是阻止浏览器显示其内容，让其不可见而已，它在页面上占据的空间依然会保留，会在原来的位置留下一个洞。对于绝对定位的元素而言，它已经脱离文档流，display: none 和 visibility: hidden 的效果是一样的。 4.9 框的外观4.9.1 轮廓样式在CSS中，outline属性用来为元素绘制轮廓，该属性在CSS2.1中就已经定义，但并未得到各主流浏览器的广泛支持。在CSS3中，对outline属性进行了增强，其语法格式为：1outline：[ outline-width ] | [ outline-style ] | [ outline-color ] 也就是说，outline属性可以分解为 outline-width、outline-style、outline-color 这 3 个参数值来定义轮廓的宽度、轮廓的样式和轮廓的颜色。各参数的含义见表 参数 含义 outline-width 轮廓的宽度，与borde-width属性取值相同，请参阅。如果outline-style设置为none，则忽略该属性。 outline-style 轮廓的样式，与borde-style属性取值基本相同（但少了值 hidden），请参阅。如果outline-width等于0，则忽略该属性。 outline-color 轮廓的颜色，与borde-color属性取值基本相同，请参阅。如果outline-width等于0或outline-style设置为none，则忽略该属性。 默认情况下，轮廓是以border边界为起点，从0开始向外延伸。轮廓和边框不是同一个东西，它们可以在同一个元素上共存。 为了灵活控制，CSS3增加了outline-offset属性，用来控制轮廓的起点与border边界的距离。outline-offset属性的值可以是正值，也可以是负值，正值表示起点在border外，负值表示起点在border内。无论正值或负值，轮廓都是从起点向外延伸。如：1234567div &#123; width: 100px; height: 40px; border: 1px dashed #ccc; outline: 14px solid #444; outline-offset: 10px;&#125; 上述代码，在距容器边框10px的地方，添加了一个宽度为14px的浅黑色实线轮廓。 添加轮廓的目的，主要是为了突显元素。轮廓与边框有点类似，但二者又有重要的区别。首先，轮廓不在文档流中，它不占用空间，因此轮廓出现或消失都不会导致文档重新显示，也不会不影响元素的尺寸。其次，轮廓可以是矩形，也可以不是矩形。最后，在元素四条边上的轮廓是完全相同的，不能单独设置。 虽然轮廓不占用空间，显示或消失都不会影响文档流，也不会破坏页面布局。但是，在轮廓很宽时，它会与相邻的元素重叠，而影响到相邻的元素。 有些浏览器会向获得焦点的文本输入框应用轮廓，指示用户键入时会从哪里开始输入。当然这并非必要，有时候反而会妨碍用户输入。如果不愿意，可以把 outline-style 设置为 none，来阻止浏览器这么做。 4.9.2 自由缩放为了增强用户体验，CSS3新增的一个非常实用的 resize属性，它允许用户通过拖动的方式，来自由缩放元素的尺寸。这在以前只能通过Javascript 编写大量脚本来实现，费时费力，效率低下。 resize属性的可选值有 none | both | horizontal | vertical，默认值为 none。none 表示不允许用户调整元素的尺寸；both 表示用户可以调整元素的宽度和高度；horizontal 表示用户仅可以调整元素的宽度；vertical 表示用户仅可以调整元素的高度。如：12345678div &#123; margin: 20px auto; border:1px solid #444; width: 120px; height: 120px; overflow: auto; resize: both;&#125; 定义了resize属性后，元素的右下角会出现允许拖动的标志，用户可以点中右下角进行拖动，来随意改变元素的尺寸。 需要注意的是，resize属性主要用于可以使用 overflow 属性的任何元素。所以，必须为元素定义 overflow 属性，否则，resize属性无效，元素的尺寸不允许改变。 在使用 resize属性调整元素的尺寸时，建议配合 cursor 属性使用，通过相应的鼠标样式，来增强用户体验。如，resize: both 时使用 cursor: se-resize，resize: horizontal 时使用 cursor: ew-resize，resize: vertical 时使用 cursor: ns-resize。 4.9.3 显示风格在CSS3中，可以通过 appearance属性使元素呈现为标准的用户界面元素，如按钮、菜单、文本输入框、单选按钮、多选按钮、列表等等。 也就是说，使用 appearance属性，可以改变任何元素的默认风格，但所有主流浏览器都不支持它。到现在为止，只得到 Webkit 和 Gecko 两个内核的支持，但需要加上浏览器的私有前缀。如，让链接元素默认显示为按钮风格：123456a &#123; width: 100px; height: 40px; -moz-appearance: button; -webkit-appearance: button;&#125; 由于 appearance属性还没有成为标准，在渲染时，仍然是各浏览器各自为政，还无法达到统一的标准。因此，在Chrome和Firefox浏览器中会得到不同的渲染效果。 4.9.4 倒影效果在CSS3之前，要在网页中使用倒影效果，只能事先使用 photoshop 将倒影设计好，然后导入到网页中，这不但耗费资源，而且影响开发的效率。 CSS3中，新增了 box-reflect属性，通过该属性为元素添加倒影效果。语法格式为：1box-reflect：&lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;? 也就是说，在 box-reflect属性中，通过 direction、offset、mask-box-image 这 3 个参数来定义倒影的方向、偏移和遮罩效果。box-reflect属性的参数及含义 参数 含义 direction 用来设置倒影出现的方向，可选值有 above \\ below \\ left \\ right，分别表示倒影在对象的上、下、左、右出现 offset 用来设置倒影距离对象本身的距离，用长度或百分百来定义（百分百根据对象的尺寸确定），默认值为0。可以是正值，也可以是负值。为正值时，倒影向远离元素的方向偏移；为负值时，倒影向靠近元素的方向偏移 mask-box-image 用来设置倒影上的遮罩效果，遮罩将覆盖倒影区域。遮罩可以是none、图像、线性渐变、径向渐变、重复线性渐变、重复径向渐变。如果省略该参数值，则默认无遮罩 默认情况下，一个元素是没有倒影的，通过 box-reflect属性，可以为任何元素添加倒影效果，视频也不例外。不过，目前为止，box-reflect属性仅得到 Webkit 内核的支持，在使用时需要添加浏览器私有前缀。如，页面上有一个容器，容器的内容是一首唐诗：123456&lt;div class=\"wrapper\"&gt;&lt;h1&gt;静夜思&lt;/h1&gt;&lt;h2&gt;唐·李白&lt;/h2&gt;&lt;p&gt;床前明月光，疑是地上霜。&lt;/p&gt;&lt;p&gt;举头望明月，低头思故乡。&lt;/p&gt;&lt;/div&gt; 现在，通过 box-reflect属性，在容器的下方，距离容器本身 2px 的地方，为容器添加倒影，让容器中的文本出现镜像效果：123456789101112131415.wrapper &#123; width: 200px; font-size: 14px; text-align: center; border: 1px solid #ccc; -webkit-box-reflect: below 2px;&#125;h1 &#123; font-size: 16px; letter-spacing: 10px;&#125;h2 &#123; font-size: 13px; font-weight: normal;&#125; 镜像的倒影效果非常简单，而在实际应用中，还可以使用遮罩来制造更加绚丽的倒影效果。如，使用线性渐变来制造朦胧的文本倒影：1234.wrapper &#123; … -webkit-box-reflect: below 2px linear-gradient(transparent, transparent 50%, #000);&#125; 4.9.5 鼠标样式在浏览网页时，通常看到的鼠标光标形状有箭头、手形、沙漏等，而在 windows 中实际看到的鼠标指针种类比这个还要多。 一般情况下，鼠标光标的形状由浏览器负责控制，大多数情况的光标形状为箭头形状，当指向链接时，光标形状会变成手指形状。 为了创建丰富的Web应用，CSS中提供了 cursor属性，允许设计师为页面上的任何元素自定义鼠标光标的形状。如，把鼠标光标样式设置为 row-resize，表示该对象可以被垂直改变尺寸：123.resize &#123; cursor: row-resize;&#125; 其实，早在CSS2时就已经支持 cursor属性了，不过当时提供的可选值相对较少。对于交互式Web应用来说，鼠标光标样式已经变得越来越重要。因此，CSS3对 cursor属性进行了扩展，并提供了更多的可选值，不同取值的含义、及在windows下的指针效果见表 cursor属性的取值、含义 属性值 含义 auto 浏览器根据当前上下文，自动确定最适合的光标类型 default 使用客户端操作系统的默认光标 none 无光标 context-menu 标示对象是上下文菜单 help 标示有帮助信息存在 pointer 竖起一只手指的手形光标 progress 标示程序忙，但用户仍然可以与程序交互 wait 标示程序忙，用户需要等待直到程序不忙为止 cell 标示对象是单元格 crosshair 简单的十字线光标 text 标示可编辑的水平文本 vertical-text 标示可编辑的垂直文本 alias 标示对象的别名 copy 标示对象可拷贝 move 标示对象可被移动 no-drop 标示被拖起的对象不允许在光标的当前位置被放下 not-allowed 标示请求的操作不允许被执行 grab 标示对象可以被抓取 grabbing 标示对象正在被抓取 e-resize 标示对象可以向东改变尺寸 n-resize 标示对象可以向北改变尺寸 ne-resize 标示对象可以在东北方向改变尺寸 nw-resize 标示对象可以在西北方向改变尺寸 s-resize 标示对象可以向南改变尺寸 se-resize 标示对象可以在东南方向改变尺寸 sw-resize 标示对象可以在西北方向改变尺寸 w-resize 标示对象可以被向西改变尺寸 ew-resize 标示对象可以被水平改变尺寸 ns-resize 标示对象可以被垂直改变尺寸 nesw-resize 标示对象可以在东北和西南方向改变尺寸 nwse-resize 标示对象可以在西北和东南方向改变尺寸 col-resize 标示对象可以被水平改变尺寸 row-resize 标示对象可以被垂直改变尺寸 all-scroll 标示对象允许向四个方向滚动 zoom-in 标示对象可以被放大 zoom-out 标示对象可以被缩小 cursor属性的默认值为 auto， 它表示由浏览器根据当前上下文，自动确定最适合的光标类型。auto 与 default 不同，default 表示使用客户端操作系统默认的光标类型。 从上表可以看出，并非所有的光标类型都得到了支持，对于未支持的类型，则使用默认光标或由浏览器自动确定光标类型。 这显然不能满足所有用户的需求，特别对于一些追求时尚和个性化的Web应用。因此，CSS允许用户创建自己的鼠标光标图片，并保存为 .cur 的光标文件，然后通过 cursor属性来使用它们。如：1cursor: url(cursors/cursor.cur) ; 上述规则表示，要求浏览器加载名称为 cursor.cur 光标文件，并将它用作鼠标光标。当然，浏览器也有可能不支持 .cur 格式的光标文件，或光标文件无法正常加载。因此，大多数浏览器要求必须指定一个备用的光标，否则，cursor属性无效。如：1cursor: url(cursors/cursor.cur), pointer; 使用上述规则，在浏览器不支持 .cur 格式的光标文件，或光标文件无法正常加载时，就会使用 pointer 作为光标。 由于不同浏览器所支持的光标文件格式不尽相同，Opera和IE仅支持 .cur 格式，Firefox、Chrome和Safari既支持 .cur 格式，也支持常见的 .jpg、.gif、.jpg 等格式。因此，CSS还支持同时指定多个光标文件，中间用逗号隔开。如：1cursor: url(cursors/cursor.cur), url(cursors/cursor.png), url(cursors/cursor.gif), pointer; 这样的话，浏览器会逐个查看各个URL，直到找到一个可用的光标文件。如果浏览器无法找到任何可用的文件，就会使用 pointer 作为光标。 元素的定位无论使用哪种定位方案，元素都是相对于其包含块进行定位，包含块是一个元素的布局上下文。绝对定位元素的包含块是最近已定位的祖先元素的内边距边界，非绝对定位元素的包含块是它最近的块级祖先元素（或表格单元格、或行内块祖先元素）的内容边界。 5.1 普通流默认情况下，所有框都在普通流中定位，普通流包括块级框的块格式化、行内级框的行格式化、块级框和行内级框的相对定位。 在普通流中，不同类型的框，会参与不同的格式化上下文（Formatting Context），格式化上下文就是框的布局上下文，它规定了该上下文中的框如何排列，以及这些框之间的关系和相互作用。 普通流中的每个框，只能参与某一种格式化上下文，要么是块格式化上下文，要么是行格式化上下文。块级框参与块格式化上下文，行内级框参与行格式化上下文。 5.1.1 行格式化上下文只有行内级框参与的格式化上下文，称作行格式化上下文（Inline Formatting Contexts，简称IFC），它规定了内部的行内级框如何排列。 在行格式化上下文中，行内级框从包含块的顶部开始，一个接一个地水平排列。在布局时，水平方向的外边距、边框和内边距都有效，并通过水平方向的外边距来调整框之间的水平距离。两个相邻的行内级框之间的水平距离，等于第一个框的 margin-right 与第二个框的 margin-left 之和。 把包含了一行内所有行内级框的矩形区域，称作行框（line box）。行框是本行一个虚拟的框，是浏览器渲染模型中的一个概念，并没有实际显示出来。 通常情况下，行框的宽度等于其包含块内容区的宽度。行框的左外边界，会紧贴其包含块的左内边界，行框的右外边界，会紧贴包含块的右内边界。 假设在一个段落中，包含三个 span 元素：12345&lt;p&gt; &lt;span&gt;inline element 1&lt;/span&gt; &lt;span&gt;inline element 2&lt;/span&gt; &lt;span&gt;inline element 3&lt;/span&gt;&lt;/p&gt; 上述代码中，包含块就是 p 元素的内容边界，行框的边界就是p 元素的内容边界。为了查看效果，为 p 元素定义了内边距和边框，为 span 元素也定义了边框：123456789p &#123; padding: 10px; background: #eee; border: 1px solid #ccc;&#125;span &#123; background: #fff; border: 1px dashed #ccc;&#125; 然而，如果在一行内存在浮动框，浮动框会脱离文档流，并被置于包含块和行框的外边界之间。假设现在让第二个 span 元素向左浮动：123span:nth-child(2) &#123; float: left;&#125; 尽管浮动框是第二个子元素，它仍然会紧贴包含块的左内边界。并且，浮动框脱离文档流后，会使行框的宽度变窄。由此可知，尽管同一行内格式化上下文中的行框是等宽的（等于包含块的宽度），浮动框却会使行框的宽度变窄。 如果一行内的多个行内级框的总宽度超过行框的宽度时，行内框将被分割成多个框，这些框又分布在多个垂直堆叠的行框中。但是，如果行内框的 white-space 属性值为 nowrap 或 pre，则该行内框将溢出到行框的外面。而原子行内级框不允许被分割，它将作为一个整体，被置于具有足够空间的行框中。 如果一个行内框被分割，外边距、边框和内边距，不会在所有分割的地方都产生视觉效果，而是仅出现在行内框的开始处和结尾处。假如有一个段落，其中包含重点强调的文本：1&lt;p&gt;为该段落中的&lt;strong&gt;重点强调的文本&lt;/strong&gt;设置外边距、边框和内边距&lt;/p&gt; 现在，在 strong 元素的左右两侧各添加 1em 的内边距和 1em 的外边距。为了便于观察，为容器 p 添加了 1px的实线边框，为 strong 元素添加了 1px 的虚线边框：1234567891011p &#123; width: 240px; padding: 10px; border: 1px solid #ccc;&#125;strong &#123; margin: 0 1em; padding: 0 1em; background: #eee; border: 1px dashed #444;&#125; 行内框的外边距、边框和内边距，仅仅出现在行框的开始处和结尾处，没有出现在每个分割的地方。 一个行框的高度，总是足以容纳一行内的所有行内级框。也就是说，一个行框的高度，就等于本行内所有行内级框中，高度最大者。 一个行内框的高度，总是等于其 line-height 属性的值，垂直方向的外边距、边框、内边距，都不会增加行内框的高度。 假设在 strong 元素的四个方向，均添加 1em 的内边距和外边距：1234567strong &#123; margin: 1em; padding: 1em; line-height: 1; background: #eee; border: 1px dashed #444;&#125; 垂直方向的外边距、边框、内边距，并没有增加行内框的高度，因为行内框的高度仅仅由它的 line-height 属性决定。 原子行内级框的情况有所不同，它的高度等于margin-box 的高度，也就是说，垂直方向的外边距、边框、内边距，都可以增加原子行内级框的高度。假设为段落中一幅图像应用垂直方向的外边距、边框、内边距：1234567img &#123; margin: 10px; padding: 10px; background: #ccc; vertical-align: middle; border: 1px dashed #444;&#125; 第一行明显比第二行要高，这是因为垂直方向的外边距、边框、内边距，增加了原子行内级框的高度，进而使行框的高度也相应增加。 由于不同的行框所包含的内容可能不同，比如一行仅包含文本，但另一行可能包含图像、表格等。因此，在同一行内格式化上下文中，行框的高度也不尽相同。 在一个行框中，当行内级框 B 的高度小于包含它的行框的高度时，则 B 在行框中垂直对齐的位置，由 B 的 vertical-align 属性决定。 当一行中的行内级框的总宽度，小于包含它们的包含块的宽度时，这些行内级框在行中的水平分布，取决于包含块的 text-align 属性。 5.1.2 块格式化上下文块级框参与的格式化上下文，称作块格式化上下文（Block Formatting Contexts，简称BFC），它规定了内部的块级框如何排列。 块格式化上下文看似抽象，其实比较简单，它实际上就是页面上的一个块级元素，只是在布局上，该元素内部的元素和外部的元素相互独立，互不影响。 通俗的讲，就是在创建了块格式化上下文的元素中，其子元素都会按照块格式化上下文的规则排列自己。以下元素都会自动为其内容创建一个块格式化上下文： 根元素 浮动的元素（float: left | right） 固定定位的元素（position: absolute | fixed） overflow 属性值为 hidden | auto | scroll 的元素 display 属性值为 table | table-caption | table-cell | flex的元素 表格的单元格（td、th） 表格的标题（display: table-captions，caption） 块格式化上下文具有以下特点： 1）在块格式化上下文中，如果只存在块级框，则所有块级框从包含块的顶部开始，一个接一个地垂直排列，每个框被渲染为完整的一行。 假设在 body 下，有一个 class = “wrapper” 的 div 子元素，该子元素又包含三个 div 子元素：12345678910&lt;html&gt;&lt;head&gt;&lt;title&gt;BFC&lt;/title&gt;&lt;body&gt;&lt;div class = \"wrapper\"&gt; &lt;div style = \"height: 40px;\"&gt;&lt;/div&gt; &lt;div style = \"width: 100px; height: 40px;\"&gt;&lt;/div&gt; &lt;div style = \"width: 100px; height: 20px;\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中，html 元素是根元素，body 元素是根元素唯一的子元素，.wrapper 又是 body 的子元素。 为了便于观察，为根元素 html 设置了外边距、内边距和红色边框，为 body 元素设置了内边距和黑色边框，为 .wrapper 子元素设置宽度、内边距和蓝色边框，还为其子元素设置上下外边距和灰色边框：123456789101112131415161718html &#123; margin: 10px; padding: 10px; border: 1px solid red;&#125;body &#123; padding: 20px; border: 1px solid black;&#125;.wrapper &#123; width: 300px; padding: 10px; border: 1px solid blue;&#125;.wrapper div &#123; margin: 10px 0; border: 1px dashed gray;&#125; 由创建BFC的条件可知，根元素默认会创建一个BFC，而 body 和 .wrapper 都不符合创建BFC的条件。因此，body、.wrapper 及 .wrapper 的三个子元素，都将参与根元素创建的块格式化上下文。 前面曾经介绍过，所有元素都是在其包含块中布局。由此可知，body 在初始包含块中布局，.wrapper 在 body 创建的包含块中布局，.wrapper 的三个子元素在 .wrapper 创建的包含块中布局，并从包含块的顶端开始，一个接一个地垂直排列。 块格式化上下文中元素垂直排列 虽然 .wrapper 的第二个和第三个子元素的宽度都是 100px，它们也独占一行。由此可知，在BFC中，每个块级框始终独占一行，即便一行的空间足以容纳多个框也是如此。 2）在同一个块格式化上下文中，相邻两个框之间的垂直距离，由它们的垂直外边距计算得到。当两个垂直外边距相遇时，它们之间的垂直距离，不是第一个框的 margin-bottom 与第二个框的 margin-top 之和，而两者中的较大者。 在CSS中，把这个现象称作外边距合并，即 margin 的合并，意思是说较小的 margin，被合并到了较大的 margin 之中。 相邻元素的垂直外边距合并 外边距合并时，当两个相邻的外边距都是正数时，合并结果是两者中的较大者；都是负数时，合并结果是两者绝对值较大者；一正一负时，合并结果是两者之和。 只要是两个垂直外边距相遇，不管这两个元素之间是父子关系还是兄弟关系，都会发生外边距合并。当一个元素包含在另一个元素中时（假如没有内边距或边框把外边距隔开），它们相邻的外边距也会发生合并。 父元素和子元素的外边距合并 一个元素自身的垂直外边距也可以发生合并，假设有一个空元素，它有上下外边距，但没有边框和内边距。这种情况下，上外边距与下外边距就碰到了一起，它们就会发生合并。 元素自身的垂直外边距合并 外边距合并看上去似乎有点奇怪，但在页面布局中，它却有存在的现实意义。假设有一组块级框，它们都设置了相同上下外边距。如果没有外边距合并，第一个框和最后一个框之外的所有框之间的垂直外边距，都将是相邻上外边距和下外边距之和，这意味着这些框之间的空间将会加倍。如果发生外边距合并，框之间的上外边距和下外边距就合并，所有框之间的垂直距离就会保持一致。 外边距合并使距离一致 只有同一个块格式化上下文中，块级元素的垂直外边距会发生合并，而浮动元素或绝对定位元素属于不同的BFC，它们之间的外边距不会合并。 3）在块格式化上下文中，每个块级框的左外边界，都紧贴包含块的左内边界（对于从右往左的格式化，则为框的右外侧紧贴包含块右侧），即便存在浮动也是如此，除非这个块级框创建了一个新的BFC。 假设在一个容器中，有一个 div 子元素和一个段落子元素：1234&lt;div class = \"wrapper\"&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;在BFC中，每个框的左外边界紧贴…除非框创建了一个新的BFC。&lt;/p&gt;&lt;/div&gt; 为了方便查看容器中内容的对齐情况，为容器设置宽度、内边距和边框，并让div 向左浮动，为两个子元素设置不同的背景颜色：123456789101112131415.wrapper &#123; width: 300px; padding: 10px; border: 1px solid #ccc;&#125;.wrapper div &#123; float: left; width: 60px; height: 60px; background: #f90;&#125;p &#123; color: #fff; background: #2595e5;&#125; 内部的框左对齐 浮动框和非浮动框的左外边界，都紧贴包含块的左内边界。其实，这也容易理解，因为浮动框已经脱离文档流，它的块级兄弟元素，会无视浮动框的存在，尽量占满一整行，导致被浮动框覆盖。 正如上 所示，这里的 p 元素仍然紧贴包含块的左内边界，导致段落被浮动框覆盖，而 p 元素中的文本所形成的行框却向右移动，并水平变窄来给浮动元素腾出空间。随着文本的增加，后面的文本又会紧贴包含块的左内边界，因为它不再受浮动框的影响，便无需再向右移动了。 有时候，可以利用这个特性来创建文本环绕的效果，但有时候，这种情况并非所愿。如果设置段落的左外边距，使 p 元素为浮动元素腾出空间，就不会被浮动元素覆盖。 不过，如果让段落创建一个新的BFC，也不会被浮动框覆盖（但是，p 元素所生成的框，会受浮动框影响而变窄）。如：12345p &#123; color: #fff; overflow: hidden; background: #2595e5;&#125; 消除浮动元素的影响 这里使用 overflow 属性来创建BFC，使 p 元素向右移动并水平变窄，来给浮动元素腾出空间，以便不被浮动元素覆盖。当然，在实际应用中，可以根据实际情况，选择任意合适的属性来创建BFC。 4）计算块格式化上下文的高度时，浮动元素也参与计算，也就是说，创建了BFC的元素，会根据子元素情况自动适应高度，可以让一个元素包含浮动元素。在 5.3.2 节将详细介绍如何利用这个规则来间接实现清理浮动的效果，这里不再赘述。 前面已经介绍，只有块级框会参与块格式化上下文，那么，当一个块格式化上下文中既有块级框，又有行内级框时，该如何布局呢？考虑以下HTML代码片段：12345678&lt;body&gt;&lt;div class = &quot;wrapper&quot;&gt; some text &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span1&lt;/span&gt; &lt;span&gt;span2&lt;/span&gt;&lt;/div&gt;&lt;/body&gt; 为了方便查看每一行的效果，为 div 和 span 设置边框，为 div 设置上下外边距：1234567.wrapper div,.wrapper span &#123; border: 1px dashed #ccc;&#125;.wrapper div &#123; margin: 10px 0&#125; 块格式化上下文中包含块级元素和行内元素 块级框中的文本“some text”生成一个匿名块级框直接参与BFC，div 元素生成一个块级框直接参与BFC，而 span1 和 span2 元素生成的行框（相当于一个匿名块级框）再参与BFC。 综上所述，普通流中页面布局基本的规则为：首先，为根元素创建一个BFC，所有子元素参与到该BFC中。然后，任何子元素都可以根据需要创建新的BFC，它的所有子元素再参与到该BFC中。这样，通过BFC的层层嵌套，就可以构建出千变万化的布局效果。 5.2 定位在CSS中，通过 position属性来对元素进行定位，可选的定位类型有 static | relative | absolute | fixed，默认值为 static，表示没有定位，元素保持在它原本应该在的位置上。 要对页面元素使用定位技术，必须 position属性设置为 static 之外的其它 3 个属性值，即相对定位、绝对定位、固定定位。 5.2.1 相对定位当一个元素的 position属性设置为 relative，它将使用相对定位。相对定位的元素在普通流中进行定位，它将出现在文档流中原本的位置。然而，可以通过设置水平或垂直偏移量，使它相对于原本的位置，偏移指定的距离，移动到新的位置。如果没有设置偏移，或设置的偏移量为 0，那么它仍将保持在原来的位置。 相对定位的元素，通过 left、right 属性来定义水平偏移量，top、bottom 属性来定义垂直偏移量。left 表示相对于原本位置的左外边界右移的距离，right 表示相对于原本位置的右外边界左移的距离，top 表示相对于原本位置的上外边界下移的距离，bottom 表示相对于原本位置的下外边界上移的距离。并且，偏移量可以是正值，也可以是负值，负值表示向相反的方向移动。 left、right、top、bottom 这 4 个属性的值，可以是长度值（可以是绝对单位或相对单位），也可以是百分比。使用百分比时，水平偏移量根据其父元素 width 属性的值计算得到，垂直偏移量根据其父元素 height 属性的值计算得到。需要注意的是，在设置偏移时，如果父元素没有显式定义 height 属性，就等同于 height 属性的值为 0。 接下来通过一个实例，来理解相对定位的原理和效果。假设页面上有一个容器 wraper，其中包含三个子元素：12345&lt;div id = \"wraper\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 假设这些子元素都水平排列，并具有 10px 的外边距。为了方便查看，为容器和子元素分别添加了边框。CSS代码如下：1234567891011121314#wraper &#123; width: 366px; overflow: hidden; /* 防止父元素高度塌陷 */ box-sizing: border-box; border: 2px dashed #ccc;&#125;#wraper &gt; div &#123; float: left; /* 让元素水平排列 */ margin: 10px; width: 100px; height: 80px; border: 1px solid #ccc; box-sizing: border-box;&#125; 未使用相对定位前，三个子元素依次水平排列，并各自占据自身在文档流中原本的位置 第二个元素的左右两侧均有 20px 的水平外边距。现在对第二个元素使用相对定位，把它的 top 属性设置为 20px， left 属性设置为 30px：12345#wraper div:nth-child(2) &#123; top: 20px; left: 30px; position: relative;&#125; 从前面的介绍可知，如果将 top 设置为 20px，框就会相对于原本位置的上边界下移20px。如果left 设置为 30px，那么框就会相对于原本位置的左边界右移30px。虚线框表示第二个元素原本的位置（当然，这个虚线框是人为加上去的），它相对原本位置右移 30px，下移 20px。可以看出，右移 30px 后，它已经覆盖到第三个元素。并且，在下移 20px后，它已经移到父元素的外面，即便如此，父元素的尺寸依然不变，也不会因此而被撑大。 由此可知，相对定位的元素，无论设置偏移，它仍然占据文档中的原有位置。设置偏移之后，只是在视觉上相对于原有的位置移动了而已，并且对父元素和兄弟元素的布局都没有任何影响，但可能会覆盖其他元素。 5.2.2 绝对定位当一个元素的 position属性设置为 absolute 或 fixed，它将使用绝对定位。绝对定位的元素将从文档流中完全删除，它原先在正常文档流中所占的空间会关闭，就好像该元素不存在一样，因此不会在原先的位置留下空白。 绝对定位的元素相对它的包含块进行定位。position: absolute 元素的包含块是最近已定位（position属性被设置，且不是static）的祖先元素，如果没有已定位的祖先元素，则为初始包含块（即 html 元素），也就是视口。position: fixed 元素的包含块是初始化包含块。当页面出现滚动条时，无论如何滚动，position: fixed 的元素始终处于固定的位置，不会随着页面滚动。因此，position: fixed 的定位被称作固定定位。不过，IE6及以下版本不支持固定定位。 绝对定位元素中，top、bottom、left、right 属性的含义，与相对定位元素完全不同，需要特别注意。绝对定位元素的 top、bottom、left、right 属性，表示元素自身相应的外边界，与包含块对应的内边距边界（注意：不是内容边界）的距离，而不是偏移量。 如果一个 absolute 元素没有显式定义宽度，则它的宽度就由 left 和 right 属性决定。如果将 left 和 right 同时设置为 0，它的宽度就等于包含块的宽度；如果将 left 或 right 设置为正值，就会将它向包含块的内部压缩，宽度随之减少 left 或 right 属性指定的宽度；如果将 left 或 right 设置为负值，就会将它向包含块的外部拉伸，并延伸到包含块的外部，宽度随之增加 left 或 right 属性指定的宽度。同理，如果没有显式定义高度，就可以设置 top 和 bottom 让它垂直拉伸。因此，如果同时设置 left: 0; right: 0; top: 0; bottom: 0;，就可以让它与包含块具有相同的尺寸。 还看上一节的例子，如果希望第二个元素在容器 wraper 中使用绝对定位，首先让它的父元素成为已定位的元素，并让第二个元素使用绝对定位。123456789#wraper &#123; position: relative; …&#125;#wraper div:nth-child(2) &#123; top: 20px; left: 20px; position: absolute;&#125; 对于任何元素来说，它的左边界是 margin 区域的左边缘，上边界是 margin 区域的上边缘。本例中，由于第二个子元素有 10px 的外边距，故发生偏移后，它的左边框与 wrapper 元素左边框的距离是 30px，而上边框与 wrapper 元素上边框的距离也是 30px。上边界和上边框同理。 如果设置了绝对定位，而没有设置偏移属性，那么它仍将保持在原来的位置。这个性质可以用于需要使某个元素脱离普通流，而仍然希望它保持在原来的位置的情况。由于绝对定位的元素将脱离文档流，这意味着它对其后的兄弟元素没有影响。 无论一个元素在普通流中是块级框，还是行内级框，使用绝对定位后，它都会生成一个块级框。由于绝对定位的元素创建了一个独立的块格式化上下文，因此，尽管绝对定位的元素也可以有外边距，但它不会与其它任何元素发生外边距合并。 5.2.3 z-index默认情况下，网页是一个二维空间，并根据在DOM中的顺序，从左到右，从上到下，依次排列各个元素。 当页面上出现相对定位、或绝对定位、或固定定位的元素后，如果对一个元素设置了偏移，就很可能出现元素相互重叠的情况。如果把页面作为 x-y 轴，垂直于页面的方向就是 z 轴，重叠的情况就发生在 z 轴。 元素在 z轴 的位置，取决于它在DOM中的先后顺序。如果两个元素发生重叠，在DOM中先出现的元素，通常排在后出现元素的下面，被后出现元素的覆盖。出现这种情况后，可以通过 z-index 属性来调整元素在 z 轴方向上的堆叠顺序。 z-index 属性的值为整数，可以为正数，也可以为负数，默认值为 0。在 z 轴方向上，定位元素就会按各自 z-index 属性的值，从小到大依次排列。z-index 属性的值越大，元素离用户越近。 z-index 属性的值可以不必连续，换句话说，10、20、30 与 1、2、3 的作用相同。把数值拉开一些，更便于以后把更多的元素插入到堆叠中。如果两个元素的z-index 属性值相同，则保持原有的堆叠关系。如果确保定位元素的上层不会出现任何内容，就可以给它设置一个相当大的 z-index 值。 需要注意的是，z-index 属性只对绝对定位、相对定位或固定定位的元素有效，对静态定位的元素无效。 5.3 浮动5.3.1 浮动CSS中，通过 float属性，任何元素都可以浮动，取值 left 让一个元素向左浮动，取值 right 则向右浮动。 浮动会影响包含块中的布局，如果一个包含块中存在浮动框，则先让所有的框按照普通流中的位置摆放，再将浮动框从文档流中取出来，并让浮动框从包含块的顶部开始，根据浮动方向一个接一个地水平排列。 浮动元素的包含块，是它最近的块级祖先元素（或表格单元格、或行内块祖先元素）的内容边界。向左浮动的元素，尽可能向左移动，直到碰到包含块的左边界。向右浮动的元素，尽可能向右移动，直到碰到包含块的右边界。 假设在一个容器中，有两个子元素，一个向左浮动，一个向右浮动：1234&lt;div class = \"wrapper\"&gt; &lt;div class = \"floatL\"&gt;box1 &lt;/div&gt; &lt;div class = \"floatR\"&gt;box2 &lt;/div&gt;&lt;/div&gt; 现在，为容器设置 10px 的内边距，为了便于观察，为容器和子元素设置了边框，并为向左和向右浮动元素添加指示箭头：12345678910111213141516171819.wrapper &#123; width: 320px; padding: 10px; overflow: hidden; border: 2px dashed #ccc;&#125;.wrapper div &#123; width: 80px; height: 60px; border: 1px dashed #444;&#125;.floatL &#123; float: left; background: url(img/fl.png) 50% 36% no-repeat;&#125;.floatR &#123; float: right; background: url(img/fr.png) 50% 36% no-repeat;&#125; 框可以向左或向右浮动无论向左浮动，还是向右浮动，浮动元素左右边界，都不会超过包含块内容区的左右边界。并且，浮动元素的上边界，也不会超过包含块内容区的上边界。 一个浮动元素，无论它是块级元素，还是行内级元素，都会生成一个块级框，并可以为它指定宽度和高度。如果没有显式设置宽度和高度，它的宽度和高度由其内容决定，但不超过包含块的宽度和高度。 假设在一个段落中，有两个 span 子元素，一个向左浮动，一个向右浮动。向左浮动的元素设置了宽度和高度，而向右浮动的元素没有设置宽度和高度：1234&lt;p&gt; &lt;span class = &quot;floatL&quot;&gt;float left&lt;/span&gt; &lt;span class = &quot;floatR&quot;&gt;float right&lt;/span&gt;&lt;/p&gt; 1234567891011121314p &#123; border: 1px solid #ccc;&#125;span &#123; border: 1px dashed #ccc;&#125;.floatL &#123; float: left; width: 200px; height: 40px;&#125;.floatR &#123; float: right;&#125; 浮动元素的宽度和高度未设置宽度和高度的元素，其尺寸由其内容决定，而设置宽度和高度元素则使用设置的尺寸。由于包含块的高度为 auto，其高度被向左浮动的元素撑开。 虽然浮动元素生成的也是块级框，但跟块级元素生成的块级框不同的是，浮动框的旁边允许放置其他的框。也就是说，浮动框可以跟块级框、或行内级框、或浮动框在同一行内水平显示。 由于浮动框已经脱离文档流，当浮动框和块级框并列时，同一行中的块级框会无视浮动框的存在，并占满一整行。这种情况下，块级框会处在浮动框的下层，也无法通过 z-index 属性改变它们的堆叠顺序。但是，块级框中的文本会环绕着浮动框，不会被浮动框覆盖，其效果跟印刷排版中的文本环绕相似。 假设有一个容器中，有一幅图像和一个段落，图像向左浮动。为了便于观察，为段落添加背景：1234&lt;div&gt; &lt;img src = \"img/img.gif\" style = \"float:left;\" /&gt; &lt;p&gt;无论是块级元素，…，浮动元素的旁边允许放置其他元素。&lt;/p&gt;&lt;/div&gt; 123456789101112div &#123; width: 300px; border: 1px dashed #ccc;&#125;p &#123; font-size: 13px; line-height: 2; background: #ddd;&#125;img &#123; float: left; &#125; 浮动框与块级框并列图像会生成一个浮动框，并且，浮动框和段落都紧贴包含块的左内边界，导致段落被浮动框覆盖，而段落中的文本所形成的行框却向右移动，并水平变窄来给浮动框腾出空间。随着文本的增加，后面的文本又会紧贴包含块的左内边界，因为它不再受浮动框的影响，无需再向右移动了。 如果浮动框和行内级框并列，浮动框将被置于包含块和行框的外边界之间，使行框的水平可用空间减少，导致行框的宽度变窄。 假设在一个段落中，有四个 span 子元素，一个向左浮动，一个向右浮动，其余两种不进行浮动：123456&lt;p&gt; &lt;span&gt;inline element 1&lt;/span&gt; &lt;span class = &quot;floatL&quot;&gt;float left&lt;/span&gt; &lt;span class = &quot;floatR&quot;&gt;float right&lt;/span&gt; &lt;span&gt;inline element 2&lt;/span&gt;&lt;/p&gt; 为了便于观察，为 span 元素添加了 1px 的虚线边框：123456789101112p &#123; border: 1px solid #ccc;&#125;span &#123; border: 1px dashed #ccc;&#125;.floatL &#123; float: left;&#125;.floatR &#123; float: right;&#125; 浮动框与行内级框并列 由于浮动框的存在，行框的宽度变窄，当行框的水平空间不足时，行内级框会自动换行。由于受浮动框高度的影响，行内级框被浮动框卡住。 如果多个浮动框并列时，它们会按在HTML中的定义顺序，一个接一个，依次水平排列，每个框按照各自的方向浮动。 假设所有的三个框都向左浮动，则框 1 向左浮动，直到碰到包含块内容区域的边界，另外两个框向左浮动，直到碰到前一个浮动框。 假设所有的三个框都向右浮动，情况与全部向左浮动类似。在HTML代码中，框 1 最先被定义，所以排在最右边，框 3 最后被定义，所以排在最左边。 如果在一行内无法容纳所有的浮动框，则后面的框会向下移动，直到有足够的空间。如果浮动框的高度不同，在向下移动时，可能被其它浮动框“卡住”。浮动框下移到有足够空间的地方 如果多个框的浮动方向不尽相同，情况会怎样呢？假设有六个浮动框，按从小到大的顺序依次定义，框 1、2、5向左浮动，框 3、4、6向右浮动。不同方向浮动的框 当框的浮动方向不尽相同时，会按照在HTML中定义的顺序，摆放每一个框，如果一行内空间不足，后面的框会自动下移，形成多行，在每一行中，每个框按照各自的方向浮动。 5.3.2 清除浮动虽然浮动可以便于页面布局，但同时会产生一些问题，也就是常说的副作用。浮动元素最常见的缺陷是：父元素的高度塌陷和影响兄弟元素的位置。 首先，看看父元素的高度塌陷。假设有一个容器，其中两个子元素，一个子元素向左浮动，一个子元素向右浮动。代码如下：1234567891011121314.wrapper &#123; border: 2px dashed #ccc;&#125;.wrapper &gt; div &#123; width: 80px; height: 60px; border: 1px dashed #444;&#125;.floatL &#123; float: left;&#125;.floatR &#123; float: right;&#125; 1234&lt;div class = \"wrapper\"&gt;&lt;div class = \"floatL\"&gt;box1 &lt;/div&gt;&lt;div class = \"floatR\"&gt;box2 &lt;/div&gt;&lt;/div&gt; 上述容器 wrapper 的高度为auto，且只包含浮动元素。由于浮动元素脱离了文档流，因此，容器 wrapper 就相当于一个空标签，其高度就会塌陷为零，使得浮动元素溢出到容器外面。 这种塌陷会影响、甚至破坏布局，如果父元素没有边框，也不包含任何可见背景，这个问题就很难被注意到，但它却是一个很重要的问题。 再来看看浮动元素如何影响兄弟元素的位置。当容器的高度为 auto，且只包含浮动元素时，如果浮动元素的高度不相同，而剩余空间足够容纳后面的元素时，后面的元素就会上跳到剩余的空间。代码如下：123456789101112.wrapper &#123; border: 2px dashed #ccc;&#125;main &#123; float: left;&#125;aside &#123; float: right;&#125;footer &#123; float: left;&#125; 12345&lt;div class = &quot;wraper&quot;&gt;&lt;main&gt;main&lt;/main&gt;&lt;aside&gt;aside&lt;/aside&gt;&lt;footer&gt;footer&lt;/footer&gt;&lt;/div&gt; 上述的布局为两栏布局，主栏向左浮动，侧栏向右浮动，并且侧栏的高度小于主栏的高度。页脚便会上跳到侧栏的剩余空间。 很显然，无论是高度塌陷，还是影响兄弟元素的位置，都不是使用浮动的目的。浮动只是为了改变元素的布局，却造成了不必要的影响。因此，需要清除浮动带来的影响。 CSS中，把清除浮动影响所进行的处理，叫做清理浮动（或清除浮动）。一般有两种处理思路：使用 clear属性和让容器创建一个BFC。 每种思路中都包含多种方法，但并不是每一种方法都尽善尽美，接下来简单介绍这些方法的原理及适用场合，可以根据实际情况，选择合适的方法。 使用 clear属性CSS中的 clear属性，用来规定在元素的哪一侧不允许出现浮动元素，可选值有 none | left | right | both，默认值为 none，表示不清除，左右两侧均允许出现浮动元素。left 表示清除左侧，在左侧不允许出现浮动元素；right 表示清除右侧，在右侧不允许出现浮动元素；both 表示清除两侧，左右两侧均不允许出现浮动元素。 1）使用带clear属性的空元素 这也是W3C推荐使用的方法，首先在CSS中定义一个清理的 class，然后在浮动元素的后面，使用一个空元素 &lt;div class = &quot;clear&quot;&gt;&lt;/div&gt; 或 &lt;br class = &quot;clear&quot; /&gt;。如：123.clear &#123; clear: both;&#125; 12345&lt;div class = \"wraper\"&gt;&lt;div class = \"floatL\"&gt;box1 &lt;/div&gt;&lt;div class = \"floatR\"&gt;box2 &lt;/div&gt;&lt;br class = \"clear\" /&gt;&lt;/div&gt; 这种方法的优点是简单、代码少、浏览器兼容性好。但是，需要添加无语义的html元素，违背了表现和内容相分离的原则，代码不够优雅，增加了后期维护的难度。 2）借用邻接元素处理 什么都不做，给浮动元素后面的那个元素添加 clear属性。假如在浮动元素后面有一个 p 元素，可以为 p 元素添加 clear属性，来间接清除浮动。如：12345&lt;div class = \"wraper\"&gt;&lt;div class = \"floatL\"&gt;box1 &lt;/div&gt;&lt;div class = \"floatR\"&gt;box2 &lt;/div&gt;&lt;p class = \"clear\"&gt;&lt;/p&gt;&lt;/div&gt; 如果你很明确的知道接下来的元素是什么，这个方法很不错，它不需要 hack，不添加额外的元素。但是，使用这种方法，必须确保浮动元素后面确实有元素。如果没有元素，巧妇难为无米之炊，也没有办法。 3）使用CSS的 :after 伪元素 结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和触发布局的 IE hack，可以完美兼容当前各大主流浏览器。 给包含浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个 :after 伪元素，在元素末尾添加一个看不见的块元素，让这个块元素来清除浮动。1234567.clearfix:after &#123; content: \".\"; clear: both; display: block; height: 0; visibility: hidden;&#125; 1234&lt;div class = \"wrapper clearfix\"&gt;&lt;div class = \"floatL\"&gt;box1 &lt;/div&gt;&lt;div class = \"floatR\"&gt;box2 &lt;/div&gt;&lt;/div&gt; 通过CSS伪元素，在容器的末尾，插入一个点 “.”，然后通过 height 和 visbility 属性使其不可见，再为插入的点设置 clear属性来清除浮动，其原理跟上述两种方法类似。 事实上，上述方法插入任何内容，都可以清除浮动。当然，如果插入一个空格的话，就不必设置 height 和 visbility 属性，代码会跟简洁。如：12345.clearfix:after &#123; content: \"\"; clear: both; display: block;&#125; 需要注意的是，由于IE7及以下的版本不支持 :after 伪元素，因此还需要为 .clearfix 设置width、或 height、或 zoom 等一系列属性，来触发布局（即，使IE私有属性 hasLayout 的值为 true）。如：123.clearfix &#123; *zoom: 1;&#125; 在这些属性值中，zoom 用于设置元素的缩放比例，取值 1 就会使用元素的实际尺寸。因此，使用 zoom: 1 既可以触发布局，又不会对元素造成其他影响，相对而言比较安全。 让容器创建BFC可以利用BFC特性，来清除浮动。准确的讲，说清除浮动不太合适，应该说是让容器创建一个BFC，来包含浮动元素。可以为容器设置以下属性，来创建一个新的BFC，间接实现清除浮动的效果： float: left | right position: absolute | fixed overflow: hidden | auto | scroll display: inline-block | table-cell | table | flex | inline-flex 虽然设置上述属性都可以创建BFC，实现清除浮动的效果，但是，float、position、display 属性可能会影响整体布局。因此，最常用的还是设置 overflow 属性。 1）让容器浮动 让容器浮动后，容器就会创建一个新的BFC，使它可以包含浮动元素。计算BFC的高度时，浮动子元素也参与计算。因此，容器的高度就表现正常，其他框的位置也就正常了。1234.wrapper &#123; float: left; border: 2px dashed #ccc;&#125; 让容器浮动后，容器的高度确实没有塌陷，但是，容器的宽度可能会发生变化，因为浮动元素的宽度是有其内容决定的（显式设置 width 属性者除外），这可能会影响整体布局。 2）为容器添加 position 属性 如果为容器设置 position: absolute 或 position: fixed，容器就会创建一个新的BFC，使它可以包含浮动元素。1234.wrapper &#123; position: absolute; border: 2px dashed #ccc;&#125; 另外，由于IE7及以下的版本不支持BFC，还需要触发布局。设置 position: absolute，IE6和IE7都可以触发布局。但是，IE6不支持 position: fixed，还需要为容器设置 zoom: 1，来触发布局。 3）为容器添加 overflow 属性 如果为容器设置 overflow: hidden 或 overflow: auto，容器就会创建一个新的BFC，使它可以包含浮动元素。1234.wrapper &#123; overflow: hidden; border: 2px dashed #ccc;&#125; 另外，由于IE7及以下的版本不支持BFC，还需要触发布局。在IE7中，把 overflow属性设置为 visible 之外的值，就可以触发布局，IE6则不行。因此，在IE6中，可以为容器设置 zoom: 1，来触发布局。 这个方法不需要额外元素，有着较好的语义性，也比较简单。但是，需要要记住，overflow 属性不是为清除浮动而定义的，注意不要隐藏了不该隐藏的内容或触发了不必要的滚动条。 说明：BFC 与 hasLayout从表现上来说，hasLayout 跟 BFC 的功能很相似，只是 hasLayout 自身存在很多问题，导致了 IE6-7 中的一系列 bug。既然 hasLayout 有着跟 BFC 相似的功能，而 IE7 及以下的版本不支持 BFC。因此，为了避免不同浏览器下的表现差异，在实际开发中，需要创建 BFC 的元素，同时也要触发 hasLayout。事实上，在实际开发中，很多莫名其妙的问题，都是由此产生的。当然同样地，如果一个元素没有创建 BFC，也要尽量保证它没有触发 hasLayout 。 链接和导航导航是任何网站不可或缺的功能，它能够为用户提供全面的引导，让用户快速进入相关频道，从而找到相关的内容。导航的风格往往也决定了一个网站的风格，因此网站设计师会投入很大的精力，来制作各式各样的导航。 链接是导航的主角，而制作导航也是列表最重要的应用之一，最常见的导航包括面包屑导航、分页导航、垂直导航、手风琴导航、主导航、下拉导航等。本章将为每一类导航，提供一个实例，来介绍其基本制作方法，掌握基本方法后，通过变幻样式，就可以轻松制作不同风格的导航。 6.1 链接的样式6.1.1 动态超链接在HTML中，通过 a 元素来定义超链接，并通过 a 元素的 href 属性来定义链接的目标地址。1&lt;a href = \"http://www.baidu.com\"&gt;百度&lt;/a&gt; 默认情况下，超链接是蓝色字体并带有下划线，被访问后，链接文本会变为紫色并且也带有下划线。并且，默认的链接样式平淡无奇，通过CSS，可以设置超链接的各种属性，如字体、颜色、背景等，并结合链接伪类，便可以实现各种各样的动态链接效果。 对链接应用样式最容易，也是最简单的方式，就是使用元素选择器。如，以下规则是所有的锚文本都显示为红色，并去掉链接的下划线。1234a &#123; color: red; text-decoration: none;&#125; 但是，这样定义链接之后，页面上的所有链接都变成了红色，也无法区分哪些链接是已经访问过的，哪些是没有被访问过的。 为了避免这个问题，CSS提供了链接伪类选择器，用来寻找处于不同状态的链接。:link伪类选择器寻找未被访问过的链接，:visitd 伪类选择器寻找已被访问过的链接。所以，下面代码中，所有没有被访问过的链接将是红色，所有被访问过的路径将是紫色。123456a:link &#123; color: blue;&#125;a:visited &#123; color: purple;&#125; 这时，就可以为链接应用 :hover 和 :active 这两个动态伪类选择器。:hover寻找鼠标悬停的元素，:active 寻找被激活的元素，对于链接，激活发生在鼠标已经按下、还没有释放的时候。123a:hover, a:active &#123; color: red;&#125; 另外，动态伪类选择器也可以连在一起使用，以创造更丰富的样式，如定义已被访问链接的悬停效果。123a:visited:hover &#123; color: #888;&#125; 为了尽可能提高页面的可访问性，在定义鼠标悬停状态时，最好为链接定义 :focus 伪类选择器，以便用户通过键盘移动到链接上时，链接的样式与鼠标悬停时的样式相同。:focus 伪类选择器，会寻找获得焦点的元素。123a:hover, a:focus, a:active &#123; color: red;&#125; 默认情况下，浏览器会为链接添加下划线，而人们常常习惯于去掉未访问和已访问链接的下划线，当悬停、获得焦点、激活时，再为链接添加下划线。123456a:link, a:visited &#123; text-decoration: none;&#125;a:hover, a:focus, a:active &#123; text-decoration: underline;&#125; 定义链接样式时，选择器的顺序非常重要，如果上面的顺序反过来，悬停和激活的样式就不起作用了。根据样式层叠规则，当两个规则具有相同的特殊性时，后定义的规则会覆盖先定义的规则，所以，a:link 和 a:visited 样式将覆盖 a:hover，a:focus，a:active 样式。 于是，为了确保不会发生这种情况，一定要按照 LVFHA 的顺序定义链接的样式，即按照link（L）、visited（V）、focus（F）、hover（H）、active（A）的书写顺序。也有人提议使用LVHFA 的顺序，这也是可行的。 6.1.2 按钮式链接在任何浏览器下，默认的链接都太过平淡，不能满足大多数人的需求。尤其是希望有特大点击区域的链接，比如制作主导航链接、手风琴菜单、按钮等链接时，默认的链接更是无能为力，而按钮式链接便可担此重任。 链接默认是行内元素，只能通过链接文本来激活链接。要想让链接像按钮一样，较大的点击区域，其实很简单。只需为链接添加合适的内边距，并设置类似按钮的背景和边框即可。123456789a &#123; padding: 10px 18px; color: #fff; font-size: 14px; font-weight: bold; border-radius: 4px; background: #f74c4c; text-decoration: none;&#125; 为了提高页面的可访问性，跟普通超链接一样，也要为按钮式链接定义其他两个状态下的样式，一个是鼠标悬停和获取焦点的状态，一个是激活状态。123456a:hover, a:focus &#123; background: #f14b00;&#125;a:active &#123; background: #f1004b;&#125; 对于简单的按钮，修改背景颜色就很合适，但对于比较复杂的按钮，可能需要使用背景图像。一般需要 3 个图像，一个用于默认状态，一个用于鼠标悬停和获取焦点的状态，一个用于激活状态。然后，为不同的状态应用不同的背景，就可以让不同状态下的链接，具有不同的风格。 6.2 列表的样式在CSS中，列表元素是一个块框，列表中的每个表项也是一个块框，只是在表项前面多了一个项目符号。列表的格式化，主要由浏览器完成，而不是由设计人员完成。设计人员只能通过 list-style属性来定义列表的样式。 list-style属性只对 display 属性值为 list-item 的对象有效，对其它类型对象无效。list-style属性的语法格式为：1list-style：[ list-style-type ] || [ list-style-position ] || [ list-style-image ] 也就是说，list-style属性可以分解为 list-style-type、list-style-position和list-style-image 这3个独立的属性，下面分别进行介绍。 list-style-typelist-style-type属性用来定义列表所使用的项目符号的类型，可选值有 none | disc | circle | square | decimal | decimal-leading-zero | lower-alpha | upper-alpha | lower-roman | upper-roman，默认值为 disc。常用属性值及效果说明见表 属性值 效果说明 none 不使用任何项目符号 disc 默认值，实心圆 circle 空心圆 square 实心矩形 decimal 数字1、2、3、4、5 decimal-leading-zero 以0打头的数字，01、02、03、04、05 lower-alpha 小写英文字母，a、b、c、d、e upper-alpha 大写英文字母，A、B、C、D、E lower-roman 小写罗马数字，ⅰ、ⅱ、ⅲ、ⅳ、ⅴ upper-roman 大写罗马数字，Ⅰ、Ⅱ、Ⅲ、Ⅳ、Ⅴ 如果一个元素的 list-style-image属性的值设置为 none，或者 list-style-image属性指定的图像无法正常时，则由 list-style-type属性来决定 list-item 元素的外观。 由于CSS无法区别一个列表是有序列表，还是无序列表，因此，不管是有序列表还是无序列表，都是使用 list-style-type属性来定义列表项符号。只要你愿意，完全可以让一个有序列表使用实心圆，而非数字作为项目符号。如果项目符号设置为数字或字母，这些数字或字母由浏览器自动计算。 如果为 ul 或 ol 元素定义 list-style-type属性，则其内部的所有 li 子元素都使用相同的项目符号。当然，也可以为 li 元素单独设置 list-style-type属性，让其只对该 li 元素有效。123456789101112131415.disc &#123; list-style-type: disc;&#125;.circle &#123; list-style-type: circle;&#125;.decimal-leading-zero &#123; list-style-type: decimal-leading-zero;&#125;.lower-alpha &#123; list-style-type: lower-alpha;&#125;.upper-roman &#123; list-style-type: upper-roman;&#125; 上述代码定义了 5 个类，每个类定义了不同的列表项目符号类型，把这 5 个类分别应用于同一个 ul 元素下的不同 li 元素。1234567&lt;ul&gt; &lt;li class=\"disc\"&gt;disc：默认值，实心圆&lt;/li&gt; &lt;li class=\"circle\"&gt;circle：空心圆&lt;/li&gt; &lt;li class=\"decimal-leading-zero\"&gt;decimal-leading-zero：以0打头的数字 01、02&lt;/li&gt; &lt;li class=\"lower-alpha\"&gt;lower-alpha：小写英文字母a、b、c、d、e&lt;/li&gt; &lt;li class=\"upper-roman\"&gt;upper-roman：大写罗马数字Ⅰ、Ⅱ、Ⅲ、Ⅳ、Ⅴ&lt;/li&gt;&lt;/ul&gt; 把上述 5 个类分别应用于同一个 ul 元素下的不同 li 元素后，不同的 li 元素具有不同的项目符号。 如果想禁止显示项目符号，就可以把 list-style-type属性值设置为 none，none 会导致浏览器在原本放置项目符号的位置不显示任何内容，不过，它不会中断有序列表的计数。如，有以下有序列表元素：12345&lt;ol&gt; &lt;li&gt;List Item 1&lt;/li&gt; &lt;li style = &quot;list-style-type: none;&quot;&gt;List Item 2&lt;/li&gt; &lt;li&gt;List Item 3&lt;/li&gt;&lt;/ol&gt; 由于 list-style-type属性具有继承性，所以，如果希望嵌套列表中使用不同的项目符号，可能需要在内层列表中单独定义。 list-style-positionlist-style-position属性设置列表项目符号的位置及列表项的对齐方式，取值 outside | inside，默认值为 outside。 outside 表示列表项目符号放置在内容以外，列表项以内容为准对齐；inside 表示列表项目符号放置在内容以内，列表项以项目符号为准对齐。如：1234567891011ul &#123; padding: 0; border: 1px solid #444; list-style-type: square;&#125;.outside &#123; list-style-position: outside;&#125;.inside &#123; list-style-position: inside;&#125; 12345678&lt;ul class = \"outside\"&gt; &lt;li&gt;outside的列表，列表项以内容为准对齐&lt;/li&gt; &lt;li&gt;outside的列表，列表项以内容为准对齐&lt;/li&gt;&lt;/ul&gt;&lt;ul class = \"inside\"&gt; &lt;li&gt;inside的列表，列表项以标记为准对齐&lt;/li&gt; &lt;li&gt;inside的列表，列表项以标记为准对齐&lt;/li&gt;&lt;/ul&gt; 上述代码中，第一个列表采用 outside 列表项标记，第二个列表采用 inside 列表项标记。 如果列表项的内容为多行，在内容发生换行后，outside 的列表项是以内容为准对齐，而 inside 的列表项则以项目符号为准对齐。 outside 列表的项目符号不但出现在列表项的内容之外，也出现在列表元素的内容之外，这是因为项目符号实际上并不是列表内容区的一部分，它不占据容器的空间。所以，在列表元素的 margin 或 padding 为 0 时，项目符号就有可能覆盖其它元素或被其它元素覆盖。如果发现列表的项目符号显示不出来，这可能是原因之一。 list-style-image浏览器提供的列表项目符号，不能满足所有人的需要，并且可选择的范围有限。因此，可以通过 list-style-image属性定义一幅图像，来取代默认的列表项目符号。语法格式为：1list-style-image: none | url() 默认值为none，表示使用 list-style-type属性指定的列表项目符号；url()表示使用 url 指定的图像来取代默认的列表项目符号，如果图像无效，则 list-style-type属性会生效。如：123ul &#123; list-style-image: url(img/square.png);&#125; 12345&lt;ul&gt;&lt;li&gt;list-style-type属性&lt;/li&gt;&lt;li&gt;list-style-position属性&lt;/li&gt;&lt;li&gt;list-style-image属性&lt;/li&gt;&lt;ul&gt; 只需一个简单的 url() 值，就可以使用图像作为项目符号。不过，在选择图像时要当心，尽量选择合适尺寸的图片，否则项目符号可能不清晰。 通常，为了防止一些意外情况，如图像未能加载、或被破坏、或浏览器无法识别图像的格式等等，为列表定义一个备用的 list-style-type 是一个很好的实践。1234ul &#123; list-style-image: url(img/square.png); list-style-type: square;&#125; 由于list-style-image属性具有继承性，所以，内层的所有列表都会使用该图像作为项目符号。如果不希望这种情况发生，假如希望内层列表使用实心矩形，就需要把内层列表的 list-style-type属性设置为 square。另外，由于 list-style-image属性比 list-style-type属性的优先级要高。因此，还需要把内层列表的 list-style-image属性重置为 none。1234ul ul &#123; list-style-image: none; list-style-type: square;&#125; 6.3 创建导航6.3.1 面包屑导航面包屑导航（Bread Crumbs Navigation）是一种辅助和补充的导航方式，非常适合展示站点的层级关系，能帮助用户明确当前所处的位置，并方便地提供返回的路径。 面包屑的概念来自童话故事“汉赛尔和格莱特”，当汉赛尔和格莱特穿过森林时，为了不在森林里迷路，他们就在沿途走过的地方都撒下面包屑，让这些面包屑帮助他们找到回家的路。 由此可知，面包屑导航可以让用户清楚了解当前所处位置，以及当前页面在整个网站中的位置，并帮助用户快速学习和了解网站内容和组织方式，从而形成很好的位置感，还能提供返回各个层级的快速入口，方便用户操作，提高用户体验，从而降低网站的跳出率。 更重要的是，面包屑导航对网站的SEO非常有利，因为它增强了网站的内链建设，搜索引擎蜘蛛只需沿着这个链实施抓取就可以了，非常方便。 最常见的面包屑导航是横向的文字链接，并用大于号“&gt;”分开，这个符号也暗示了链接之间的层级关系。当然，也可以使用其他符号，如 “»”、“/”、“→”等，选择什么符号主要取决于网站的美学设计。 面包屑导航的制作方法非常简单，只需创建一个容器，并在容器中创建面包屑导航的链接即可。为了方便应用样式，可以把大于号放在 span 元素中。12345&lt;div class=\"breadcrumbs\"&gt; &lt;a href=\"#\"&gt;买房无忧&lt;/a&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;a href=\"#\"&gt;上海二手房&lt;/a&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;a href=\"#\"&gt;发布出售房源&lt;/a&gt;&lt;/div&gt; 由于导航中的所有链接都在一行内水平显示，为了美观，将容器的高度和行高设置为相同的值，以便容器中的内容能够垂直居中。1234.breadcrumbs &#123; height: 36px; line-height: 36px;&#125; 由于面包屑是一种辅助导航，在页面中，它不应该起支配作用。因此，链接文本不应该太突出，也相对较小。可以将整个导航中文本的颜色设置为浅黑色，字体大小设置为 12px，字体设置为宋体。12345.breadcrumbs &#123; color: #666; font-size: 12px; font-family: simsun;&#125; 并将链接的颜色也设置为浅黑色，并去掉链接的默认下划线。当用户鼠标悬停在链接上时，通过改变链接的颜色，来提醒用户。1234567.breadcrumbs a &#123; color: #666; text-decoration: none;&#125;.breadcrumbs a:hover &#123; color: #f60;&#125; 此时预览，发现链接文本和大于号挤在一起，影响美观。可以通过 span 元素的外边距，让链接文本和大于号之间保持适当的距离。123.breadcrumbs span &#123; margin: 0 10px;&#125; 至此，面包屑导航基本制作完成。整个导航中只包含文本，略显单调。可以在整个导航的开头添加一幅表示主页的图像，来丰富链接的内容，使它不至于那么单调。可以通过一个 img 元素来直接插入图像，也可以通过容器的背景图像来间接插入图像。 两种方法的效果完全相同，只是方法不同而已，这里使用背景图像。要为容器添加背景图像，还要为容器设置左内边距，来为背景图像腾出空间，以防背景图像和文本发生重叠。12345.breadcrumbs &#123; … padding-left: 20px; background: url(img/home.jpg) left 10px no-repeat;&#125; 插入图像后，整个导航就不那么单调了。 事实上，在实际应用中，网站的风格千变万化，面包屑导航的外观也是千变万化，但万变不离其宗，制作方法都是大同小异。比如，苹果商店的面包屑导航 要制作这样的面包屑导航也很简单，它只是将 span 元素中的大括号用类似大括号的图像进行替换而已。这个导航实现思路也很简单： 首先，创建导航中的链接。如果一个元素中没有任何内容，其宽度就会收缩为 0，背景图像就无法显示出来。因此，要将 span 元素中的大括号用空格代替。12345&lt;div class=\"breadcrumbs\"&gt; &lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=\"#\"&gt;Shop iPod&lt;/a&gt; &lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=\"#\"&gt;iPod Accessories&lt;/a&gt; &lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=\"#\"&gt;Power&lt;/a&gt;&lt;/div&gt; 其次，为容器添加边框，并设置合适的圆角。12345.breadcrumbs &#123; … border-radius: 6px; border: 1px solid #e5e5e5;&#125; 最后，将 span 元素的 display属性设置为 inline-block，并设置宽度，再应用模拟大括号的背景图像。123456.breadcrumbs span &#123; margin: 0 6px; width: 20px; display: inline-block; background: url(img/crumbs_bg.png) left top no-repeat;&#125; 6.3.2 分页导航对于搜索引擎或电子商务网站，常常将信息分页显示，这样可以减少页面大小，进而提高页面的加载速度。分页显示后，就需要通过分页导航来告诉用户要浏览的信息量，方便用户快速跳过一些不想看的信息，也便于定位和查找。因此，分页导航也是很常见的、很重要的一种导航。 实际上，分页导航的制作方法也很简单。分页导航一般包括上一页、页码、下一页三部分。首先，创建一个容器，来包裹分页导航的链接。如：12345&lt;div class=\"page\"&gt; &lt;a href=\"#\" rel=\"pre\"&gt;&amp;lt; 上一页&lt;/a&gt; &lt;a href=\"#\" class=\"active\"&gt;1&lt;/a&gt;…&lt;a href=\"#\"&gt;5...&lt;/a&gt; &lt;a href=\"#\" rel=\"next\"&gt;下一页 &amp;gt;&lt;/a&gt;&lt;/div&gt; 分页导航的所有链接也是在一行内显示，也要将容器的高度和行高设置为相同的值，来让容器中的内容垂直居中。1234.page &#123; height: 34px; line-height: 34px;&#125; 接下来设置链接的样式。由于链接默认是行内元素，只有鼠标移动到链接文本上，才能激活链接。如果把链接的 display 属性设置为 block，在链接区域的任何位置都能激活链接。然而，在IE6下，链接的 display 属性设置为 block 却不凑效，需要设置为 inline-block 才行。再为链接设置一个灰色边框，并设置合适的内边距，让链接水平居中。再设置链接文本的样式，包括颜色、字体、文本大小，并去掉链接的默认下划线。对于数字，tahoma字体比较醒目，因此将字体设置为 tahoma, simsun，让数字使用tahoma字体，中文使用宋体。123456789.page a &#123; display: inline-block; border: 1px solid #ededed; padding: 0 12px; color: #3e3e3e; font-size: 14px; font-family: tahoma,simsun; text-decoration: none;&#125; 再根据上下文的情况，设置链接悬停时的样式。这里将链接的悬停颜色设置为浅红色，同时，将悬停时的边框颜色也设置为同样的颜色：1234.page a:hover &#123; color: #f40; border-color: #f40;&#125; 为了突显当前页码，需要定义类 .active 的样式，将它的背景颜色、边框颜色都设置为浅红色，字体颜色设置为白色。并且，在鼠标悬停时，它的样式也保持不变：123456.page .active,.page .active:hover &#123; color: #fff; background: #f40; border: solid 1px #f40;&#125; 至此，分页导航就基本制作完成了 事实上，分页导航的目的，是为了方便用户快速跳转到想要的页码。然而，分页导航中可显示的页码一般是有限的，用户不可能跳转到任意页码。 一般的做法是，在分页导航中提供一个表单，表单中提供一个数字输入框和一个提交按钮，当用户输入数字，点击提交按钮后，便跳转到指定的页码。为了让方便用户输入，最好提供总页数和当前页码，并限制数字输入框的最大值和最小值。如：123456&lt;form&gt; &lt;span class=\"text\"&gt;共100页，到第&lt;/span&gt; &lt;input type=\"number\" value=\"2\" min=\"1\" max=\"100\" /&gt; &lt;span class=\"text\"&gt;页&lt;/span&gt; &lt;input type=\"submit\" value=\"确定\" /&gt;&lt;/form&gt; 为了让表单和页码在一行内显示，可以将表单元素的 display 属性设置为 inline，让它生成一个行内级框。123.page form &#123; display: inline;&#125; 再来设置表单中 span 元素、数字输入框、提交按钮的样式。由于表单并非分页导航的主角，将其中的文本颜色稍淡一点，字体也少小一点。1234567891011121314151617181920212223242526.page form span &#123; color: #999; font-size: 13px;&#125;.page form .text &#123; width: 35px; height: 21px; outline: none;&#125;.page form .button &#123; width: 46px; height: 24px; cursor: pointer;&#125;.page form .text,.page form .button &#123; text-align: center; border-radius: 2px; border: 1px solid #ededed; background: #fff;&#125;.page form .text:focus,.page form .button:hover &#123; color: #f40; border-color: #f40;&#125; 这样一来，如果页码很多，用户就可以自由输入页码，跳转到任意合法的页码，这就方便多了。 6.3.3 垂直导航垂直导航主要用于网站的侧边栏导航，使用侧边栏的好处是可以节约空间。因此，一些内容多，而又喜欢简约的网站，常常以侧边栏的方式进行展示。 默认情况下，列表及列表项 li 元素都是块级元素，每个列表项后独占一行。因此，使用无序列表创建垂直导航就非常方便。 首先，创建一个无序列表来包裹导航链接：1234567&lt;ul class = \"verticalnav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;产品中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"current\" href=\"#\"&gt;工程案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新闻动态&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;联系我们&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 这时预览，发现列表的内容都挤在一起，前面还有一个小圆点。并且，链接文本以蓝色显示，还带有下划线。 这个小圆点是列表的默认项目符号，它会占据列表的空间。因此，通常需要重置列表的默认样式，将外边距、内边距设置为 0，并去掉默认的项目符号。当然，这些操作一般都是在全局 reset 中进行，如果你使用全局reset，这个步骤就不必做了。12345ul &#123; margin: 0; padding: 0; list-style: none;&#125; 接下来，通过列表元素的宽度，来控制整个导航所占用的水平空间。123.verticalnav &#123; width: 120px;&#125; 再来设置导航链接的样式。在介绍按钮式链接时，曾经使用 padding 来增加链接的点击区域。但是，如果各个链接中的文本个数不同，则每个链接的宽度也不同，整个垂直导航就会参差不齐。 如果把容器设置为固定宽度，再把链接的 display 属性设置为 block，让它自动填满整个容器。这样一来，所有链接就具有相同的宽度，并且在链接区域的任何位置都能激活链接，一举两得。 同时，设置链接的高度，并通过 text-align 和 line-height 属性，让链接文本在水平方向和垂直方向居中显示。再根据上下文环境，为链接设置合适的颜色和字体。最后，去掉链接的默认下划线。123456789.verticalnav a &#123; display: block; height: 32px; line-height: 32px; text-align: center; color: #666; font-size: 12px; text-decoration: none;&#125; 为了提醒用户，当鼠标悬停时，自动改变链接文本的颜色。另外，为了突显当前链接，定义一个 current 类，并通过不同的颜色和左边框进行标识，让用户一目了然。12345678.verticalnav li a:hover, .verticalnav li a:focus &#123; color: #ff5f3e;&#125;.verticalnav li a.current &#123; color: #ff5f3e; border-left: 4px solid #ff5f3e;&#125; 好了，一个简约而漂亮的垂直导航就制作完成了。 6.3.4 手风琴导航在垂直导航中，如果存在多个分级，常常使用手风琴导航，它会以手风琴方式展开和折叠，来节约空间。 简单的说，手风琴导航就是垂直导航的层层嵌套，需要多少级，就嵌套多少层。这里就以两级导航为例，来介绍手风琴导航的基本制作方法。 为了方便控制手风琴导航的样式和行为，外层导航使用定义列表 dl、而内层使用无序列表 ul 来包裹导航中的链接元素：12345678910111213141516171819&lt;dl class=\"accordion\"&gt; &lt;dt&gt;&lt;a href=\"#\"&gt;公司介绍&lt;/a&gt;&lt;/dt&gt; &lt;dd&gt; &lt;ul class=\"verticalnav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司概况&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;历史沿革&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;dt&gt;&lt;a href=\"#\"&gt;产品中心&lt;/a&gt;&lt;/dt&gt; &lt;dt&gt;&lt;a href=\"#\"&gt;工程案例&lt;/a&gt;&lt;/dt&gt; &lt;dt&gt;&lt;a href=\"#\"&gt;新闻动态&lt;/a&gt;&lt;/dt&gt; &lt;dd&gt; &lt;ul class=\"verticalnav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"current\" href=\"#\"&gt;行业新闻&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;dt&gt;&lt;a href=\"#\"&gt;联系我们&lt;/a&gt;&lt;/dt&gt;&lt;/dl&gt; 首先，通过外层列表的宽度，来控制整个导航所占用的水平空间。并通过垂直外边距和背景颜色，让外层链接各元素之间界限分明。1234567.accordion &#123; width: 120px;&#125;.accordion dt &#123; margin: 1px; background: #6FB934;&#125; 其次，设置链接的样式。123456789.accordion a &#123; display: block; height: 32px; line-height: 32px; text-align: center; color: #fff; font-size: 14px; text-decoration: none;&#125; 这里使用子选择器 .accordion a 设置链接的样式，对整个手风琴菜单中的链接都产生影响，而二级导航中的链接需要局部调整。1234.verticalnav li a &#123; color: #666; font-size: 12px;&#125; 最后，设置二级导航中链接的悬停状态、激活状态，及当前链接的样式。1234567.verticalnav li a:hover, .verticalnav li a:focus &#123; color: #ff5f3e;&#125;.verticalnav li a.current &#123; color: #ff5f3e;&#125; 到此为止，手风琴导航的就制作完成了，但整个导航都处于展开状态，还需要实现手风琴方式的展开和折叠效果。 这个可以通过 jQuery来实现，其基本思想是：第一个导航的子导航默认展开，其他全部隐藏。当单击某个 dt 下的链接时，所有已经显示的 dd 元素以动画方式隐藏，当前链接元素的父元素（即 dt）的相邻元素（即二级导航 dd 元素）以动画方式展开。代码如下：12345678$(document).ready(function()&#123; $(\"dd:not(:first)\").hide(); $(\"dt a\").click(function()&#123; $(\"dd:visible\").slideUp(\"slow\"); $(this).parent().next().slideDown(\"slow\"); return false; &#125;);&#125;); 现在，当单击导航上的某个链接时，整个导航就能够以手风琴方式的展开和折叠了。 6.3.5 主导航水平主导航的制作方法。 首先，创建一个无序列表来包裹导航链接：12345678&lt;ul class = \"mainnav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;文件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;编辑&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;查看&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;收藏夹&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;工具&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;帮助&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 首先，重置列表的默认样式，将外边距、内边距设置为 0，并去掉默认的项目符号。并让列表的 li 元素向左浮动，来构建水平列表。12345678. mainnav &#123; margin: 0; padding: 0; list-style: none;&#125;. mainnav li &#123; float: left;&#125; 当列表的所有列表项都浮动后，它就不再占据文档流中的任何空间。因此，此时预览，列表中实际上没有内容，所有的列表项都溢出到列表的外面。 最简单的解决办法，就是使用 overflow: hidden 技术，让父元素创建一个新的块格式化上下文，来包含浮动的子元素。对于IE 6，则需要触发布局，最简单、又没有副作用的方法是设置 width: 100%。12345.mainnav &#123; … width: 100%; overflow: hidden;&#125; 为了让链接醒目，把 mainnav 元素的背景颜色设置为橙色，把链接的文本颜色设置为白色，并设置链接文本的字体，关闭链接的下划线。123456789.mainnav &#123; … background: #fa7a20;&#125;mainnav li a &#123; color: #fff; text-decoration: none; font: 1em \"Microsoft YaHei\", STXihei;&#125; 由于列表项 li 之间的默认间距为0，链接文本全部挤在一起。可以在链接两边增加内边距，来调整链接文本之间的距离。 再为链接指定宽度，并通过 padding 让链接文本垂直居中，通过 text-align 让链接文本水平居中。123456789.mainnav li a &#123; color: #fff; width: 80px; padding: 10px 0; text-align: center; display: inline-block; text-decoration: none; font: 1em \"Microsoft YaHei\", STXihei;&#125; 为了提醒用户，当鼠标悬停时，自动改变链接的背景颜色。另外，为了突显当前链接，定义一个current 类，并通过不同的背景颜色进行标识，让用户一目了然。123456.current &#123; background: #e4393c;&#125;.mainnav li a:hover &#123; background: #f30;&#125; 最后，通过增加适当的圆角，来锦上添花。就这样，一个时尚、高端、大气、上档次，兼容所有浏览器，又很流行的网站主导航就制作完成了，制作过程很简单吧。 6.3.6 下拉导航下拉菜单仍然是Web上流行的界面元素，虽然有一些纯Javascript 解决方案，但在禁用Javascript 的浏览器下，它却无能为力。因此，纯CSS的下拉菜单才是最好的选择。 这种技术及其简单，只需把子导航嵌套在无序列表中，并让子导航默认隐藏，然后当鼠标悬停或点击父列表时，再让它显示出来。 本节，在上一节主导航的基础上，添加子导航，来演示下拉导航的制作方法。主导航的样式保持不变，这里只介绍子导航的样式。首先，创建多级导航列表。1234567891011121314&lt;ul class = \"mainnav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;文件&lt;/a&gt; &lt;ul class = \"submenu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新建&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;打开&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;保存&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;编辑&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;查看&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;收藏夹&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;工具&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;帮助&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 与主导航相同，首先需要重置列表的默认样式，将外边距、内边距设置为 0，并去掉默认的项目符号。12345.submenu &#123; margin: 0; padding: 0; list-style: none;&#125; 由于在主导航中让所有 li 向左浮动，子导航中，需要子导航垂直显示。因此，需要让子导航中的 li 样式不再浮动。123.submenu li &#123; float: none;&#125; 接下来，把子导航中链接的 display 属性设置为 block，以便在链接区域的任何位置都能激活链接。再设置链接的宽度、默认属性、以及鼠标悬停时的属性。12345678910.submenu li a &#123; color: #000; padding: 4px 0; font-size: 13px; display: block;&#125;.submenu li a:hover &#123; color: #fff; background: #4899E0;&#125; 子导航样式设置完成后，就可以通过 display: none 把子导航隐藏起来。当鼠标悬停在主导航的 li 上时，再通过 display: block 把子导航显示出来。123.mainnav li:hover .submenu &#123; display: block;&#125; 由于子导航在普通流中定位，会占用父元素的空间。因此，如果子导航使用绝对定位，它就会脱离文档流，不再占用父元素的空间。这样的话，在子导航被显示出来时，父元素的高度就不会被撑开。123456.submenu &#123; padding: 0; list-style: none; display: none; position: absolute;&#125; 至此，纯CSS的下拉菜单就制作完成了！ 当然，也可以制作三级、四级，甚至更多级的下拉菜单。假如在二级菜单下，又添加三级下拉菜单：1234567891011&lt;li&gt;&lt;a href=&quot;#&quot;&gt;查看&lt;/a&gt; &lt;ul class = &quot;submenu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;工具栏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;转到&lt;/a&gt; &lt;ul class = &quot;drop&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;后退&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前进&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 无论多少级菜单，其本质完全相同，制作方法也没什么差别。都是让子菜单使用绝对定位，并默认隐藏起来，当鼠标悬停在上一级菜单上时，再自动将下级菜单显示出来。1234567891011.drop &#123; left: 100%; display: none; list-style: none; background: #ccc; position: absolute;&#125;.submenu li:hover .drop &#123; display: block; margin-top: -27px;&#125; 上述这种技术制作出来的下拉导航，可以适用于大多数现代浏览器，但在IE7及以下版本中，存在易用性问题。 一个问题是，在IE7及以下版本中，多级列表中，下级列表的位置会发生偏移，导致二级和三级菜单的位置不正确。可以通过 CSS hack 对二级和三级列表进行修正，偏移的距离，要根据实际情况确定，而IE6与IE7偏移的距离可能会不同，需要单独修正。12345678910111213.mainnav li:hover .submenu &#123; display: block; *margin-top: 38px; *margin-left: -88px; _margin-top: 40px; _margin-left: -84px;&#125;.submenu li:hover .drop &#123; display: block; margin-top: -27px; *margin-top: 0; *margin-left: 0;&#125; 另一个问题是，在IE6中，当鼠标悬停在主导航的 li 上时，子导航却不能正常显示出来，因为IE6不支持在非锚元素上使用 :hover 伪类选择器。因此，需要使用 Javascript 或 .htc 文件来启用这个功能。 .htc 文件实际上就是脚本文件，只有IE能够识别它。 在网上下载csshover.htc 文件，把它放在网站的某个位置，然后，在 body 选择器中通过 behavior 属性指向该文件即可。123body &#123; behavior: url(\"http://XXX/csshover.htc\");&#125; 还有一个问题，就是上述每个 li 后面有一个回车，在IE6中，当 li 中的内容是一个 a 元素，并且 a 元素或 a 元素的子元素（如，元素）设置了display: block 时，浏览器将不会忽略 li 之间的空白字符，表现为在 li 之间有一个额外的空行。 这个问题有两种解决办法：一种方法是避免为 li 中的 a 元素或 a 元素的子元素设置display: block，或去掉 li 后面的回车；另一种方法是就是让 a 元素或 a 元素的子元素触发布局，常用的就是通过 _zoom: 1 触发布局，因为它没有副作用。 我们使用第一种方法，让二级、三级等列表中的链接使用display: inline-block，这样既不影响链接的点击区域，又可以消除 li 之间的额外空行，可谓一举两得。123456.submenu li a &#123; color: #000; font-size: 13px; padding: 4px 0; display: inline-block;&#125; 至此，我们的三级下拉导航才算真正制作完成，它在所有的浏览器下都表现正常，并且表现完全一致。 表格和表单7.1 表格7.1.1 表格特有的元素HTML中，专门用来创建表格的标签多得吓人，而最常用的有 &lt;table&gt;、&lt;caption&gt;、&lt;thead&gt;、&lt;tbody&gt;、&lt;tr&gt;、&lt;th&gt;、&lt;td&gt; 这 7 个标签。 &lt;table&gt; 标签用于定义一个表格；&lt;caption&gt; 标签用于定义表格的大标题，习惯放在表格定义的第一行，即紧随 &lt;table&gt; 标签；&lt;tr&gt; 标签用来定义表格的行；&lt;th&gt; 标签用于定义行或列的名称，即表头，其中的内容默认会加粗居中显示；&lt;td&gt; 标签用于定义表格的单元格，来存放表格的数据。 为了方便控制样式，一般把表头放在 thead 元素中，表格正文放在 tbody 元素中。代码如下：12345678910111213141516171819&lt;table&gt;&lt;caption&gt;HTML表格示例&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头1&lt;/th&gt; &lt;th&gt;表头2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;单元格1&lt;/td&gt; &lt;td&gt;单元格2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格1&lt;/td&gt; &lt;td&gt;单元格2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 7.1.2 表格的基本布局在可视化模型中，一个表格既可以生成块级框（display:table），也可以生成行内级框（display:inline-table），默认生成块级框。 无论是块级框，还是行内级框，table元素都会生成一个主框，其中包含一个 table 框和一个 caption 框。 7.1.3 表格的样式属性表格中的每个单元格，都是盒模型中一个独立的盒子，并生成一个矩形框。因此，盒模型中几乎所有的属性，如边框、内边距、背景、对齐方式、文本、字体等，都适用于单元格的 td 元素。但有一点除外，外边距属性对 td 元素无效，相邻单元格之间的距离，是通过 border-spacing属性进行调整，而不是外边距属性。 在CSS2中，为表格定义了 5 个专用的属性，分别为 table-layout属性、caption-side属性、border-spacing属性、empty-cells属性 和 border-collapse属性，CSS3中未新增属性。 table-layouttable-layout属性来定义表格的布局算法，取值为 auto | fixed，默认值为 auto。auto 表示自动布局，fixed 表示固定布局。 使用自动布局时，表格的布局是由浏览器根据各单元格的内容自动计算得到，列的宽度是由列单元格中，没有折行的最宽内容设定。由于需要在所有单元格的内容读取计算之后，才能确定最终布局，所以渲染速度较慢。 使用固定布局时，水平布局仅取决于表格宽度、列的宽度、表格边框宽度、单元格间距，而与单元格的内容无关。浏览器接收到第一行数据后，就可以确定布局，所以渲染速度较快。因此，最好是通过表头 th 元素的 width 属性，来设置列的宽度。 当然，根据应用的需要，也可以只设置其中某些列的宽度。这样的话，设置了固定宽度的列将采用固定布局，而没有设置固定宽度的列将采用自动布局。无论怎样，只要有一个列设置了固定宽度，表格的 table-layout 属性就必须设置为 fixed。如，有以下表格：12345678910111213141516171819202122232425262728293031323334353637&lt;table&gt;&lt;caption&gt;2015年销售额&lt;/caption&gt;&lt;thead&gt; &lt;tr&gt; &lt;th&gt;年&lt;/th&gt; &lt;th&gt;季度&lt;/th&gt; &lt;th&gt;销售额（万元）&lt;/th&gt; &lt;th&gt;说明&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt; &lt;tr&gt; &lt;th&gt;2015&lt;/th&gt; &lt;th&gt;1&lt;/th&gt; &lt;th&gt;1895.26&lt;/th&gt; &lt;th&gt;...&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;2015&lt;/th&gt; &lt;th&gt;2&lt;/th&gt; &lt;th&gt;3456.84&lt;/th&gt; &lt;th&gt;...&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;2015&lt;/th&gt; &lt;th&gt;3&lt;/th&gt; &lt;th&gt;4857.69&lt;/th&gt; &lt;th&gt;...&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;2015&lt;/th&gt; &lt;th&gt;4&lt;/th&gt; &lt;th&gt;8941.82&lt;/th&gt; &lt;th&gt;...&lt;/th&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; 由于表格的第 1、2、3 列的内容比较明确，其宽度也相对固定。因此，就可以设置这三列的宽度，来采用固定布局，而不设置第 4 列的宽度，让它采用自动布局：12345678910111213table &#123; width: 100%; border-spacing: 0; table-layout: fixed; border-collapse: collapse;&#125;th:nth-child(1),th:nth-child(2) &#123; width: 40px;&#125;th:nth-child(3) &#123; width: 120px;&#125; 上述表格中，由于第 1、2、3 列设置了固定宽度，表格的 table-layout属性就必须设置为 fixed。 由于表格的宽度设置为百分比，表格就会随着浏览器窗口自动缩放（当然，还需要祖先元素采用流式布局），第 4 列也就会随之缩放。但无论怎么缩放，第 1、2、3 列的宽度始终保持不变。 caption-sidecaption-side属性用来定义caption框的显示位置。默认值情况下，caption 框显示在表格的上方，可以把 caption-side属性设置为 bottom 让它显示在表格的下方。 border-spacingborder-spacing属性用来定义相邻单元格的边框之间的距离，默认值为0。使用长度值定义，不允许使用负值。该属性需要两个长度值，第一个用于水平间距，第二个用于垂直间距。如果只提供一个长度值，则同时用于水平间距和垂直间距。 需要注意的是，只有在 border-collapse属性取值为 separate 时，该属性才会有效。并且，该属性是应用于表格本身，而不是单元格。如果为 td 元素声明 border-spacing属性，则会被浏览器忽略。 empty-cellsempty-cells属性用来定义当表格的单元格无内容时，是否显示该单元格的边框，取值为hide | show，默认值为show。只有在border-collapse属性取值为separate时，该属性才会有效。 如果该属性设置为show，则会绘制空单元格的边框和背景，就好像该单元格有内容一样。如果值为 hide，则不会绘制该单元格的边框和背景，就好像该单元格被设置为 visibility: hidden 一样。 如果一个单元格包含有内容，则不能认为是空的。这里的内容除了文本、图像、表格等，还包括不间断空格（&nbsp;）、以及除回车、换行、空格符以外的所有其它空白符。如果一行中的所有单元格都为空，而 empty-cells 的值为 hide，则该行的高度为 0，就好像这个整行被设置为 display: none 一样。 border-collapseborder-collapse属性用来定义单元格边框的显示方式，取值为 separate | collapse，默认值为 separate。separate 表示各单元格有独立的边框，collapse 表示相邻单元格的边框被合并为一个边框。 边框独立时，不会忽略 border-spacing属性和 empty-cells属性；边框合并时，则会忽略 border-spacing属性和 empty-cells属性。如：123456789101112131415.separate &#123; border-collapse: separate; border-spacing: 2px;&#125;.collapse &#123; border-collapse: collapse;&#125;caption &#123; margin: 4px; font: bold 14px 黑体;&#125;th, td &#123; border: 1px solid #ccc; padding: .3em 1em;&#125; 左侧表格采用独立边框，右侧表格采用合并边框。为了清楚可见，为单元格定义1px的灰色边框，即每个单元格各自有1px的边框。独立边框还定义了2px的边框间隙。 可以看出，左侧表格单元格的边框各自独立，单元格之间的距离为各自边框及边框间距之和，即1px + 2px + 1px = 4px；而右侧表格单元格边框被合并成了一个边框，并忽略了边框间隙，最终边框宽度依然为1px。 7.2 表单7.2.1 表单元素的样式表单元素主要包括 label、input、textarea、select、datalist、keygen、progress、meter、output等，以及对表单元素进行分组的 fieldset 和 legend 元素。 根据功能的不同，input 元素又包括 text、password、radio、checkbod、file、submit、reset、search、tel、url、email、number、range、color、Date Pickers等类型。 由于规范只规定了表单元素的功能，并未规定它们的外观。因此，在不同浏览器下，表单元素的外观各不相同。 为了获得更好的用户体验，在所有浏览器下保持统一的风格，通常需要重新定义表单元素的外观，来覆盖浏览器的默认外观。 自定义外观时，元素类型不同，需要重新定义的内容也不尽相同。接下来，针对不同的表单元素，进行分别介绍。 input元素在input 元素中，单行文本输入框、文件选择框、单选框和复选框、表单按钮在各浏览器下的外观差别较大，需要专门定义外观，来统一风格。 1）单行文本输入框 单行文本输入框，包括text、password、search、tel、url、email、number、Date Pickers，它们的作用是纯粹接受文本，这些文本信息或者由用户手工输入，或者在浏览器的弹出框中选择输入。 假设在一个用户登录界面上，包含一个 type=”text” 和一个 type=”password” 的文本输入框，分别用来输入用户名的密码：1234&lt;form id=\"layer\" action=\"\" method=\"post\"&gt;&lt;p&gt;&lt;label&gt;用户名: &lt;/label&gt;&lt;input type=\"text\" name=\"username\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;密&amp;nbsp;&amp;nbsp;码: &lt;/label&gt;&lt;input type=\"password\" name=\"password\" /&gt;&lt;/form&gt; 在外观上，单行文本输入框就是一个添加了边框的矩形区域，而不同浏览器下的默认尺寸、边框、背景等都不尽相同。 不同浏览器下的差别很大，即便是相同浏览器的不同版本（如IE6、IE8），也可能有很大差别。因此，为了能够在所有浏览器下表现相同，需要重新定义框的宽度、高度、字体、文本、边框、背景等，来覆盖浏览器的默认外观。如：123456789input[type=\"text\"] ,input[type=\"password\"] &#123; width: 240px; height: 28px; color: #333; font-size: 14px; background: #fff; border: 1px solid #cbcbcb;&#125; 有时候，为了突显该文本输入框的作用，比如用户登录表单中，在用户名和密码的输入框中，通过背景图像来添加一个小图标，显得更人性化。设置背景图像后，需要为文本框设置相应的左内边距，来为图像腾出空间。12345678910input[type=\"text\"],input[type=\"password\"] &#123; padding-left: 34px;&#125;input[type=\"text\"] &#123; background: #fff url(user.gif) 10px center no-repeat;&#125;input[type=\"password\"] &#123; background: #fff url(pass.gif) 10px center no-repeat;&#125; 在现代浏览器中，可以通过圆角和内部盒阴影，对文本输入框进行渐进式增强，使它看上去更美观，还能增加一点不错的立体效果。添加圆角和内部盒阴影12345input[type=\"text\"],input[type=\"password\"] &#123; border-radius: 4px; box-shadow: inset 2px 2px 4px #d9d9d9;&#125; 如果在文本输入框获得焦点时，通过改变边框颜色，并在文本框的外面，添加一个淡淡的盒阴影，这样既能向用户作出反馈，又能增强用户体验。 由于大多数现代浏览器中，在文本输入框获得焦点时，都是通过改变文本框的轮廓颜色，来向用户作出反馈。如果不希望如此，可以把 outline 属性设置为 none，关闭此功能。123456input[type=\"text\"]:focus,input[type=\"password\"]:focus &#123; outline: none; border: 1px solid #bbb; box-shadow: 2px 2px 8px #b8b7b7;&#125; 2）文件选择框 文件选择框与单行文本输入框不同，它有一个按钮，供用户选择文件。在不同的浏览器下，文件选择框的外观差别很大，情况稍微有点复杂。 在IE下，文件选择框表现为一个文本输入框和一个“浏览…”按钮。在用户未选择文件时，文本输入框的内容为空，用户选择文件后，文本输入框的内容为文件的绝对路径。 并且，在IE的不同版本下，文件选择框的外观还稍有差别，IE6和IE7下，文本输入框是灰色背景，而IE8下是白色背景。因此，要在IE下获得一致的表现，就必须设置背景和边框的样式。 在Google Chrome浏览器下，它只有一个“选择文件”的按钮，而没有文本输入框。在用户未选择文件时，显示“未选择任何文件”字样，用户选择文件后，在按钮的右侧显示文件的名称。 为了在所有浏览器下保持统一的风格，常常需要为一个表单中的文本输入框定义宽度、背景和边框：12345input &#123; width: 320px; background: #fff; border: 1px solid #94B6ED;&#125; 当然，上述定义对所有的文本输入框均有效，包括文件选择框。然而，不同的浏览器，对文件选择框应用边框的方式却又不同。 IE浏览器，会为文本输入框和“浏览…”按钮应用相同的边框样式，互不影响。 Google Chrome浏览器，会为“选择文件”按钮和右侧文本同时应用边框，边框出现在“选择文件”按钮和右侧文本的周围。 当然，这个并不是真正想要的效果，我们希望Google Chrome下，仅仅在“选择文件”按钮周围出现边框。 此时，就可以借助CSS Hack技术中的 ‘\\9’，让边框只对IE有效。并使用 webkit 内核专有的 ::-webkit-file-upload-button 伪元素，来设置“选择文件”按钮的样式，使IE和Chrome的按钮风格保持一致：12345678910input &#123; width: 320px; background: #fff; border: 1px solid #7F9DB9\\9;&#125;::-webkit-file-upload-button &#123; padding: 4px 14px; background: #ECE9D8; border: 1px solid #7F9DB9;&#125; 当然，这里只是提供了一种处理问题的思路，并不代表它就是最佳解决方案，显然这种处理方案只对 webkit 内核的浏览器有效，具有很大的局限性。 既然上述解决方案有很大的局限性，能否换一种思路，设计一个文件选择框，让它在任何浏览器下的表现完全一致呢？ 答案是肯定的。既然大家已经习惯了IE的文件选择框，就可以在表单上包含一个文本框、一个 “浏览…” 按钮和一个文件框，通过文本框和 “浏览…” 按钮，来模拟文件框的外观，而文件框的功能保持不变，只是被隐藏起来了：12345&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" id=\"text\" /&gt; &lt;input type=\"button\" value=\"浏览...\" /&gt; &lt;input type=\"file\" id=\"file\" /&gt;&lt;/form&gt; 首先，设置文本框和按钮的样式，来模仿文件框的外观，主要是设置其宽度和高度。为了兼容IE6和IE7，还需要设置背景和边框样式：12345678910111213input[type=\"text\"]&#123; width: 180px; height: 24px; line-height: 24px; background: #fff; border: 1px solid #94B6ED;&#125;input[type=\"button\"]&#123; width: 70px; height: 26px; background: #ECE9D8; border: 1px solid #94B6ED;&#125; 然后，让文件选择框使用绝对定位（先要把 form 设置为相对定位），并控制它的尺寸，让它正好覆盖文本框和按钮，还要保证按两个钮正好对齐。再通过透明度，来隐藏文件选择框。这样，用户点击按钮或文本框（现代浏览器下），就等价于点击文件选择框，可以做到以假乱真了。123456789101112form &#123; position: relative;&#125;input[type=\"file\"]&#123; top: 0; left: 0; position: absolute; width: 260px; height: 26px; filter: alpha(opacity:0); opacity: 0;&#125; 使用这种技术设计出来的文件选择框，在任何浏览器下的外观都完全一致。 不过，由于文件框被隐藏，在用户选择文件后，就不能清楚看到自己的选择。其实这也不难，只需少量的 Javascript 代码就可以实现。 当用户选择文件后，就会触发文件选择框的 onchange 事件，只需在该事件的处理函数中进行相应的处理即可。 如果是单文件选择框，就非常简单，由于它只能选择一个文件，只需根据 id 获取文件框的值，并将它显示在文本框中即可：1&lt;input type=\"file\" onChange=\"text.value = this.value\" /&gt; 在HTML5中，为文件选择框新增了 multiple 属性，支持选择多文件。如果是多文件选择框，可以通过一个函数，来遍历文件框的值，并显示在文本框中：1&lt;input type=\"file\" onChange=\"text.value = getFiles(this.files)\" multiple /&gt; 对于多文件选择框，当用户选择文件后，会将文件保存在 FileList 对象中，它是一个文件的列表，通过遍历该列表，就可以得到每个文件的信息。1234567function getFiles(files) &#123; var strText = \"\"; for(var i = 0; i &lt; files.length; i++) &#123; strText += files[i].name + \", \"; &#125; return strText;&#125; 上述函数中，通过遍历 FileList 对象，通过 name 属性得到每个文件的名称，并把它们用逗号连接起来。于是，用户选择文件后，文本框中就会显示用户所选择的文件列表。 如果需要，还可以获取文件的大小（size）、类型（type）、最后修改日期（lastModifiedDate）等信息。 3）单选框和复选框 单选框和复选框本身很简单，但有一个问题，就是默认情况下，在所有的浏览器中，单选框和复选框都无法与旁边的文本对齐。 导致这个问题的原因很复杂，限于篇幅，这里不进行深究，只给出解决方案。其实，这个问题的解决方案也很多，一个比较简单的解决方案，就是让单选框和复选框垂直居中对齐，再设置 -2px 的上外边距和 1px 的下外边距：123456input[type=\"radio\"],input[type=\"checkbox\"] &#123; vertical-align: middle; margin-top: -2px; margin-bottom: 1px;&#125; 经过上述处理之后，选择框与文本已经对齐，并且，在所有的浏览器中的表现基本相同。 select元素在表单元素中，下拉列表是最令人头疼的一个元素，因为它的外观非常丑陋，而许多样式对它又不生效。如，字体、文本颜色、边框、背景颜色等，都很容易进行美化处理。但是，任凭怎么美化，默认的下拉箭头始终保持不变，无法直接进行处理。 这个问题有多种解决方案，相对简单的解决方案是，用一个容器来包裹 select 元素。再为容器应用样式，来模拟下拉列表的样式。 在实际应用中，可以根据上下文需要来选择包裹 select 元素的容器。如果希望 select 元素独占一行，就用块级容器进行包裹；否则，就用行内级容器来包裹。这里以块级容器 div 为例进行说明：123456&lt;div class=\"select\"&gt;&lt;select&gt; &lt;option value=\"1\"&gt;北京&lt;/option&gt; &lt;option value=\"2\"&gt;上海&lt;/option&gt;&lt;/select&gt;&lt;/div&gt; 首先，设置容器的尺寸，再指定一个自定义的下拉箭头，作为容器的背景，并让它出现在预想的位置，以便能够遮盖 select 元素的默认下拉箭头。如果希望 select 元素在行内显示，还需要设置 display 属性。123456.select &#123; width: 240px; height: 34px; overflow: hidden; background: #fff url(arrow_down.png) 220px center no-repeat;&#125; 然后，通过 appearance 属性清除 select 元素的默认样式，并让背景透明，这是本方案的核心，也是最关键的一步。 再根据需要，设置 select 元素的尺寸、内边界、字体、背景、边框等属性。使用百分比设置尺寸的好处是，在修改容器尺寸时，不必修改 select 元素的样式，让布局更灵活、更独立，可以提高代码的可维护性。12345678910.select select &#123; width: 100%; height: 100%; padding: 5px; font-size: 14px; background: transparent; border: 1px solid #94B6ED; -moz-appearance: none; -webkit-appearance: none;&#125; 当然，可以更进一步美化，当用户执行点击操作后，将向下的箭头动态改变为向上的箭头，使下拉列表更加人性化。这个功能只需简单的jQuery即可实现。 首先，定义一个类，它让容器使用向上的箭头作为背景图像。123.selected &#123; background-image: url(arrow_up.png);&#125; 然后，当jQuery检测到用户执行点击操作后，为容器添加 .selected 类，来改变箭头的方向。点击操作既可以由容器触发，也可以由下拉列表触发，根据实际情况进行选择。12345$(function() &#123; $(\".select\").click(function() &#123; $(\".select\").addClass(\"selected\"); &#125;);&#125;); 上述这种直接书写代码的方式确实很方便，但它不利于代码的重用。如果把这个点击操作封装为一个函数，再为容器绑定单击事件的处理函数 onclick=”changArrow()” ，可以大大提高代码的重用性。123function changArrow() &#123; $(\".select\").addClass(\"selected\");&#125; 而当鼠标移出容器时，需要删除 .selected 类，来恢复箭头的方向。同理，需要为容器绑定鼠标移出事件的处理函数1234onmouseout=\"removeArrow()\"：function removeArrow() &#123; $(\".select\").removeClass(\"selected\");&#125; 现在，下拉列表趋于完美了，用户点击后，会自动把向下的箭头改为向上的箭头，当鼠标移出时，再恢复箭头的方向。 表单按钮默认的按钮非常丑陋，并且不同浏览器下的外观又不尽相同。如果使用图像按钮，还需要向服务器请求图像，会增加服务器的额外负担。因此，使用原生的表单按钮，再使用纯CSS进行美化，才是最佳的选择。 HTML中，共有三类表单按钮，分别是提交按钮、重置按钮和普通按钮，无论哪种按钮，美化方法完全相同。 其实非常简单，首先设置按钮文本的颜色、字体，在通过 padding 属性文本在按钮中的位置，再根据上下文的风格，设置按钮的背景颜色。为了让按钮有一点立体感，可以增加一个边框，让边框跟背景使用相同色系，但颜色稍深一点：12345678input[type=\"submit\"] &#123; color: #fef4e9; font-size: 16px; font-family: \"Microsoft YaHei\"; padding: .4em 2em .45em; background: #f78d1d; border: 1px solid #da7c0c;&#125; 当鼠标悬停到按钮上时，通过改变背景颜色，来提醒用户：123input[type=\"submit\"]:hover &#123; background: #f47c20;&#125; 上述按钮可以适应于所有的浏览器，并在所有浏览器下的表现完全相同。为了在现代浏览器下表现得更好，可以通过圆角、文本阴影，对按钮进行渐进式增强，并通过盒阴影和渐变背景，让按钮的立体感更加逼真：1234567input[type=\"submit\"] &#123; … border-radius: 4px; text-shadow: 0 -1px 1px rgba(0, 0, 0, 0.25); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.6); background: linear-gradient(180deg, #faa51a, #f47a20);&#125; 7.2.2 水平布局的表单对于非常简短的表单，用户要填写的内容比较少，表单本身也不会占用太多空间，比如网站顶端的快捷登录表单，它只包含用户名、密码和登录按钮：12345&lt;form action=\"\" method=\"post\"&gt; &lt;label&gt;用户名: &lt;/label&gt;&lt;input type=\"text\" name=\"username\" /&gt; &lt;label&gt;密码: &lt;/label&gt;&lt;input type=\"password\" name=\"password\" /&gt; &lt;input type=\"submit\" value=\" 登 录 \" /&gt;&lt;/form&gt; 这种简短的表单，比较适合采用水平布局，让整个表单在一行内显示。由于默认情况下，表单上的所有元素都会生成一个行内级框。所以，采用水平布局时，无需对表单元素做太多的设置，只需设置文本框的宽度和边框，让它们按顺序自然排列即可。12345input[type=\"text\"],input[type=\"password\"] &#123; width: 100px; border: 1px solid #ccc;&#125; 就这么简单，一个水平布局的表单就制作完成了， 7.2.3 垂直布局的表单对于比较复杂的表单，要填写的内容相对较多，采用水平布局显然不合适。因此，垂直布局的表单更加常用。垂直对齐的表单中，标签和输入框可以使用三种对齐方式，包括顶对齐、左对齐和右对齐。 顶对齐的表单顶对齐可以缩短用户填写表单的时间，由于标签和输入框非常靠近，处理起来毫不费力，用户只需顺着表单向下移动，就可完成整个表单。 但是，顶对齐的标签会占用额外的垂直空间。因此，如果可供使用的垂直屏幕空间较小，应当谨慎使用顶对齐标签。另外，顶对齐的表单还应当采用合适的垂直距离，输入框之间的垂直距离太小或太大都会影响填写。一般而言，最好使用输入框高度的50%到70%，作为相邻输入框的间距。 如果人们不熟悉表单要收集的数据，或者在逻辑上分组有困难，左对齐的标签浏览起来可能更容易。用户只需要上下看看左侧的标签就可以了，而不会被输入框打断思路。 左对齐的表单左对齐可以占用较少的垂直屏幕空间，但有些长标签会增加标签和输入框之间的距离，用户必须左右来回跳转目光，来找到标签对应的输入框，因而影响填写表单的时间。 于是产生了一种替代的方案，右对齐标签的布局，它使得标签和输入框之间的联系更紧密，有助于快速填写表单。 右对齐的表单然而，右对齐会导致左边参差不齐，会降低浏览表单的效率。对于西方国家，人们习惯于从左至右的书写，右对齐会给这些用户造成阅读障碍。 由此可知，三种对齐方式各有利弊，在实际应用中，到底采用哪种对齐方式，则由应用场景和具体的目标而定，不能一概而论。根据中文的语言习惯，以及大多数网站的情况，右对齐的表单比较常用。 接下来，通过一个实例，来简单介绍一下垂直布局表单的实现方法。众所周知，表格本身是一种网格结构，其最大特点是同一列都具有相同的宽度，因此，表格本身是一种很好的布局工具。 由于表单内容相对简单，每行一般只包含一项内容，都是在一个标签后，紧跟一项待填写的表单元素。因此，表单的就相当于 n 行两列的布局，一列是标签，一列是待填写的表单元素。 如果把表单的每一行放在一个块级容器中（如，div、p等），并让每一列都具有固定宽度，则表单的内容就具有表格的特点，其布局也就非常简单。 在表单元素中，label 元素默认生成一个行内框，其他元素则生成一个原子行内级框。因此，如果把 label 元素的 display 属性设置为 inline-block，它也会生成一个原子行内级框。这样的话，就可以为表单上的所有元素设置固定宽度，实现网格布局。 当然，对于复杂的表单，一行内可能有三列、四列，甚至更多列。无论有多复杂，都可以沿用这种思想，让每一列生成一个原子行内级框，来采用网格布局。如，以下表单：123456789101112131415161718192021&lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;&lt;label&gt;姓名: &lt;/label&gt;&lt;input type=\"text\" name=\"name\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;E-Mail: &lt;/label&gt;&lt;input type=\"email\" name=\"email\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;所在城市: &lt;/label&gt; &lt;select name=\"city\"&gt; &lt;option value=\"1\"&gt;北京&lt;/option&gt; &lt;option value=\"2\"&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt;&lt;label&gt;性别: &lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\" checked /&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"female\" /&gt;女 &lt;/p&gt; &lt;p&gt;&lt;label&gt;个人爱好: &lt;/label&gt; &lt;input type=\"checkbox\" name=\"music\" value=\"music\" checked /&gt;音乐 &lt;input type=\"checkbox\" name=\"swimming\" value=\"swimming\" /&gt;游泳 &lt;input type=\"checkbox\" name=\"football\" value=\"football\" checked /&gt;足球 &lt;input type=\"checkbox\" name=\"skating\" value=\"skating\" /&gt;轮滑 &lt;/p&gt; &lt;p&gt;&lt;label&gt;自我介绍: &lt;/label&gt;&lt;textarea name=\"introduce\" &gt;&lt;/textarea&gt;&lt;/p&gt;&lt;/form&gt; 事实上，网格布局的核心，就是行和列的布局，行布局负责元素在行内的水平摆放整齐，列布局负责相同的列能够正确对齐。 首先，进行行格式化。为了防止行之间过于拥挤，可以为 p 元素添加 10px 的上下外边距。由于相邻的 p 元素会发生外边距合并，则所有行之间的距离都将是 10px。123form p &#123; margin: 10px 0;&#125; 在一行内，如果 label 和 input 元素生成的框垂直居中对齐，会比较美观。这样的话，无论行有多高，这些元素会始终保持居中对齐。123label, input &#123; vertical-align: middle;&#125; 其次，进行列格式化。列格式化的目的，是实现网格中列的对齐。如果相同的列都等宽的话，网格自然就会对齐。因此，只需把 label 元素的 display 属性设置为 inline-block，再为 label 和 input 元素设置合适的宽度，即可实现列的对齐。1234567label &#123; width: 80px; display: inline-block;&#125;input &#123; width: 240px;&#125; 当为 input 元素设置宽度 240px 后，预览就会发现，所有的input 元素（如radio、checkbox、提交按钮等）的宽度都将变成 240px。 解决这个问题的一个办法是，使用属性选择器寻找特定类型的表单元素，专门设置宽度。如，专门设置文本输入框的宽度：123input[type=\"text\"] &#123; width: 240px;&#125; 或者如果希望大多数的 input 元素的宽度都是 240px，只有 radio 和 checkbox 使用其它宽度，则可以将这些元素的宽度设置为 auto，来覆盖前面对 input 元素的设置：1234input[type=\"radio\"],input[type=\"checkbox\"] &#123; width: auto;&#125; 遗憾的是，属性选择器在IE6及更低版本中是无效的。因此，在属性选择器得到广泛支持之前，区分输入元素最好的方法，是给他们分配一个类。如，为单选按钮分配类名 radio，为复现框分配类名 checkbox：123.radio, .checkbox &#123; width: auto;&#125; 再为 label元素设置 text-align: right 来实现标签的右对齐，并通过右侧的外边距，使 label 和 input 之间保持适当的距离，防止标签和输入框过于拥挤。1234label &#123; text-align: right; margin-right: 10px;&#125; 好了，表单元素现在已经按照网格排列整齐。然后，再按照前面介绍的方法，对每个表单元素的细节进行处理，来实现需要的表单效果。 7.2.4 弹出隐藏的表单大多数情况下，表单会直接显示在页面上，但并非总是如此。比如，一些购物网站，允许用户把商品加入购物车，当提交订单时，再检测用户是否登录，如果没有登录，则弹出登录界面，供用户登录。 弹出表单的基本原理是，在页面上已经存在一个表单，并通过CSS将其隐藏，当用户点击某个按钮或链接，或满足一定触发条件时，再利用 Javascript 或 jQuery 将表单动态显示出来。当然，不局限于表单，页面上的任何元素，都可以通过这种方式动态显示出来。 这种效果不仅能够充分利用有限的版面空间，而且能够提高用户体验。更重要的是，它并不影响 SEO 效果，因为它实际存在于页面中，只是对用户不可见而已。 本节，我们通过一个具体的实例，来演示一下如何弹出隐藏的表单。假设页面上有一个链接和一个隐藏的用户登录界面，用户点击链接后，会弹出隐藏的界面。 首先，制作用户登录的界面。它实际上就是一个表单，输入用户名和密码后，方可登录。同时，表单上还提供一个链接，供用户关闭表单。123456789&lt;form id=\"layer\" action=\"\" method=\"post\"&gt;&lt;div class=\"title\"&gt;&lt;h2&gt;用户登录&lt;/h2&gt;&lt;a onclick=\"layer.style.display=none\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;&lt;label&gt;用户名: &lt;/label&gt;&lt;input type=\"input\" name=\"username\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;密 码: &lt;/label&gt;&lt;input type=\"password\" name=\"password\" /&gt;&lt;p&gt;&lt;input type=\"submit\" value=\" 登 录 \" /&gt;&lt;/p&gt;&lt;/form&gt; 由于在执行显示和隐藏操作时，要通过 id 属性来获得表单对象，因此，需要为 form 元素定义 id 属性。 在HTML代码中，如果在链接的 onclick 处理事件中编写Javascript代码，则可以直接通过 id 来获得一个对象。因此，可以直接通过 id 获得表单对象，再把它的 display 属性值设置为 none，来隐藏表单。 考虑到代码的重用性，也可以编写一个Javascript函数，来隐藏表单。如果使用Javascript函数，就要通过 document.getElementById() 接口来获得一个对象，而不能直接通过 id 获得对象。1234function hideLayer(id) &#123; var obj = document.getElementById(id); obj.style.display = \"none\";&#125; 其次，通过CSS的 id 选择器将表单隐藏起来，因为在打开页面时，并不希望它被显示出来。需要注意的是，这个 id 选择器必须与 form 中定义的 id 名称匹配。1234#layer &#123; display: none; position: absolute;&#125; 如果表单使用绝对定位，在它被显示出来时，就不会影响其他元素，也不会破坏页面布局，因为它已经脱离文档流。绝对定位可以使用 position: absolute，也可以使用 position: fixed。但是，IE6及以下版本不支持固定定位，使用时要小心。 隐藏一个绝对定位的元素，可以使用 display: none，也可以使用 visibility: visible，要根据实际情况，选择合适的方法。 其次，创建Javascript代码，来动态显示表单，它是弹出隐藏表单的核心。为了方便代码重用，需要把弹出表单的操作封装为一个函数。 因为要操作页面元素，必须要知道元素的 id。另外，还希望表单出现在屏幕的中央位置，就需要知道表单的宽度和高度。因此，该函数需要三个参数，第一个参数是表单元素的 id，第二个参数是表单的宽度，第三个参数是表单的高度。1234567891011function showLayer(id, width, height) &#123; var obj = document.getElementById(id); var winWidth = document.documentElement.clientWidth; var winHeight = document.documentElement.clientHeight; var offsetTop = document.documentElement.offsetTop; var left = (winWidth - width)/2; var top = (winHeight - height)/2 + offsetTop; obj.style.top = top + \"px\"; obj.style.left = left + \"px\"; obj.style.display = \"block\";&#125; 需要注意的是，在设置表单元素的 top 坐标时，要把页面滚动的距离计算在内。另外，在Javascript中操作CSS时，CSS的属性值都是字符串。因此，就要写成 obj.style.top = top + “px”，不能省略 “px”。 最后，在页面是创建一个链接，当用户主动点击该链接时，调用Javascript函数，将表单动态显示出来。1&lt;a onclick=\"showLayer(\"layer\", 300, 400)\"&gt; 登 录 &lt;/a&gt; 当然，在实际应用中，除了点击链接外，也可以让用户点击按钮，或满足一定触发条件时，自动调用Javascript或jQuery的函数来显示表单。 说明：本例操作表单的显示和隐藏，都是直接使用Javascript实现的。当然，也可以使用jQuery来实现。无论使用Javascript，还是jQuery，其思想完全相同，只是两种表现形式而已。更重要的是，如果使用jQuery，代码会更加简洁。并且，jQuery可以很容易获取到表单元素的宽度和高度，showLayer()函数就可以省略两个参数，使用起来更加方便。123456789function showLayer(id) &#123; var left = ($(window).width() - $(id).width())/2; var top = ($(window).height() - $(id).height())/2; $(id).css(&#123;\"top\": top, \"left\": left, \"display\": \"block\"&#125;);&#125;function hideLayer(id) &#123; $(id).css(&#123;\"display\": \"none\"&#125;);&#125; 需要注意的是，如果使用jQuery实现，设置坐标时，无需再添加 “px”。另外，在调用这两个函数的地方，参数 id 的前面要加一个 ‘#’（当然，也可以在函数中拼接），它是jQuery中 id 选择器的标识符。如，显示表单的链接就要写成 &lt;a onclick=&quot;showLayer(&#39;#layer&#39;)&quot;&gt; 登 录 &lt;/a&gt;。 变换、过渡和动画8.1 变换在CSS3之前，要实现元素的平移、旋转、缩放和倾斜效果，常常需要依赖图片、Flash或Javascript才能完成。 在CSS3中，使用变换（transform），就能轻松实现这些效果，而无需加载额外的文件，在提升开发效率的同时，还能提高页面的执行效率。变换的基本原理，是通过改变坐标系统，来实现元素的平移、旋转、缩放和倾斜等效果。 把实现平移、旋转、缩放、倾斜等所使用的方法，称作变换函数，它们分别是translate、rotate、scale、skew、matrix。 CSS3中，通过 transform属性指定一系列变换函数，来实现元素的变换效果。语法格式为：1transform: none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]* 默认值为none，表示不进行变换；表示一个或多个变换函数，以空格分开。也就是说，变换可以用于任何元素，一个元素可以同时应用多种类型的变换，包括平移（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）、及矩阵变换（matrix）。 CSS3中的变换包括2D变换和3D变换，2D变换在二维坐标系统中进行，3D变换在三维坐标系统中进行。笔者对3D变换研究不深，这里只介绍2D变换。 2D变换，就是在二维空间中，通过平移、旋转、缩放、倾斜和矩阵变换，来改变二维坐标系统中的 x 轴、 y 轴，进而实现元素的平移、旋转、缩放、倾斜效果。 平移平移，就是在水平或垂直方向上，将元素移动指定的距离。平移有三个变换函数： 1）translate(tx, ty)：在水平方向和垂直方向同时平移（即 x 轴和 y 轴同时移动）。如果未提供 ty，则使用默认值 0。 参数 tx 表示在 x 轴方向平移的距离，大于 0 时向右移动，小于 0 时向左移动，等于0 表示不平移；参数 ty 表示在 y 轴方向平移的距离，大于 0 时向下移动，小于 0 时向上移动，等于 0 表示不平移。 如，transform: translate(100px, 20px)，表示将元素在 x 轴方向向右移动 100px，y 轴方向向下移动 20px。 2）translateX(tx)：只在 x 轴（水平方向）进行平移，相当于translate(tx, 0)。 如，transform: translateX (100px)，表示将元素在 x 轴方向向右移动 100px，y 轴方向不进行移动。 3）translateY(ty)：只在 y 轴（垂直方向）进行平移，相当于translate(0, ty)。 如，transform: translateY (20px)，表示将元素在 y 轴方向向下移动 20px，x 轴方向不进行移动。 旋转旋转，就是围绕变换的原点，将元素按顺时针或逆时针方向旋转指定的角度。旋转只有一个变换函数： rotate(θ)：将元素旋转 θ 所指定的角度。角度的单位为度（deg），正值表示顺时针旋转，负值表示逆时针旋转。 如，transform: rotate(45deg)，表示将元素按顺时针方向旋转45°。 缩放缩放，就是基于变换的原点，将元素在水平或垂直方向上缩小或放大指定的倍数。缩放有三个变换函数： 1）scale(sx, sy)：在水平方向和垂直方向同时缩放（即 x 轴和 y 轴同时缩放）。如果未提供 sy，则 sy 与 sx 相等，即表示 x，y 两个方向的缩放比例相同。 参数 sx 表示在 x 轴方向的缩放比例，大于 1 时放大，小于 1 时缩小；参数 sy 表示在 y 轴方向的缩放比例，大于 1 时放大，小于 1 时缩小。默认情况下，sx 和 sy 参数的值均为 1，即不进行缩放。sx, sy 既可以是正值、也可以是负值。为负值时，首先把坐标轴的方向改变为相反方向，使元素在该方向上发生翻转，然后再执行缩放操作。 如，transform: scale (2, 1.5)，表示将元素在 x 轴方向放大 2 倍，在 y 轴方向放大 1.5倍。 2）scaleX(sx)：只在 x 轴（水平方向）进行缩放，相当于scale(sx, 1)。 如，transform: scaleX (2)，表示将元素在 x 轴方向放大 2 倍，在 y 轴方向不进行缩放。 3）scaleY(sy)：只在 y 轴（垂直方向）进行缩放，相当于scale(1, sy)。 如，transform: scaleY (1.5)，表示将元素在 y 轴方向放大1.5 倍，在 x 轴方向不进行缩放。 倾斜倾斜，就是基于变换的原点，让元素绕水平轴或垂直轴倾斜指定的角度，也就是以 x 轴或 y 轴为轴心，让元素倾斜指定的角度。倾斜有三种个变换函数： 1）skew(θx, θy)：在水平方向和垂直方向同时倾斜（即同时绕 x 轴和 y 轴倾斜）。如果未提供 θy，则使用默认值 0。 参数 θx 表示绕 x 轴倾斜的角度，正值表示逆时针倾斜，负值表示顺时针倾斜；参数 θy表示绕 y 轴倾斜的角度，正值表示顺时针倾斜，负值表示逆时针倾斜。注意两个参数的默认倾斜方向不同。 如，transform: skew(30deg, 10deg)，表示元素在 x 轴方向按逆时针倾斜30°，在 y 轴方向按顺时针倾斜10°。 skew() 是一个非常有用的变形函数，它可以将一个元素围绕着 x 轴或 y 轴，按一定角度进行倾斜。它与 rotate() 函数不同，rotate() 函数只是旋转，而不会改变元素的形状，skew() 函数会改变元素的形状。 经过skew() 函数变形之后，元素的形状发生了改变，由原来的矩形，变成了现在的菱形。 2）skewX(θx)：只按 x 轴（水平方向）进行倾斜，相当于 skew(θx, 0)。 如，transform: skewX(30deg)，表示元素在 x 轴方向按逆时针倾斜30°，在 y 轴方向不进行倾斜。 3）skewY(θy)：只按 y 轴（垂直方向）进行倾斜，相当于skew (0, θy)。 如，transform: skewY(10deg)，表示元素在 y 轴方向按逆时针倾斜10°，在 x 轴方向不进行倾斜。 矩阵变换使用 transform 的变换函数 translate()、rotate()、scale()、skew()，让平移、旋转、缩放、倾斜等操作变得很简单，也很方便。 如果要对一个元素同时应用平移、旋转、缩放、倾斜等操作，就需要在 transform属性中指定多个变换函数，函数之间用空格分开。 为了方便，CSS提供了矩阵函数 matrix()，只需一个函数，就可以对元素同时应用多个变换函数。 2D变换矩阵是一个 3×3 的矩阵，共有6个参数，其格式为 matrix(a, b, c, d, e, f)，这些参数对应的矩阵为： CSS变换矩阵 简单的讲，matrix() 函数就表示，使用 a, b, c, d, e, f 这6个参数所构成的 3×3 的变换矩阵，通过矩阵乘法，来实现一个2D变换。变换规则如下： CSS矩阵变换规则 其中，x、y是元素初始原点的坐标，x’ 、y’ 是变换后得到新原点的坐标。简化后，上述矩阵乘法运算得到的公式为： x’ = ax + cy + e y’ = bx + dy + f 根据上面的公式，使用不同的变换矩阵，就可以得到不同的变换效果。也就是说，只需为 a, b, c, d, e, f 提供特定的值，translate()、rotate()、scale()、skew() 这些变换函数，都可以通过矩阵函数 matrix() 实现。不同变换函数所对应的 matrix() 函数为： translate(tx, ty)：对应matrix(1, 0, 0, 1, tx, ty)。 scale(sx, sy)：对应matrix(sx, 0, 0, sy, 0, 0)。 rotate(θ)：对应matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)。 skew(θx, θy)：对应matrix(1, tan(θy), tan(θx), 1, 0, 0)。 说明：改变变换的原点默认情况下，transform 所进行的 translate、rotate、scale、skew、matrix 等操作，都是以元素自身的中心点进行的。但很多时候，需要在不同的位置执行变换操作。这时，就可以通过 transform-origin 属性改变变换原点的位置，改变原点后，所有变换操作都将参考新原点进行。transform-origin的语法格式为：transform-origin: (ox, oy)其中，参数 ox 表示 x 轴的原点位置，参数 oy 表示 y 轴的原点位置。ox 和oy 的值可以是长度值、或百分比、或预定义值，数值允许负值。x 轴预定义值有 left（左边）、center（中间）、right（右边），y 轴预定义值有top（顶部）、center（中间）、bottom（底部）。如果未提供 oy 的值，则使用默认值 50%。如，transform-origin: (left, top)，水平方向上的原点为元素的左边，垂直方向上的原点为元素的顶部，即新基点为元素的左上角。如，transform-origin: (right)，水平方向上的原点为元素的右边，垂直方向上的原点为元素50%的位置。如，transform-origin: (25%, 75%)，水平方向上的原点为元素25%的位置，垂直方向上的原点为元素75%的位置。 8.2 过渡在给超链接设置样式时，一般都会设置一个悬停状态（hover）的效果，这种方法能明显提醒用户他的鼠标指向的是一个超链接。此时，悬停状态就相当于一个开关，在鼠标悬停时，会立即从默认状态切换到另一种状态。 但很多时候，人们并不希望元素立即从一种状态切换到另一种状态，而是希望以动画方式，从一种状态平滑过渡到另一种状态。此时，就可以使用CSS3的过渡（transition），来实现状态的平滑过渡。 W3C标准中，对 transition 的描述是“CSS的 transition 允许CSS的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。” CSS3中，使用 transition属性来定义元素样式变换时的过渡效果。语法格式为：1234transition：[transition-property] || [transition-duration] || [transition-timing-function] || [transition-delay] 也就是说，transition 是一个复合属性，可分解为 transition-property、transition-duration、transition-delay 和 transition-timing-function 这 4 个独立的属性，下面分别进行介绍。 transition-propertytransition-property属性指定当元素的哪些属性的值发生改变时，会以过渡的形式呈现。其值可以是 none | all | IDENT，默认值是 all。 none 表示没有任何属性；all 表示所有可过渡的属性；IDENT 表示指定CSS属性名称列表，列表以逗号分隔，只有出现在列表中的属性，才允许以过渡形式呈现。如：1transition-property: width, background-color, transform 表示当 width, background-color, transform 这 3 个属性中，任意一个属性的值发生改变时，会以过渡的形式呈现。 transition-durationtransition-duration属性规定一个过渡从开始到结束所持续的时间，默认值为 0s。接受秒或毫秒的值，如 2s、.3s、300ms。如果省略该属性，则定义的 transition-* 属性均无效，不会产生过渡效果。 transition-duration属性可用于任何元素，包括 :before 和 :after 伪元素。当一个元素的 transition-property属性指定多个过渡属性时，transition-duration属性也可以指定多个值，值之间用逗号分隔。并且，多个属性不必步调一致，即多个过渡属性的持续时间不必相同。如：12345.transition &#123; ...... transition-property: border, color, text-shadow; transition-duration: 2s, 3s, 8s;&#125; 此处，通过 transition-property属性指定只过渡 border、color、text-shadow 这 3 个属性，然后在 transition-duration属性中，设定边框过渡效果应该在 2 秒内完成，文本颜色 3 秒内完成，文本阴影 8 秒内完成。 如果同时设置多个过渡属性时，如果这些过渡属性的持续时间相同，就没有必要为每个属性设置一个过渡持续时间，只需给transition-duration属性设置一个值，这个值将用于所有的过渡属性。 transition-delaytransition-delay属性规定在过渡开始之前的等待时间，默认值为0s，表示不需要等待。接受秒或毫秒的值。如果不需要等待，可以省略该属性。 transition-timing-functiontransition-timing-function属性用来规定过渡期间的速度如何变化，其值是 cubic-bezier 函数、或 steps 函数、或预定义关键字。 1）cubic-bezier函数 cubic-bezier 表示三次方贝赛尔曲线，它由 4 个控制点 P0、P1、P2、P3 来控制曲线的形状。每个控制点由坐标 (x, y) 来确定。P0 总是 (0, 0)，P3 总是 (1.0, 1.0)，P1和P2点则由 cubic-bezier 函数的四个参数来定义。 cubic-bezier (x1, y1, x2, y2) 函数中，(x1, y1) 代表P1点，(x2, y2) 代表P2点，x1, y1, x2, y2 的值都必须在 [0, 1.0] 区间内，否则无效。 2） steps函数 steps 函数用来实现分步过渡的动画效果，即阶梯式过渡，而非平滑过渡。其格式如下： steps(n, [ start | end ] ]?) 其中，第一个参数 n 是一个自然数，意思是把一个动画的持续时间划分为 n 个相同的间隔，并在固定的间隔播放动画，直到走完整个动画；第二个参数可选，接受 start 和 end 两个值，指定在每个计时周期的起点或是终点发生跃变，默认值为 end。 当指定的跃变点为 start 时，动画在每个计时周期的起点发生跃变（即图中空心圆变为实心圆 ）；当指定的跃变点为 end，动画在每个计时周期的终点发生跃变。 假如一个过渡的 transition-duration属性被设置为 2s，则它的计时周期就是 2 秒。以鼠标悬停为例，在 steps(1, start) 时，跃变点为 start，鼠标悬停会立即触发样式的变化；在 steps(1, end) 时，跃变点为 end，鼠标悬停后，还要等待 2 秒，才会触发样式的变化。 3） 预定义关键字 预定义关键字有 ease | linear | ease-in | ease-out | ease-in-out | step-start | step-end，默认值为 ease。各关键字的含义见表 关键字 含义 ease 逐渐变慢，相当于cubic-bezier(0.25, 0.1, 0.25, 1) linear 匀速过渡，相当于cubic-bezier(0, 0, 1, 1) ease-in 由慢到快，相当于cubic-bezier(0.42, 0, 1, 1) ease-out 由快到慢，相当于cubic-bezier(0, 0, 0.58, 1) ease-in-out 由慢到快再到慢，相当于cubic-bezier(0.42, 0, 0.58, 1) step-start 相当于steps(1, start) step-end 相当于steps(1, end) 实现过渡效果时，要在过渡效果开始的选择器中定义 transition-* 属性和初始样式，在触发过渡的选择器中定义目标样式。这样，当 transition-property属性中定义的任意属性的属性值发生改变时，就会触发 transition 效果。 下面通过一个简单实例，来说明 transition属性的使用方法。如，有一个100 px * 100px的盒子，当鼠标悬停到该盒子时，要求盒子在 2 秒内旋转360°，动画由慢到快再到慢。CSS代码如下：1234567891011.transition &#123; width: 100px; height: 100px; background: #92b901; transition-duration: 2s; transition-property: transform; transition-timing-function: ease-in-out;&#125;.transition:hover &#123; transform: rotate(360deg);&#125; 上述代码中，在过渡效果开始的选择器 .transition 定义过渡相关的属性和初始样式，在触发过渡的选择器 .transition:hover 中定义目标样式。由于初始样式中未定义 transform 属性，故使用默认值 none，当鼠标悬停到元素时，元素的 transform 属性的值发生改变，由初始的 none 变为最终的 rotate(360deg)。所以，元素的 transform 属性就触发了 transition 效果。 需要注意的是，只有当CSS属性的“属性值”发生改变时，才会触发过渡效果，而“元素外观”的改变，是不会触发过渡效果的。如，设定元素的宽度为百分比，在改变浏览器大小，元素大小改变时，并不会触发过渡效果。 说明：如果transition-property属性为CSS属性列表，则定义 transition-duration、transition-delay、transition-timing-function属性时，就需要提供多个值，以逗号分隔，每个值与 transition-property属性中的每个值按顺序对应。如：12transition-property: background-color width;transition-duration: 1.5s 2s; 上述代码表示，background-color属性动画的持续时间为1.5秒，width属性动画的持续时间为2秒。 8.3 动画在CSS3中，通过 animation 属性来定义动画。虽然 transition 也可以实现从一种状态到另一种状态的动画效果，但它只能控制开始和结束的两个点，功能非常有限。而 animation 除了能控制开始和结束的两个点外，还能通过关键帧来控制动画的每一步，可以实现更为复杂的动画效果。 CSS3中，animation 实现的动画由两个部分组成：首先，使用关键帧 @keyframes 来声明一个动画；然后，在 animation属性中，调用关键帧声明的动画。 简单的说，就是在 keyframes 中定义动画效果，再由 animation 的相关属性来控制动画的播放，接下来分别进行介绍。 8.3.1 关键帧在CSS3中，把 @keyframes 称作关键帧，并使用 @keyframes 来定义动画每一帧的效果，即定义由当前样式逐渐改变为新样式的动画效果。 @keyframes 有自己的语法规则，它由 @keyframes 开头，后面紧跟动画名称和一对大括号，在大括号中定义每个帧的样式规则：123@keyframes &lt;identifier&gt; &#123; &lt;keyframes-blocks&gt;&#125; identifier 表示动画的名称，它将被动画的 animation-name 属性引用，来实现动画和元素的关联。动画可以使用任何名称，但考虑到动画可以在多个元素上复用，尽量取一个合理的、能望文生义的名称。 keyframes-blocks 定义动画每个帧的样式规则，样式规则是由多个百分比构成，在每个百分比中定义该帧的样式规则，从而实现从一种状态到另一种状态的动画效果。样式规则中的百分比，可以看做是每一帧在动画时间轴上的位置，0% 为时间轴的起点，100% 为时间轴的终点。 由此可知，使用 @keyframes 声明一个动画的语法规则为：外，在声明关键帧时，0% 可以用 from 代替，100% 可以用 to 代替。如：1234567891011@keyframes &lt;identifier&gt; &#123; from &#123; /* CSS样式 */ &#125; percentage &#123; /* CSS样式 */ &#125; to &#123; /* CSS样式 */ &#125;&#125; 接下来，看看一个由W3C提供的实例：1234567891011121314@keyframes wobble &#123; 0% &#123; left: 100px; &#125; 40% &#123; left: 150px; &#125; 60% &#123; left: 75px; &#125; 100% &#123; left: 100px; &#125;&#125; 上述代码定义了一个名称为 wobble 的动画，它从 0% 开始，到 100% 结束，中间还经历了40% 和 60% 两个过程。也就是说，名称为 wobble 的动画共有四个关键帧，来实现以下动画效果： 1）在0%（第一帧）时，元素的定位到 left 为100px 的位置； 2）在40%（第二帧）时，元素的过渡到 left 为150px 的位置； 3）在60%（第三帧）时，元素的过渡到 left 为75px 的位置； 4）在100%（第四帧）时，元素的又回到 left 为100px 的起点位置。 事实上，关键帧的写法相当自由，它不必以 0% 开始、100% 结束，也可以省略某个中间状态，浏览器会自动推算，进行平滑播放。就连关键帧的声明顺序，也可以随意书写，因为播放动画上，关键帧的顺序是由百分比决定，而不是由声明顺序决定。还可以将多个状态写在一起，如from，to { transform: none; }，它就表示 from 和 to 这两个关键帧应用了相同的样式。 但需要注意的是，不能省略百分比中的百分号，即 0% 不能写成 0，100% 也不能写成1。否则，将导致整个动画的声明无效，不会产生动画效果。 8.3.2 动画@keyframes只是用来声明一个动画，而动画本身并不执行任何操作。因此，如果希望为某个元素应用动画，还需要把动画与该元素关联起来。 如果一个动画没有与任何元素关联，它就不会被调用，也就不会产生动画效果。动画与元素关联后，在整个动画过程中，元素的样式将完全由 animation属性来控制，关键帧中后面的样式，会覆盖前面的样式。CSS3动画，就是通过样式的不断变化得以实现的。 在CSS3中，使用 animation属性来实现动画与元素的关联，并由 animation 相关的属性来控制动画的整个播放过程。其语法格式为：12345678animation：[animation-name] || [animation-duration] || [animation-timing-function] || [animation-iteration-count] || [animation-direction] || [animation-play-state] || [animation-delay] || [animation-fill-mode] 也就是说，animation 是一个复合属性，可分解为 animation-name、animation-duration、animation-timing-function、animation-iteration-count、animation-direction、animation-play-state、animation-delay、animation-fill-mode 这 8 个独立的属性，下面分别进行介绍。 animation-nameanimation-name属性指定所要关联的动画名称，其作用是让元素调用由@keyframes所定义的动画。如果省略该属性，则使用默认值 none，将没有任何动画效果。 一个元素可以关联一个或多个动画名称，如果关联多个动画，就需要指定多个动画名称，中间以逗号进行分隔。如：123.demo &#123; animation-name：wobble；&#125; 上述代码就表示，将@keyframes wobble所定义的动画与 class=”demo” 的元素相关联，该元素将调用名称为 wobble 的动画。 animation-durationanimation-duration属性规定动画从开始到结束所持续的时间，默认值为 0s。接受秒或毫秒的值。如果省略该属性，则定义的 animation -* 属性均无效，不会产生动画效果。 animation-timing-functionanimation-timing-function属性指定动画期间速度如何变化，与 transition-timing-function 属性的取值相同，请参阅。 animation-iteration-countanimation-iteration-count属性指定动画的迭代次数，取值为 infinite | ，默认值为 1。动画单向遍历一次关键帧的过程，称作一次迭代。 一般情况下，一个动画会有两个状态：默认状态和迭代状态。页面初始加载完成后，元素进入迭代之前的状态，称作默认状态；而元素进入迭代之后的状态，被称作迭代状态。 当取值为 0 时，不发生迭代；当取值为 1 时，仅发生一次迭代；当取值大于 1 时，发生多次迭代；当取值为 infinite 时，会发生无穷次迭代。 注意：animation-iteration-count属性取值为 0 与没有动画完全不同。当属性设置为 0 时，动画依然有效，也会被播放，只是元素从默认状态进入到迭代状态后，发现迭代次数为 0，动画会停止在迭代开始时的状态而已。没有动画时，元素始终保持在默认状态，不会进入迭代状态。 animation-directionanimation-direction属性定义在某些迭代或所有迭代中的播放方向。可选值有 normal | reverse | alternate | alternate-reverse，默认值为 normal。当 animation-iteration-count属性设置为 1 时，alternate 和 alternate-reverse 为无效值。 1） normal 表示正向播放，即每个迭代都正向播放。正向播放从关键帧的 from 开始，到 to 结束。 2） reverse 表示逆向播放，即每个迭代都逆向播放。逆向播放从关键帧的 to 开始，到 from 结束。 3） alternate 表示正向交替播放，即以正向播放开始，首尾相接，循环播放。其结果是第 n 次迭代正向播放，第 n+1 次迭代逆向播放（n 从 1 开始）。 4） alternate-reverse 表示逆向交替播放，即以逆向播放开始，首尾相接，循环播放。其结果是第 n 次迭代逆向播放，第 n+1 次迭代正向播放。 animation-play-stateanimation-play-state属性用来控制动画的播放状态，取值 running 或 paused，默认值为 running。 可以通过paused将正在播放的动画暂停下来，也可以通过 running 让暂停的动画从暂停的位置重新播放。 animation-delayanimation-delay属性定义在动画开始之前的等待时间，默认值为 0s，表示不需要等待。接受秒或毫秒的值。如果不需要等待，可以省略该属性。 animation-fill-modeanimation-fill-mode属性定义动画在处于执行之外的时间期间，即动画播放结束后、或被延迟播放期间，元素所应用的样式。可选值有 none | forwards | backwards | both，默认值为 none。不同取值的含义见表 属性值 含义 none 始终应用默认样式，即页面初始加载完成后，还未进入迭代前的样式 backwards 表示后退，即后退到动画第一个迭代开始时的样式。被延迟的动画，延迟期间应用第一个迭代开始时的样式。播放方向为normal或alternate的动画，应用from帧的状态（若未定义from帧，则应用默认样式）；播放方向为reverse或alternate-reverse的动画，应用to帧的样式 forwards 表示前进，即前进到动画结束时的样式。被延迟的动画，延迟期间应用默认状态的样式；被播放的动画，播放结束后，应用结束状态的样式。正向播放时，应用from帧的样式（若未定义from帧，则为默认样式）；逆向播放时，应用to帧的样式 both 同时遵循forwards和backwards的规则，在两个方向上扩展动画属性。即动画开始之前，应用backwards规则；动画结束之后，应用forwards规则 布局使用CSS ，可以创建各种各样的布局，布局设计是Web应用中非常重要的一部分。在CSS2中，页面布局的手段非常有限，只能通过普通流、浮动和定位元素来进行布局控制。 为了顺应时代发展，CSS3新增了多种布局特性，包括多列布局、弹性布局盒模型。多列布局可以轻松实现类似报纸、杂志一样的排版效果，而无需任何额外的标签另外，框的布局还会受到一些外部信息的控制，如，在响应式布局中，改变视口大小时，框的布局可能会随之进行调整。 9.1 基本布局类型Web设计师注定要处理很多未知的东西，如访问者使用哪一种浏览器，访问者的显示器尺寸是多少，等等。但是，设计师面临的最大问题，可能是要针对不同的显示器尺寸来创建引人入胜的设计。 针对这个问题，提出了三种基本的布局类型，分别是固定布局、流式布局和弹性布局。那到底是选择固定布局，还是流动布局，还是弹性布局？这个问题已经困扰了网页设计师们很多年了。最后的选择往往取决于需求，应该是哪种布局更适合，而不是哪种布局更简单。 由于每种布局都有各己的优点和缺点，需要设计师综合考虑各种因素，并通过恰当的设计，充分利用不同布局的优点，来实现完美的布局。在实际应用中，常常是组合使用这几种布局，而不是单独使用某一种布局。 9.1.1 固定布局固定布局，就是页面上所有元素的宽度都以像素为单位，不管设备屏幕及浏览器宽度是多少，都使用同一套尺寸进行布局，得到的布局结果也完全相同。 在早期Web刚刚兴起的时候，屏幕的分辨率相对稳定，基本都是 800 600 和 1024 768，固定宽度的布局就很合适。 由于已经知道每个元素的精确宽度，也知道所有元素的具体位置，实现起来相对容易。因此，固定布局是匹配固定像素尺寸显示器的最简单方法。 但是，固定宽度的布局对部分访问者可能造成不便。因为所有元素的宽度都是固定的，无论窗口尺寸有多大，它们的尺寸总是不变。对使用大显示器的用户，无法充分利用空间，浪费了原本可以显示更多精彩内容的空间；对使用小显示器的用户，又会导致出现水平滚动条，他们不得不把页面滚动到最右边，才能看到所有的内容，给阅读带来不便。 随着移动终端的兴起，屏幕尺寸范围越来越大，固定宽度的布局越来越无法适应灵活多变的 Web 应用。因此，固定宽度的布局经不起未来的考验，将慢慢淡出人们的视野。 9.1.2 流式布局在移动终端兴起的时代，可以预见的是，未来还会涌现出更多大小不一的屏幕，人们需要一种灵活的、能够适应未知设备的方法，使得我们的设计在所有屏幕中都能完美显示，这就催生了流式布局。 使用流式布局时，尺寸不再使用像素，而是使用百分百进行设置。这种布局可以自适应用户的分辨率，并根据浏览器窗口尺寸自由伸缩，非常高效的利用空间。当浏览器窗口变大，元素的尺寸会变宽，当浏览器窗口变小，元素的尺寸也会跟着变小。页面周围的空白区域在所有分辨率和浏览器下都是相同的，在视觉上更美观。如果设计良好，流式布局可以避免在小分辨率下出现水平滚动条。 使用百分比布局后，页面就能根据窗口尺寸自由伸缩，高效利用空间。但是，流式布局也不是没有问题。在浏览器窗口变得很小时，元素的会变得很窄，很难阅读。因此，常常需要添加以 px 或 em 为单位的 min-width，以防止布局变得太窄。但是，如果 min-width 设置的太大，流式布局的灵活性就会大打折扣。 与之相反，在超大显示器上，这种设计看起来可能宽得可笑，文本行就变得太长，阅读起来非常困难。可以采取几个措施来避免这个问题。首先，元素只跨越窗口宽度的一部分，比如90%，而不是整个浏览器窗口。其次，可以使用百分比为元素设置内边距和外边距，这样的话，内边距和外边距宽度将随窗口尺寸而变化，防止设计变得过宽。再次，可以使用媒体查询，针对不同的窗口尺寸，为元素设置不同的宽度。最后，对于非常严重的情况，可以使用 max-width 属性，为最外层的容器设置最大宽度，以防止页面无限制的扩张。 9.1.3 弹性布局虽然流式布局可以充分利用可用空间，但是，在高分辨率的屏幕上，行仍然会过长，让用户不舒服。相反，在低分辨率的屏幕上，或增加文本的字体大小时，行又变得非常短，内容很零碎。对于这个问题，弹性布局可能是一种解决方案。 弹性布局实际上是一种尺寸比较灵活的固定宽度设计，页面上的所有元素都使用 em 单位值来设置元素的宽度，而不是浏览器窗口宽度。当浏览器的字号发生改变时，em 值也会随之改变，因此，设计的宽度最终取决于浏览器的基准字号，可以确保在字体大小增大时，整个布局会随之变大。 当然，弹性布局也有与固定宽度布局类似的问题。如，不能充分利用可用空间，增大字号后导致出现水平滚动条等问题。 9.2 多列布局在CSS3之前，要让Web页面像报纸、杂志的排版一样，呈现多列布局，你必须将内容拆分到不同的标签中，然后分别设定样式，或者使用浮动和绝对定位，或者使用JS脚本等，并且实现起来也很困难。 CSS3新增了多列布局特性，彻底改变了这样的局面，这种新语法能够让页面内容轻松地分布到多列网格中，实现类似报纸、杂志一样的排版效果，而无需任何额外的标签。 多列布局相关的核心属性包括列宽和列数、列间隙和边框、分列符、跨列、填充列等，下面分别进行介绍。 9.2.1 多列布局在多列布局中，可以通过 columns属性设定列的具体宽度或列的数目，使内容分布到多列网格中，用来实现多列布局的效果。语法格式为：1columns：[column-width ] || [ column-count ] 也就是说，columns属性可以分解为 column-width 和 column-count 这 2 个独立的属性，下面分别进行介绍。 column-width如果想使用固定宽度的列，就可以使用 column-width属性来设置每列的列宽，取值为 &lt;length&gt; | auto，默认为 auto。auto 表示元素多列的列宽将由其它属性（如，column-count属性）决定；&lt;length&gt;表示使用长度值来设置元素的最佳列宽，不允许负值。 假设有一个 div 容器，容器中包含一些内容。HTML代码如下：1234&lt;div&gt;&lt;p&gt;在CSS3之前，要…实现起来也很困难。&lt;/p&gt;&lt;p&gt;CSS3多列布局的出现，彻底改变…分布到多列网格中。&lt;/p&gt;&lt;/div&gt; 接下来的多列布局实例，都将使用上述结构。为了方便查看效果，为容器设置固定宽度，并添加了 1px 的浅黑色边框：1234div &#123; width: 450px; border: 1px solid #444;&#125; 如果将 column-width属性设置为固定的长度值，则在内容的宽度超过该值时，浏览器就会自动以多列进行布局。目前为止，还没有任何浏览器支持多列布局相关的属性，需要使用浏览器私有属性（下同）。如：1234div &#123; … -webkit-column-width: 10em;&#125; 按照上述设定，容器中的内容将会分布在宽度为 10em 的列中。并且，在窗口尺寸发生变化的过程中，浏览器会自动根据列框，来调整列的数目。 然而，根据W3C标准，column-width属性值实际上是给浏览器建议的最佳宽度，实际的列宽可以根据容器空间的大小进行调整。调整规则如下： 1）当容器可用空间足够大时，实际的列宽可能大于所设置的列宽。如：1234div &#123; … -webkit-column-width: 300px;&#125; 上述代码中，容器的宽度是 450px，而设置的列宽是 300px。此时，内容将自动填满整个容器的宽度，实际的列宽将是 450px，而不是 300px。 虽然容器可用空间足够大，但还是无法按两列进行布局，所以就会把列宽扩展到容器的宽度，整个容器就只有一列，而不是多列。 2）当容器的宽度小于设置的列宽时，将以容器的宽度作为列宽。如：1234div &#123; width: 200px; -webkit-column-width: 300px;&#125; 上述代码中，容器的宽度是200px，而设置的列宽是300px。此时，实际的列宽将是容器的宽度 200px。 虽然设置的列宽大于元素容器的宽度，但并不会让元素内容按列的宽度进行布局，它只能把列宽压缩到容器的宽度。 column-count如果希望列的数目保持不变，而让浏览器根据窗口的尺寸自动调整列宽，就可以使用 column-count属性来设置列数，取值为 &lt;integer&gt; | auto，默认为 auto。auto 表示列数由浏览器自动计算；integer 表示建议的最佳列数，取值为大于 0 的整数。如果同时指定了列数和列宽，则 column-count 表示最大列数。如：1234div &#123; … -webkit-column-count: 3;&#125; 在多列容器中，浏览器会自动按照指定的列数，一列一列进行填充。上述代码表示，按 3列将内容填充到容器中。 给多列容器指定列数后，在窗口尺寸发生变化时，浏览器会根据列数和容器宽度，自动计算出每列的宽度，以保证按照 3 列进行布局。 9.2.2 列间隙和边框多列布局之后，通过 column-gap属性和 column-rule属性来设置相邻两列之间的间隙及边框的样式，column-rule 会出现在列间隙的中间位置，column-gap 和 column-rule 的高度等于列的高度。 column-gapcolumn-gap属性用来设置相邻两列之间间隙的宽度，取值为 &lt;length&gt; | normal，默认为 normal。normal 表示其值由所设置的 font-size 来确定，就相当于 1em；长度值表示间隙的宽度，不允许负值。如：1234div &#123; -webkit-column-count: 2; -webkit-column-gap: 100px;&#125; 上述代码中，容器的宽度是 450px，列间隙的宽度是 100px，按两列进行布局，每列的宽度 =（450px - 100px）/ 2 = 175px。 column-rulecolumn-rule属性用来定义列与列之间分割线的样式，包括分割线的颜色、样式、宽度。其语法格式为：1column-rule: &lt;column-rule-width&gt; || &lt;column-rule-style&gt; || &lt;column-rule-color&gt; 也就是说，column-rule属性可以分解为 column-rule-width、column-rule-style、column-rule-color 这 3 个独立的属性。各属性的含义见表 属性 含义 column-rule-width 用来设置列分割线的宽度，与borde-width属性取值相同，请参阅。如果 column-rule-style属性设置为 none，则忽略该属性 column-rule-style 用来设置列分割线的样式，与borde-style属性取值相同，请参阅。如果 column-rule-width属性等于 0，则忽略该属性 column-rule-color 用来设置列分割线的颜色，与borde-color属性取值相同，请参阅。如果 column-rule-width属性等于 0 或 column-rule-style属性设置为 none，则忽略该属性 增加列间隙和分割线可以有效区分各列，使列之间界限清晰可见，泾渭分明。如：12345div &#123; -webkit-column-count: 3; -webkit-column-gap: 20px; -webkit-column-rule: 1px solid #ccc;&#125; 上述代码中，列间隙的宽度为 20px，而为每列之间定义一个1px宽的灰色分割线。 设置列分割线的目的是有效区分各列，但分割线不会占据任何空间位置，改变其宽度并不会影响列的位置。当分割线的宽度大于列间隙的宽度时，分割线将会和相邻的列重叠，成为列的背景。如果把上述列分割线的宽度改为50px，列边框的宽度大于列间隙的宽度时，列边框和相邻的列重叠，成为列的背景，但并未对列的位置产生任何影响。 9.2.3 跨列默认情况下，多列容器中的内容，会一列一列地自动填充。但有时候，却需要其中的某些内容（如，文章标题）不是多列布局，而是横跨所有列。 要实现类似报纸、杂志上的跨列效果，就可以使用 column-span属性，来控制多列容器中的某个子元素是否横跨所有列，取值为 none | all。none 表示不跨列，all 表示横跨所有列。 如，在上述结构中增加一个 h2 标题和若干个段落，为了节省篇幅，用（…）代替略去的内容：123456&lt;div&gt;&lt;p&gt;在CSS3之前，要…实现起来也很困难。&lt;/p&gt;&lt;p&gt;CSS3多列布局的出现，彻底改变…分布到多列网格中。&lt;/p&gt;&lt;h2&gt;跨列&lt;/h2&gt;&lt;p&gt;从前面的介绍可知，多列容器中…就需要用到column-span属性。&lt;/p&gt;&lt;/div&gt; 如果希望 h2 标题能够横跨所有列，而不使用多列布局，就需要把 column-span属性的值显式设置为 all：12345678910div &#123; -webkit-column-count: 3;&#125;div p &#123; text-indent: 2em;&#125;div h2 &#123; background: #ccc; -webkit-column-span: all;&#125; h2 标题将文章的内容分成了相互独立的两个部分，每部分依然是一个 3 列布局，而 h2 标题独自横跨三列。 9.2.4 列的填充方式在多列容器中，如果显式设置了容器的高度，往往会由于内容不足，而导致最后面的列没有内容填充，就会出现各列高度不一致的情况。 这种情况下，就可以通过 column-fill属性来控制各列内容的填充方式，可选值为 auto | balance。balance 表示各列的内容均衡填充，auto 表示各列的内容自动填充。 由于多列布局还没有成为正式标准，各浏览器的默认填充方式也没有得到统一。Firefox 浏览器默认是均衡填充，而其他浏览器默认是自动填充。假设为上述容器显式设置高度：123div &#123; height: 140px;&#125; 在Firefox 浏览器中，当 column-fill属性取值 balance时，每一列所填充的内容量相等，其结果是所有列的高度相等，但不会超过容器的高度。这种情况下，当内容不能填满整个容器时，空白区域分布在容器的底部。 目前为止，column-fill属性仅得到 Firefox 浏览器的支持，并且需要添加浏览器私有前缀。如果希望 Firefox与其他浏览器的表现相同，即自动填充，则需要将 column-fill属性显式设置为 auto：1234div &#123; … -moz-column-fill: auto;&#125; 此时，在Firefox 及其他浏览器中的运行结果相同。当 column-fill属性取值 auto 时，浏览器会按容器的高度自动填充每列的内容，先填充第1列，再填充第2列，依次类推，直到内容全部填充完成。自动填充时，当内容不能填满整个容器时，空白区域分布在最后一列的末尾。 9.3 弹性布局盒模型Web 应用中，布局设计是非常重要的一部分。随着响应式设计的盛行，一般都要求 Web 应用能够适配不同尺寸的设备。响应式设计中最重要的一环就是布局，需要根据窗口尺寸来调整布局，从而改变元素的尺寸和位置，以达到最佳的显示效果，这也使得布局的逻辑变得更加复杂。 CSS3中，提出了弹性布局盒模型（Flex Layout Box Model），它一种全新的布局方式，其目的是提供一种更加高效的方式，来对容器中的子元素进行布局、对齐和分配空间。开发人员只需声明布局应该具有的行为，而不需要给出具体的实现方式，浏览器会自动完成实际的布局，即便子元素的尺寸未知的或动态改变的，布局也能正常工作。 9.3.1 基本概念把一个元素的 display 属性的值显式地设置为 flex 或 inline-flex，该元素就成为一个弹性容器（flex container）。弹性容器会为其内容创建弹性格式化上下文，其中的所有子元素就会按弹性布局模型进行布局。相应的，弹性容器的所有子元素就称作弹性子元素（flex items）。 在传统的布局方式中，块级元素从上到下依次垂直排列，行内元素在一行内从左到右依次水平排列。 弹性盒布局并没有这种内在的方向限制，可以由开发人员自由操作。但是，默认情况下，弹性容器中的子元素也是采用从上到下、从左到右的排列方式。 在弹性容器内有两个弹性子元素。其中，最外围的灰色边框，就表示弹性容器；编号 1 和 2 的灰色边框，就表示弹性子元素。 弹性容器有两个轴，一个称为主轴（main axis），另一个称为侧轴（cross axis），主轴和侧轴总是互相垂直。弹性容器中的子元素可能是单行，也可能是多行。主轴用来确定每一行内，子元素的排列方向，而侧轴则确定这些行的排列方向。默认情况下，主轴为水平方向，从左向右延伸；侧轴为垂直方向，从上向下延伸。 在主轴方向，子元素总是从主轴起点（main start），向主轴终点（main end）依次排列。侧轴方向，行总是从侧轴起点（cross start），向侧轴终点（cross end）依次排列。 对于弹性子元素，在主轴方向上的尺寸称作主轴尺寸（main size），主轴尺寸对应的属性称作主轴尺寸属性（main size property），在侧轴方向上的尺寸称作侧轴尺寸（cross size），侧轴尺寸对应的属性称作侧轴尺寸属性（cross size property）。实际上，它们指的是 CSS 中的 width 或 height 属性。比如，当主轴是水平方向时，主轴尺寸属性是 width，而 width 的值是主轴尺寸，侧轴尺寸属性是 height，而 height 的值是侧轴尺寸。 9.3.2 建立弹性盒布局弹性盒布局模型中引入了一些新的属性，只要设置好相应属性，盒子就具有弹性，在改变浏览器窗口大小时，盒子大小也会自动发生变化。并且，盒子的大小由浏览器自动计算，使页面布局更加灵活、更加简单，可以很轻松创建自适应浏览器窗口的流式布局。 如，在class = “father” 的父元素中，包含class = “box1”、class = “box2”、class = “box3”三个子元素。HTML代码如下（除非特殊声明，后文都将使用该实例）：12345&lt;div class = \"father\"&gt; &lt;div class = \"box1\"&gt;1&lt;/div&gt; &lt;div class = \"box2\"&gt;2&lt;/div&gt; &lt;div class = \"box3\"&gt;3&lt;/div&gt;&lt;/div&gt; 要使用弹性布局盒模型，实现弹性布局的效果，只需要两步：第一步，开启弹性盒模型；第二步，设置子元素的空间分配比例。 开启弹性盒模型是否开启弹性盒模型，由父元素（即弹性容器，下同）决定。要开启弹性盒模型，只需把父元素的 display 的属性值为 flex 或 inline-flex 即可。如：1234.father &#123; width: 600px; display: flex;&#125; 取值为 flex 时，弹性容器被渲染为块级元素，取值为 inline-flex时，弹性容器被渲染为行内元素。如果把一个浮动或绝对定位元素的 display 属性值设置为 inline-flex，则 display 属性的计算值是 flex。 设置子元素的空间分配比例开启弹性布局盒模型后，所有弹性子元素共享父元素的空间，并按弹性盒进行布局。然后，通过子元素的 flex-grow 属性设置各自的空间分配比例。设置分配比例后，所有子元素根据各自所占用的份额来分配父元素的空间。如：123456789101112.box1 &#123; flex-grow: 2; background: #7f3ffd;&#125;.box2 &#123; flex-grow: 1; background: #ef39d5;&#125;.box3 &#123; flex-grow: 1; background: #1bb9f1;&#125; 上述代码中，box1、box2、box3的 flex-grow 属性值分别是2、1、1，它们把父元素的空间分成了2 + 1 + 1 = 4份。其中，box1占2/4，box2占1/4，box3占1/4。父元素的总宽度是600px，box1分得600×(2/4) = 300px，box2分得600×(1/4) = 150px，box3分得600×(1/4) = 150px。 如果父元素 father 为非固定宽度，则在浏览器窗口大小发生变化时，各个子元素的宽度就会随着按比例发生变化，便体现出弹性布局的优势。 9.3.3 弹性容器的属性为了实现对弹性子元素的灵活控制，在弹性容器上定义了相关属性，通过这些属性来控制主轴的方向、子元素溢出后的行为、子元素的对齐方式等。这些属性见表 属性 说明 flex-direction 定义容器的主轴方向 flex-wrap 定义容器溢出后的行为，即容器溢出后是否换行 flex-flow 复合属性，定义容器的主轴方向和溢出后的行为 align-items 定义单行容器的侧轴对齐方式 justify-content 定义单行容器和多行容器的主轴对齐方式 align-content 定义多行容器的侧轴对齐方式 flex-directionflex-direction属性用来定义主轴的方向，主轴方向确定之后，侧轴的方向也相应确定下来，因为主轴和侧轴总是互相垂直。可选值有 row | row-reverse | column | column-reverse，默认值是 row。不同取值的含义见表 属性值 含义 row 主轴为水平方向。子元素排列顺序与容器的书写模式相关。如果是 ltr，则从左到右排列，如果是 rtl，则从右到坐排列 row-reverse 主轴为水平方向。子元素排列顺序与取值 row 相反 column 主轴为垂直方向。子元素从上到下排列 column-reverse 主轴为垂直方向。子元素从下到上排列 由于主轴方向不同，主轴起点和主轴终点的位置不同。而子元素总是从主轴起点，到主轴终点进行排列。因此，主轴方向就确定了每一行内，子元素的排列方向。 在默认情况下，弹性容器中的子元素是采用从上到下、从左到右的排列方式，这与中文的默认书写模式相同，因此，本章的所有实例都采用这种排列方式。 基于前面的实例，把弹性容器的 flex-direction属性设置为 column 和 column-reverse 后，可以把文档流的默认排列方向，由水平方向改为垂直方向。 flex-wrap默认情况下，弹性盒容器中的子元素会尽量占满主轴方向上的一行。当容器的主轴尺寸不足以容纳所有子元素时，子元素之间就会互相重叠或溢出容器。 可以通过 flex-wrap属性来定义子元素容器溢出后的行为，即当容器的主轴尺寸不足以容纳所有子元素时，子元素是否换行排列到下一行，以及换行后的排列方向。可选值有 nowrap | wrap | wrap-reverse，默认值是 nowrap。不同取值的含义见表 属性值 含义 nowrap 不换行，子元素始终在一行排列 wrap 自动换行，子元素多行排列，下一行的位置与侧轴的方向一致 wrap-reverse 自动换行，子元素多行排列，下一行的位置与侧轴的方向相反 在 flex-wrap属性取值为 nowrap 时，子元素始终在一行排列，容器被称作单行容器；取其他值时，子元素可以在多行排列，容器被称作多行容器。 基于前面的实例，现在把父元素的宽度设置为 140px，子元素的宽度设置为 70px，容器的空间就不足，在一行内无法容纳所有子元素：1234567father &#123; width: 140px; display: flex; &#125;.father &gt; div &#123; width: 70px;&#125; 此时，就需要使用 flex-wrap属性来控制子元素溢出后的行为，当父元素的 flex-wrap属性取值为 nowrap 时，子元素就会根据各自的 flex-shrink属性进行收缩。由于 flex-shrink属性的默认值为 1，所以，3个子元素的收缩比例相同，收缩后的尺寸也相同。当然，如果把某个子元素的 flex-shrink属性值设置为 0，它就不会收缩，子元素就可能溢出到容器的外面。这时候，就可以通过父元素的 overflow 属性，来控制溢出时的处理方式。 当父元素的 flex-wrap属性取值为 wrap 时，box3 就会换到下一行。由于侧轴方向是从上到下，行的排列顺序与侧轴方向相同，即从 cross-start 到 cross-end 排列，故新产生的行就会在其它行的下方。 当父元素的 flex-wrap属性取值为 wrap-reverse 时，则行的排列顺序与侧轴方向相反，即从 cross-end 到 cross-start 排列，新产生的行就会在其它行的上方。 flex-flowflex-flow属性是 flex-direction属性 和 flex-wrap属性的复合属性，用来一次性定义容器的主轴方向和容器溢出后的行为。语法格式为：1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt; 如果希望主轴方向为水平方向，子元素溢出后自动换行，并且下一行的位置与侧轴的方向一致。使用复合属性 flex-flow 的定义如下：12345.father &#123; width: 140px; display: flex; flex-flow: row wrap;&#125; justify-contentjustify-content属性用来定义容器中所有子元素在主轴上的对齐方式，即当容器在主轴方向上有额外的空白空间时，主轴方向上的空白空间如何分布。可选值有 flex-start | flex-end | center | space-between | space-around，默认值为 flex-start。不同取值的含义见表 属性值 含义 flex-start 子元素集中在主轴起点，多余或溢出的空间位于主轴终点 flex-end 子元素集中在主轴终点，多余或溢出的空间位于主轴起点 center 子元素集中在主轴的中央，多余或溢出的空间在两侧平均分配 space-between 第一个子元素在主轴起点、最后一个子元素与父元素的在主轴终点，多余的空间由中间的元素平均分配，并确保两两之间的空白空间相等 space-around 所有子元素平均分配剩余空间，每个子元素的空白在该元素的两侧平均分配。这样，第一个元素前和最后一个元素后的空白空间，是其它元素空白空间的一半 对单行容器和多行容器，该属性均有效。 align-items通过 align-items属性用来定义单行容器中所有子元素在侧轴上的对齐方式，即单行容器在侧轴方向上有额外的空白空间时，侧轴方向上的空白空间如何分布。可选值有 flex-start | flex-end | center | baseline | stretch，默认值为 stretch。不同取值的含义见表 属性值 含义 flex-start 子元素集中在侧轴起点，多余或溢出的空间位于侧轴终点 flex-end 子元素集中在侧轴终点，多余或溢出的空间位于侧轴起点 center 子元素集中在侧轴的中央，多余或溢出的空间在两侧平均分配 baseline 子元素沿着它们的基线对齐，多余或溢出的空间可前可后 stretch 容器空间过剩时，子元素被拉伸到与容器同高；容器空间不足时，子元素保持实际高度 如，在一个弹性容器中，有 5 个子元素。为了方便查看剩余空间的分布情况，为子元素设置不同的高度，让子元素高度参差不齐。代码如下：123456&lt;div class = \"father\"&gt; &lt;div&gt;x&lt;/div&gt; &lt;div&gt;g&lt;/div&gt; &lt;div&gt;a&lt;/div&gt; &lt;div&gt;h&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.father &#123; width: 120px; /* 增加宽度，防止容器过宽 */ height: 100px; /* 增加高度，方便看清垂直方向上的剩余空间 */ border: 1px solid #ef39d5; /* 增加边框，方便看清容器边界 */ display: flex;&#125;.father div:nth-child(1) &#123; font-size: 40px; background: #7f3ffd;&#125;.father div:nth-child(2) &#123; font-size: 70px; background: #ef39d5;&#125;.father div:nth-child(3) &#123; font-size: 30px; background: #1bb9f1;&#125;.father div:nth-child(4) &#123; font-size: 50px; background: #6fb934;&#125; 值得注意的是，当 align-items属性取值为 baseline 时，所有子元素以各自的基线相互对齐，多余的空间可前可后，所有子元素在侧轴方向参差不齐排列。 align-contentalign-content属性用来定义容器中所有子元素在侧轴上的对齐方式，即当容器在侧轴方向上有额外的空白空间时，侧轴方向上的空白空间如何分布。可选值有 flex-start | flex-end | center | space-between | space-around | stretch，默认值为 stretch。不同取值的含义见表 属性值 含义 flex-start 行集中在侧轴起点，多余或溢出的空间位于侧轴终点 flex-end 行集中在侧轴终点，多余或溢出的空间位于侧轴起点 center 行集中在侧轴的中央，多余或溢出的空间在两侧平均分配 space-between 第一行在侧轴起点、最后一个行在侧轴终点，多余的空间由中间的行平均分配，并确保相邻行之间的空白空间相等 space-around 所有行平均分配剩余空间，每行的空白在该行的两侧平均分配。这样，第一行前和最后一行后的空白空间，是其它行空白空间的一半 stretch 拉伸行，并占满剩余空间。剩余空间由所有行平均分配，使得每一行的侧轴尺寸变大 对于单行容器，即当容器的 flex-wrap属性值为 nowrap 时，该属性无效。 9.3.4 弹性子元素的属性弹性布局盒模型的核心，在于弹性容器中子元素的尺寸是弹性的，容器会根据布局的需要，自动调整子元素的尺寸和顺序，并以最佳方式填充所有可用空间。 当容器中有空白空间时，子元素可以扩展，以占据额外的空白空间；当容器中的空间不足时，子元素可以缩小尺寸，以防止超出容器范围。 在弹性布局盒模型中，浏览器会根据子元素的相关属性，来自动调整子元素的尺寸和顺序。这些属性见表 属性 说明 order 定义子元素的排列顺序 flex-grow 定义子元素的拉伸因子，当容器空间过剩时，子元素按比例进行拉伸 flex-shrink 定义子元素的收缩因子，当容器空间不足时，子元素按比例进行收缩 flex-basis 定义为子元素分配的默认空间大小 flex 复合属性，定义子元素的拉伸因子、收缩因子、默认空间大小 align-self 定义子元素自身在侧轴方向上的对齐方式 order属性默认情况下，弹性容器中子元素的排列顺序，取决于它们在HTML代码中的排列顺序，先出现的排在前面。 在弹性布局盒模型中，每个子元素有自己独立的 order属性，用来控制子元素的排列顺序，数值小的排在前面。语法格式为：1order: &lt;integer&gt; order属性的默认值为 0。可以为负值。指定 order 属性后，浏览器将根据 order属性的值，对子元素进行分组，order 值相同的元素属于一组，值小的组排在前面，组内则根据元素在HTML代码中出现的先后顺序，先出现的排在前面。 现在，为三个子元素定义 order属性，取值分别是 2、1、-1，就相当于把所有子元素分为 3 组，每组 1 个元素。CSS代码如下：123456789101112.box1 &#123; order: 2; background: #7f3ffd;&#125;.box2 &#123; order: 1; background: #ef39d5;&#125;.box3 &#123; order: -1; background: #1bb9f1;&#125; 可以看出，box1、box2、box3 的出现顺序与它们在HTML中的定义顺序无关，而是按照 order属性值的大小，数值小的排在前面。 flex-grow属性flex-grow属性用来定义子元素的拉伸因子，当容器有多余的空间时，浏览器把所有子元素的 flex-grow属性值相加，再根据各自在总值中所占的份额，分配容器的多余空间。语法为：1flex-grow: &lt;number&gt; flex-grow属性的默认值为 0。支持整数或小数，不允许负值。如果某个子元素没有定义 flex-grow属性，或将 flex-grow属性显式设置为 0，或定义了固定尺寸，则不再为它分配父元素的多余空间。123456789101112131415161718.father &#123; width: 600px; display: flex;&#125;.father &gt; div &#123; width: 100px;&#125;.box1 &#123; flex-grow: 2; background: #7f3ffd;&#125;.box2 &#123; flex-grow: 1; background: #ef39d5;&#125;.box3 &#123; background: #1bb9f1;&#125; 上述代码中，父元素的宽度是 600px，每个子元素的宽度为 100px，于是，父元素的剩余宽度就变成 600 – 3×100 = 300px。 box1 和box2 定义了 flex-grow属性，box3 未定义。故 box1 和 box2 把剩余空间分成 2 + 1 = 3 份，box1 占 2/3，box2 占 1/3。于是，box1、box2 按 3:1 来分配这 300px，box3 不分配。box1 分得 300×(2/3) = 200px，box2 分得 300×(1/3) = 100px。 最终的结果是，box1 和 box2 在预分配空间的基础上，又分得了剩余空间，而 box3 仅有原本的 100px 而已。 可以看出，box1 的实际宽度为100 + 200 = 300px，box2的实际宽度为100 + 100 = 200px，box3 的实际宽度仍然是 100px。 flex-shrink属性flex-shrink属性定义子元素的收缩因子，当容器空间不足时，浏览器把所有子元素的 flex-shrink属性值相加，再根据各自在总值中所占的份额进行收缩。语法为：1flex-shrink: &lt;number&gt; flex-shrink属性的默认值为 1。不允许负值，0 表示不收缩。如，父元素 father 下有两个子元素 box1、box2。HTML代码如下：1234&lt;div class=\"father\"&gt; &lt;div class=\"box1\"&gt;1&lt;/div&gt; &lt;div class=\"box2\"&gt;2&lt;/div&gt;&lt;/div&gt; CSS代码如下：12345678910111213 .father &#123; width: 600px; display: flex;&#125;.box1 &#123; width: 400px; flex-shrink: 3; background: #7f3ffd;&#125;.box2 &#123; width: 400px; background: #ef39d5;&#125; 上述代码中，父元素的宽度是 600px，每个子元素的宽度是 400px，于是，父元素的宽度不足。为了能够容纳所有子元素，子元素需要收缩，待收缩的宽度为 2×400 – 600 = 200px。 box1 定义了 flex-shrink属性，box2 未定义，box2 的 flex-shrink属性使用默认值 1。box1, box2 把待收缩空间分成 3 + 1 = 4份，box1 占 3/4，box2 占 1/4。于是，box1 和 box2按 3:1 来分配这 200px，box1要收缩 200×(3/4) = 150px，box2 要收缩 200×(1/4) = 50px。 最终的结果是，box1 的实际宽度为 400 – 150 = 250px, box2 的实际宽度为400 – 50 = 350px。 flex-basis属性flex-basis属性用来定义为子元素预留的主轴尺寸。语法为：flex-basis: &lt;length&gt; | auto，默认值为 auto。 取值值为 auto 时，实际使用的值是主轴尺寸属性的值，即 width 或 height 属性的值。如果主轴尺寸属性的值也是 auto，则要根据其内容和 flex-grow属性来分配空间。 取值为长度值时，首先为该元素预留空间，预留后剩余的空间，再分配给所有子元素。这样一来，该元素除了预留空间外，还会分得容器的剩余空间。在父元素的空间有剩余时，该元素分配的空间 = flex-basis + flex-grow；在父元素空间不足时，该元素分配的空间 = flex-basis - flex-shrink。 如，父元素 father 下有两个子元素 box1、box2。HTML代码如下：1234&lt;div class=\"father\"&gt; &lt;div class=\"box1\"&gt;1&lt;/div&gt; &lt;div class=\"box2\"&gt;2&lt;/div&gt;&lt;/div&gt; CSS代码如下：12345678910111213.father &#123; width: 400px; display: flex;&#125;.box1 &#123; flex-grow: 1; flex-basis: 200px; background: #7f3ffd;&#125;.box2 &#123; flex-grow: 1; background: #ef39d5;&#125; 上述代码中，父元素的宽度是 400px。box1 定义了 flex-basis属性，预留了 200px 的空间。而 box2 未定义 flex-basis属性，并未预留空间。这样一来，父元素剩余的空间就变成了 400 – 200 = 200px。 由于 box1, box2 的 flex-grow属性的值都是 1，故由 box1, box2 均分父元素的剩余空间，各分得 100px。最终结果是，box1 的实际宽度为 200 + 100 = 300px, box2 的实际宽度为 100px。 flex属性flex属性是 flex-grow、flex-shrink、flex-basis 这 3 个属性的复合属性，用来定义子元素如何分配父元素的空白空间。语法格式为：1flex: none | [ &lt;&quot;flex-grow&quot;&gt; &lt;&quot;flex-shrink&quot;&gt;? || &lt;&quot;flex-basis&quot;&gt; ] 取值为关键字 none 时，相当于 flex-grow 的值为 0、flex-shrink 的值为 0、flex-basis的值为 auto。也就是说，flex: none 就相当于 flex: 0 0 auto。除此之外，flex属性还可以使用以下常用值： 1） flex: initial，这是 flex属性的初始值，它表示 flex-grow、flex-shrink、flex-basis 这 3 个属性均使用默认值，就相当于flex: 0 1 auto。 2） flex: auto，相当于 flex: 1 1 auto，表示子元素的实际尺寸为 width 或 height 属性的值，并子元素可以根据弹性容器的空间自由伸缩。 3） flex: ，相当于 flex: 1 0%，表示为子元素预留的主轴尺寸为0，并根据设置的比率分配弹性容器的剩余空间。如果一个伸缩容器里的所有项目都使用此模式，则它们按各自指定的伸缩比率分配弹性容器的剩余空间。 align-self属性align-self属性用来定义当容器在侧轴方向上有额外的空白空间时，该子元素如何分配多余的空间，或容器的空间不足时，如何分配溢出的空间。 align-self属性用来覆写容器上 align-items属性，除了 align-items属性的所有可选值外，align-self属性还可以设置为 auto，表示其计算值是弹性容器的 align-items属性值；如果弹性容器未定义 align-items属性，则为 stretch。 9.4 响应式布局在早些时候，为了满足移动用户的需求，需要为移动设备专门建立一个额外的网站。随着响应式设计的出现，这种做法已经越来越少见了。 2010年5月25日，Ethan Marcotte在A List Apart上发表了一篇开创性的文章，在这篇名为Responsive Web Design的文章中，他将媒体查询、弹性网格布局、弹性图片这三种已有的开发技术整合起来，并命名为响应式Web设计（RWD，Responsive Web Design）。 响应式设计的理念是，页面的设计应当根据用户行为及设备环境，进行相应的响应和调整。有了响应式设计，一个网站只需要一个版本便能兼容多个终端，而不必为每个终端制作一个特定的版本，可以大大降低网站的成本。 9.4.1 媒体查询媒体查询（Media Queries）是CSS3中提出的一个新概念，它允许为页面设置不同的媒体条件，并根据条件来应用相应的样式。媒体查询的基本语法为：12media_query: [only | not]? &lt;media_type&gt; [ and expression ]*expression : (media_feature [: value]?) 可以看出，媒体查询主要包括三部分内容，分别是媒体类型（media_type）、媒体特性（media_feature）和关键字。 媒体类型媒体类型（Media Type）是CSS2中就已经存在的一个常见属性，指的就是用户浏览网页的设备，如电脑显示器、打印机、投影设备，甚至盲文触觉反馈设备等。W3C共定义了10种媒体类型见表 属性 说明 all 所有设备 braille 盲文触觉反馈设备 embossed 盲文打印机 handheld 小型或手提设备 print 打印机或显示屏设备上的打印预览模式 projection 投影展示设备，如投影仪、PPT screen 显示屏设备 speech 语音或音频合成器 tty 固定间距的字符栅格设备，如电传打字机和终端 tv 电视类设备 媒体特性媒体特性就是媒体的属性，媒体查询允许针对不同的媒体特性，定义不同的样式。最常用的媒体特性是设备的视口宽度和屏幕宽度，但为了方便查阅，下面列出所有可供查询的媒体特性。 属性 说明 width 设备的视口宽度 height 设备的视口高度 device-width 设备的屏幕宽度 device-height 设备的屏幕高度 orientation 设备目前处于横向还是纵向状态 aspect-ratio 设备视口的宽度和高度的比例。如，16:9的显示屏aspect-ratio:16/9 device-aspect-ratio 设备的宽度和高度的比例 color 设备每种颜色的位数。如，min-color:32会检测设备是否拥有32位颜色 color-index 设备颜色索引表中的颜色值不能是负数。 monochrome 单色帧缓冲区中，每个像素所使用的位数。值不能是负数。 resolution 屏幕或打印机的分辨率。如，min-resolution:300dpi或min-resolution:118dpcm scan 电视机的扫描方式，可以是progressive（逐行扫描）或interlace（隔行扫描） grid 设备是网格的还是位图设备 上表中的所有特性，除 scan 和 grid 外，都带有 min 和 max 前缀，用于表示小于等于和大于等于某个值的情况。 媒体特性用逻辑表达式表示，格式跟CSS样式规则的格式非常相似。一个表达式是一个媒体特性和值对，中间用冒号隔开，每个表达式包裹在一对圆括号中。如：1(max-width: 480px) 一个表达式可以看作是一个提问，上述表达式就相当于在问“你的最大宽度是480px吗？”。由此可知，一个表达式的结果就是一个布尔值。因此，某些媒体特性（如，color、monochrome、grid等）就可以直接用作条件，而无需指定它的值。如，以下语句就表示所有彩色设备：1(color) 如果要同时检测多个特性，可以设置多个表达式，并用关键字 and 连接起来。因此，可以使用 min 和 max 前缀来创建一个查询范围。如：1(min-width: 360px) and (max-width: 480px) 这里对 width 应用了 min 和 max 来设定查询范围，就表示视口宽度介于 360 像素和 480 像素之间。 关键字媒体查询中可以使用的关键字有and、only、not，and主要起连接作用，only 用来限定整个查询结果，not 用对整个查询结果取反。如果使用关键字 not 或 only，必须明确指定一个媒体类型，并且关键字必须位于整个媒体查询语句的开头。 1）and 关键字 and 用来把媒体类型和多个媒体特性的表达式组合起来，合并到同一条媒体查询中。只有当媒体类型和每个表达式的结果都为真时，查询结果才为真。如：1screen and (min-width: 700px) and (orientation: landscape) 媒体查询的结果是一个布尔值：要么为true，要么为false。只有当 and 连接的所有部分都为true，整条媒体查询语句的结果才为 true。 媒体查询也可以看作是对浏览器的提问。上述媒体查询首先会问“你是一块显示器吗？”，如果浏览器回答“是”，会继续问“你的最小宽度为700像素吗？”，如果浏览器回答“是”，再继续问“你的屏幕处于横向状态吗？”。只有当三个提问都回答“是”， 整条媒体查询语句的结果才为 true。 2）only 关键字 only用来限定范围，它将作用于整个查询结果。如：1only screen and (color) 就仅仅对彩色显示屏设备有效，对其他任何设备均无效。它等价于：1not (screen and (color)) 3）not 关键字not用来对整个查询结果取反。如：1not (screen and (monochrome)) 就表示除单色显示屏设备外的所有设备。它等价于：1not (screen and (monochrome)) 而不是：1(not screen) and (monochrome) 除了单个查询外，也可以定义一个媒体查询的列表，列表之间用逗号隔开。如果列表中的任意一个媒体查询的结果为 true，媒体查询的列表的结果就为 true；否则，媒体查询的列表的结果就为 false。 媒体查询列表中的每个查询相互独立，一个查询中的操作符并不影响其它的媒体查询。因此，媒体查询列表能作用于不同的媒体类型和媒体属性。如：1(min-width: 700px), handheld and (orientation: landscape) 上述媒体查询列表中包含两个媒体查询，对于最小宽度为700像素的任何设备，或者横屏的手持设备，媒体查询列表的结果为 true，其他情况均为 false。 有了媒体查询，就可以使用它来构建响应式布局了。有两种使用媒体查询的方法：一种是使用 @media 规则，选择载入不同的CSS代码；一种是使用 &lt;link&gt; 标签的 media 属性，选择加载不同的样式表文件。 1）使用 @media 规则 使用 @media 规则，要在同一个CSS 文件中，根据不同的媒体条件，定义不同的样式。用户浏览网页时，浏览器会根据媒体查询的结果，选择应用哪一段CSS代码。 @media 规则的语法，是在 @media后，紧跟媒体类型和媒体特性，然后是一对大括号，在大括号中定义相应的样式规则。如：123456@media screen and (max-device-width: 480px) &#123; /* 如果设备宽度 &lt;= 480px，将会应用这里的 CSS 代码 */&#125;@media screen and (max-width: 768px) &#123; /* 如果视口宽度 &lt;= 768px，将会应用这里的 CSS 代码 */&#125; 根据样式的层叠性，样式表中后定义的样式，会覆盖前面的相同样式。因此，就可以在样式表的开头定义基本样式，来适应所有的设计，再使用媒体查询重写相应的部分，让不同的媒体条件应用不同的样式规则。 2）使用 &lt;link&gt; 标签的 media 属性 使用 &lt;link&gt; 标签的 media 属性时，针对不同的媒体条件，定义不同的样式表文件，浏览器会根据媒体查询的结果，加载不同的样式表文件。123&lt;link rel=\"stylesheet\" media=\"screen\" href=\"reset.css\"&gt;&lt;link rel=\"stylesheet\" media=\"screen and (max-width: 480px)\" href=\"phone.css\"&gt;&lt;link rel=\"stylesheet\" media=\"screen and (min-width: 768px)\" href=\"screen.css\"&gt; 这里定义了3个样式表文件reset.css、phone.css、screen.css，并让所有的显示屏设备都加载reset.css，让视口宽度小于 480px 的显示屏设备加载phone.css，让视口宽度大于768px的显示屏设备加载screen.css。 可以看出，使用第一种方法，要在同一个CSS 文件中，写好几遍 @media；使用第二种方法，要写好几遍 &lt;link&gt; 标签。两种方法的效果相同，可以选择自己喜欢的方式。 事实上，还可以是CSS的 @import 指令按条件引入其他样式表。如，以下代码对给视口最大宽度为 360px 的显示屏设备加载一个名为 small.css 的样式表文件。1@import url(&quot;small.css&quot;) screen and (max-width: 360px); 但是，使用CSS的 @import 方式会增加HTTP请求，这会影响页面的加载速度，因此并不推荐使用这种方法。 在媒体查询中，把设备宽度的临界点称作断点，并把媒体特性 min-width 和 max-width 对应的属性值称作断点值。 综上所述，媒体查询就是使用断点来创建媒体查询的条件，并为每个断点调用一个样式表文件（或样式代码），来实现在不改变页面内容的情况下，为不同的设备及不同尺寸的设备定制显示效果。 说明：让IE6~8支持媒体查询虽然媒体查询已经被广泛使用，并得到所有现代浏览器的支持，但IE 9以下的老版本浏览器却不支持它。可以选择给老版本的IE添加垫片脚本，让它们支持媒体查询功能。respond.js（https://github.com/scottjehl/Respond）是一个快速、轻量的 Javascript 工具，它会遍历页面上的所有 CSS 引用，并使用媒体查询分析 CSS 规则。然后，监控浏览器宽度的变化，并添加或删除与媒体查询匹配的样式，使原本不支持媒体查询的IE6-8 支持媒体查询的 min-width 和 max-width 特性。respond.js的使用非常简单，只需在页面所有的CSS之后，使用IE条件注释，让IE6-8版本加载 respond.js 脚本即可：123&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;respond.js &quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 但需要注意，respond.js 无法解析CSS的@import指令。因此，建议在已有的样式表中追加媒体查询的样式。如，在样式表文件中，使用 min-width 或 max-width 定义媒体查询：123@media screen and (max-width: 480px) &#123; // 针对视口宽度小于 480px 的显示屏设备定义样式&#125; 9.4.2 弹性网络当页面需要适应各种尺寸的设备时，就应该使用弹性网格，让整个布局结构根据用户行为，以及设备环境进行响应式调整。 弹性网格是一个网格系统，它参考流式布局中网格系统的设计，将每个格子设置为百分比宽度，以便网格的宽度会随时根据浏览器窗口大小做出相应的调整。 那如何将固定宽度的网格系统，转换成弹性网格系统对应的百分比宽度呢？响应式设计之父 Ethan Marcotte 提供了一个简单易行的公式： 目标元素宽度 ÷ 上下文元素宽度 = 百分比宽度 先不要被这个公式吓到，在创建响应式布局时，它很快就会成为你的得力助手。先看看下面的设计，如何把它从固定宽度转换为百分比宽度：123456&lt;body&gt;&lt;div id=\"wrapper\"&gt; &lt;main&gt;&lt;/main&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/div&gt;&lt;/body&gt; 这个页面相对简单，在一个 id = “wrapper” 的容器中，包括主内容区 main 和侧栏 aside两部分。采用固定布局的CSS代码如下：123456789101112#wrapper &#123; margin: 10px auto; width: 1000px;&#125;aside &#123; width: 200px; float: left;&#125;main &#123; width: 780px; float: right;&#125; 上述代码中的所有尺寸，都使用像素值。页面的所有内容都包裹在一个 id = “wrapper” 的div 容器中，div 被设置为居中显示。容器的宽度为1000px，main 和aside 的宽度分别为 780px 和 200px。 要将固定宽度的网格系统，转换成弹性网格系统。首先，以视口的总宽度为基准，把页面容器的宽度转换为百分比宽度。然后，再以容器的宽度为基准，把子元素的固定像素宽度，转换为对应的百分比宽度。 现在，可以使用上面的公式，将固定宽度改成百分比宽度。外层的容器，将以窗口的总宽度为基准，定义其百分比宽度。假设对于宽度为 1024px 的屏幕，套用上面的计算公式，计算百分比宽度： 1000px ÷ 1024px = 97.65625% 得到的准确宽度为97.65625%，这样的话，得到的宽度跟固定宽度将完全相同。当然，你也可以选择 100% 或者 96%，以保证达到最佳的视觉效果。 接下来，再将里层的元素从固定宽度转换为百分比布局，由于 main 和aside 都包裹在#wrapper容器中，此时，main 和 aside 就是目标元素，#wrapper 则是上下文元素。得到 main 的百分比为： 780px ÷ 1000px = 78% 同理，计算出 aside 的百分比为 20%。经过上述一番转换之后，页面的基本结构都变成了百分比布局，相应的CSS代码如下：123456789101112#wrapper &#123; margin: 10px auto; width: 97.65625%;&#125;aside &#123; width: 20%; float: left;&#125;main &#123; width: 78%; float: right;&#125; 如果 main 和 aside 也包含子元素，则使用相同的方法进行计算，只是上下文元素会随之发生改变。对于 main 的子元素，上下文元素就是 main 元素，对于 aside 的子元素，上下文元素就是 aside 元素，依次类推。 9.4.3 弹性图片默认情况下，图像的显示尺寸是 HTML 中指定的 width 和 height 属性值。如果不指定这些属性值，图像就会按原始尺寸显示。当然，还可以在 CSS 中以像素为单位，设置图像的 width 和 height。 在现代浏览器中（包括IE7+）中，只需将图像的 max-width 属性设置为百分数，就可以让图像随着弹性网格自动缩放。如：123img &#123; max-width: 100%;&#125; 这样，如果图片的宽度超过容器的宽度，就自动缩小，而不会撑破容器；如果图片的宽度小于容器的宽度，就按原始尺寸显示。这种机制可以确保图片能够适应各种尺寸的网格，而不会破坏布局。 更进一步，还可以将同样的样式应用到其他多媒体元素，这些多媒体元素就可以适应各种网格尺寸了。如：123img, object, video, embed &#123; max-width: 100%;&#125; 这样一来，图像和多媒体元素都能在，父元素的内容区域内自由缩放。不过，需要注意的是，使用这种方法时，一定要使用 max-width 属性，而不是 width 属性。 这种方法可以解决现实的问题，但它又会带来新的问题：第一，需要提前准备一张超大的图片，以备大视口使用。第二，无论什么设备，无论视口多大，都会下载超大图片，这不但浪费手机流量、造成没有必要的存储空间消耗，还会影响网站载入速度，并且在小屏幕下图片很不清晰。 如果不同尺寸的设备使用同一张大的图片，不但浪费手机流量、造成没有必要的存储空间消耗，还会影响网站载入速度，并且在小屏幕下图片很不清晰，显然不合适。 如果能为不同尺寸的设备提供不同尺寸的图片，问题便迎刃而解。一种解决方案是不直接使用 img 元素，而是为父元素添加背景图片，再使用媒体查询，让不同尺寸的设备加载不同尺寸的背景图片。 看一个简单的例子，假设在网站头部要包含一个 logo，只需定义一个空的 header 元素，而不定义 img 元素。如：1&lt;header&gt;&lt;/header&gt; 就可以通过媒体查询，对不同尺寸的设备，使用不同尺寸的 logo 图像作为 header 元素的背景图片。如：12345678910@media screen and (min-width: 480px) &#123; header &#123; background: url(logo_480.png) no-repeat; &#125;&#125;@media screen and (min-width: 800px) &#123; header &#123; background: url(logo_800.png) no-repeat; &#125;&#125; 9.4.4 兼容老IE对于响应式布局，有一点需要注意，就是IE8 及以下的版本不支持媒体查询，这意味着它们只会呈现媒体查询以外的样式，即基准样式。并且，它们也不支持HTML5 的 header、main、aside、footer 等新元素。 对于IE8及更早的版本，可以什么都不做，让网站显示最基本的版本，或者为它们单独创建一个样式表，让它们显示网站最宽的版本。 当然，大多数人还是倾向于让页面具有响应式的效果。这也好办，只需在页面的头部中引入 respond.js，就能让老版本的IE 也支持响应性设计。123&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;respond.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 9.4.5 布局实例掌握了响应式设计的核心技术之后，你可以迫不及待想要使用它来构建响应式网站了。也许你会认为响应式设计有点复杂，但事实上，它比你想象的要简单。 下面通过构建一个响应式的页面基本布局，让你快速了解如何使用响应式设计技术来构建响应式网站。 首先，创建HTML结构和页面布局。 最常见基本布局将页面划分为 4 个部分，分别是头部、主内容区、侧边栏和页脚，而主内容区和侧边栏一般都会包含在一个容器中。如：12345678&lt;body&gt;&lt;header&gt;header&lt;/header&gt;&lt;div id=\"wrapper\"&gt; &lt;main&gt;main&lt;/main&gt; &lt;aside&gt;aside&lt;/aside&gt;&lt;/div&gt;&lt;footer&gt;footer&lt;/footer&gt;&lt;/body&gt; 如果一个元素的宽度为 auto 或百分比，它就具有响应性，它就会随着浏览器窗口尺寸的改变，而自动调整宽度。这里将主内容区的宽度为 78%，侧边栏的宽度为 20%，而 header 和 footer使用自动宽度，无需进行设置。12345678main &#123; width: 78%; float: left;&#125;aside &#123; width: 20%; float: right;&#125; 由于 #wrapper 只包含浮动元素，可以通过 overflow: hidden 来创建一个块格式化上下文，让它能够包含浮动元素。再为它设置适当的外边距，让各个元素之间泾渭分明。1234#wrapper &#123; margin: 10px auto; overflow: hidden;&#125; 为了方便查看效果，让头部、主内容区、侧边栏、页脚都具有 40px 的固定高度和 1px 的实线边框。1234header, main, aside, footer &#123; height: 40px; border: 1px solid #ccc;&#125; 其次，通过 meta 标签，设置视口的宽度，并禁止默认缩放。 视口（viewport）指的是浏览器（包括桌面浏览器和移动浏览器）显示页面的区域，它只是浏览区域，并不包含地址栏、按钮等区域。媒体查询中的 width 特性指是视口的宽度，而 device-width特性指的是屏幕的宽度。 在大多数移动设备上，默认情况下，这两个值通常不一样。如，iPhone的视口区域默认是 980 像素宽，而它的屏幕只有 320 像素宽。因此，iPhone 会按980 像素宽来显示页面，并将页面缩小，以适应 320 像素的屏幕宽度，就会显示为网站缩小后的样子。 幸运的是，在页面的头部添加 meta 元素，可以使该问题迎刃而解：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 这段代码的重点是 width=device-width，它将视口的宽度设置为设备的屏幕宽度，来让网页的宽度自动适应移动设备的屏幕宽度。而 initial-scale=1.0 表示页面按实际尺寸显示，不进行缩放。 在移动设备的浏览器上，通过添加 user-scalable=no，可以禁用其缩放功能。禁用缩放功能后，用户只能滚动屏幕，这样能让你的网站看上去更像原生应用。但并不推荐所有的网站都使用这种方式，是否使用这种方式要视情况而定。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; 最后，设置断点，让布局适应不同视口宽度。 通过媒体查询设置不同的断点，为不同的视图宽度指定不同的CSS规则，让浏览器根据指定的视图宽度渲染页面，来实现响应式布局。 可以根据需要添加任意多个媒体查询断点，为了简单起见，这里只添加一个断点。如，希望在视口宽度小于等于 480px 时，将 main 和 aside 的宽度设置为 auto 并取消浮动，让它们全屏显示：1234567891011@media screen and (max-width: 480px) &#123; main &#123; width: auto; float: none; &#125; aside &#123; width: auto; float: none; margin-top: 10px; &#125;&#125; 针对不同的屏幕尺寸定义媒体查询后，用户在改变浏览器窗口大小的过程中，浏览器会根据视口的尺寸自动重新渲染页面。 如，当视口宽度大于 480px 时，main 和 aside 在一行内显示，并各占一栏，宽度分别为 78% 和 20%。 当视口宽度小于 480px 时，main 和 aside 都全屏显示，各自独占一行。 当然，构建响应式网站要考虑的因素很多，远比这个要复杂。本实例仅仅是抛砖引玉，只简单介绍了构建响应式网站的基本过程，要了解响应式设计的更多技术，还要阅读专门介绍响应式设计的书籍，如《响应式Web设计：HTML5和CSS3实战》等。 解决跨浏览器问题10.1 渐进增强与优雅降级你可能听过优雅降级（graceful degradation）和渐进增强（progressive enhancement）这两个词，它们是构建Web应用时，处理多浏览器支持的两种方法论，并在Web社区中引发过激烈的辩论。 持优雅降级观点者认为，应该针对最高级、最完善的浏览器来设计网站。然后，再为那些被认为过时或有功能缺失的浏览器提供候选方案，使之基本可用，但不至于完全失效。这样一来，新特性在老浏览器中会降级，且一般会有一个分界点，声明不支持哪些老浏览器。有时候会警告使用老浏览器的用户，建议更换，如“您的浏览器已经老掉牙了，建议使用现代浏览器！”。 与优雅降级正好相反，持渐进增强观点者则认为，应该关注于内容本身。首先，保证最核心的功能，让任何低端的浏览器都能看到网站的内容。然后，再通过CSS或Javascript来进行效果、交互等改进，为更先进的浏览器提供渐进式增强，带来更好的用户体验。 其实，渐进式增强并不是一种技术，而是一种开发方式，是一种Web设计的新理念。过去，人们往往习惯性的认为，要让网站在所有浏览器下表现一致。这种出发点本身并没有什么问题，但会让高级浏览器的优势完全丧失，无法充分显示出来。 目前，人们普遍认为渐进式增强是一种更为合理的设计理念，也慢慢被越来越多的设计师所接受，并为之付诸行动。 10.2 兼容浏览器的方法开发人员基本都知道，CSS的开发本身并不难，但是，当在不同的浏览器下测试代码时，困难就出现了。浏览器的 bug 和不一致的显示方式，是大多数CSS开发人员面临的主要难题，你的设计在一种浏览器上看起来很好，而在另一种浏览器上可能会支离破碎。 实践证明，CSS的兼容性主要有两种情况：一种是对老版本IE的兼容性，一种是使用CSS3新特性后产生的兼容性。 对老版本IE的兼容性，主要通过CSS Hack和客户端脚本来解决；对使用CSS3新特性后产生的兼容性，主要通过浏览器私有前缀来解决。 10.2.1 CSS Hack由于不同厂商的浏览器（如IE、Chrome、Firefox、Safari），或同一浏览器的不同版本（如IE6~IE11），对CSS的解析不完全一样，导致同一页面在不同浏览器中的效果可能不一致。 为了得到统一的效果，就需要针对不同浏览器，或同一浏览器的不同版本，编写不同的CSS，把这个过程就被称作CSS Hack。 实践证明，CSS Hack主要用来解决IE的兼容性问题。虽然它是强有力的工具，但应该谨慎使用，它一般作为修复问题的最后一道屏障，在不得已的时候才会使用。因为更重要的是跟踪、隔离和识别问题，而不是修复问题。只有真正了解问题背后的原理，才能找到最好的解决方案。 CSS Hack 有 3 种表现形式： 1）属性前缀或后缀法 即在定义样式规则时，为样式属性添加只有特定浏览器，或某浏览器特定版本才能识别的前缀或后缀。 常见的前缀后缀说明及应用示例 前缀/后缀 适用版本 应用示例 _ IE6 p { _color: blue; } - IE6 p { -color: blue; } + IE7 p { +color: blue; } * IE6/IE7 p { *color: blue; } # IE6/IE7/IE8 p { #color: blue; } !important IE7/IE8/IE9/IE10/IE11 p { color: blue !important; } \\9 IE6/IE7/IE8/IE9/IE10/IE11 p { color: blue\\9; } \\0 IE8/IE9/IE10/IE11 p { color: blue\\0; } \\9\\0 IE9/IE10/IE11 p { color: blue\\9\\0; } 在使用属性前缀或后缀法时，一般是将适用范围广、被识别能力强的写法写在前面，把特殊写法写在后面。如：123456div &#123; background: blue; background: green\\9; *background: black; _background: orange; &#125; 由于所有浏览器都识别标准写法，而IE6/IE7/IE8/IE9/IE10/IE11可识别\\9，IE6/IE7可识别*，IE6仅能识别_。根据CSS的叠加原理，后定义的属性会覆盖先定义的同名属性，就实现了为IE各版本和现代浏览器应用不同样式的目的。 2）选择器前缀法 即在CSS选择器前，添加只有特定浏览器或某浏览器特定版本才能识别的前缀，选择器和前缀之间用空格分隔。 常用的前缀有 *html 和 *+html，*html 是IE6特有的前缀，而 *+html 是IE7特有的前缀。如：12*html p &#123; color: blue; &#125; /* IE6 */*+html p &#123; color: blue; &#125; /* IE7 */ 3）条件注释法 条件注释是IE浏览器专有的，也是微软官方推荐的Hack方式。它是使用IE条件注释，针对不同IE版本，编写不同的CSS，来为不同版本的IE应用不同的样式。 一种方法是直接在条件注释中定义样式。如：1234567&lt;style&gt;&lt;!--[if IE 6]&gt;div &#123; display: inline;&#125;&lt;![endif]--&gt;&lt;/style&gt; 虽然这种方法可以解决一些现实的问题，但这些注释需要放在HTML文件，而不是CSS文件中，样式定义散落在多个地方，不便于维护，也容易出错。也违背了内容与表现相分离的原则，故不推荐使用。 另一种方法是，编写不同的CSS文件，再使用IE条件注释，通过 &lt;link&gt; 标签，有针对性的加载外部样式表。如：123&lt;!--[if IE 6]&gt;&lt;link rel=\"stylesheet\" href=\"css/ie6.css\" /&gt;&lt;![endif]--&gt; 这种方法却会增加IE用户的HTTP请求次数，影响访问速度。所以，在使用这种方法前，要仔细斟酌，判断是否真的有必要在自己的网站上使用它。 一个好消息是，从IE10版本开始，不再支持条件注释。这标志着IE从此走向成熟、走向标准，Web设计师再也不必为IE的兼容性问题所困扰了。 愿望是美好的，现实却是残酷的。很多WEB设计师仍然发现，相同的CSS，在IE9/10/11上的渲染效果，和其它现代浏览器还是不一样。 也就是说，我们仍然需要条件注释。那么，在不支持条件注释的IE10/11上，能够实现条件注释的效果呢？ 答案是肯定的。并且，有多种方法可以实现条件注释的替代效果。并且，它们有各自的应用场景，可以根据需要选择使用。 方法一：使用IE = EmulateIE9属性，指示浏览器采用IE9渲染模式：1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE9&quot;&gt; 因为IE9是支持条件注释的，在页面的头部加入以上的元数据后，IE10/11就使用IE9的渲染模式，自然就能识别条件注释了。 很显然，这样做的弊端是，浏览器使用的是IE9的渲染模式，而不是最新的IE10/11的渲染模式。 方法二：使用媒体查询语句的 +-ms-high-contrast 属性，为不同浏览器应用不同的样式。 CSS 的媒体查询语句是一种高级的CSS条件语句，它能根据一些属性和属性值的计算结果，来判断CSS是否可以生效。 由于只有IE10/11实现了 -ms-high-contrast 属性，取值为active或none。因此，就可以使用以下媒体查询语句：123@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) &#123; /* IE10+ CSS styles go here */&#125; Firefox浏览器、Chrome浏览器不能识别这个属性，这个语句中的CSS就不会生效，便间接实现了条件注释的效果。 方法三：使用Javascript判断浏览器的类型，来为不同浏览器定义不同的样式。 先用Javascript 判断浏览器的类型，如果是IE浏览器，就在页面的 &lt;html&gt; 标签上添加一个 ie 的类名：123456789101112&lt;script&gt;var ms_ie = false;var ua = window.navigator.userAgent;var old_ie = ua.indexOf(\"MSIE\");var new_ie = ua.indexOf(\"Trident/\");if ((old_ie &gt; -1) || (new_ie &gt; -1)) &#123; ms_ie = true;&#125;if ( ms_ie ) &#123; document.documentElement.className += \"ie \";&#125;&lt;/script&gt; 有了这个标志性 class 后，就可以在CSS中，区分不同的浏览器，并专门针对IE编写不同的CSS代码。如：123456.testClass&#123; /* 这里写通用的css */&#125;.ie .testClass&#123; /* 这里写专门针对IE的css */&#125; 事实上，这个方法还能区分老IE和新IE。因此，也可以区分老IE和新IE，并有针对性的编写不同的CSS代码。 方法四：使用IE10/11私有的条件编译特性，来区分IE6-9 和IE10/11。1234567&lt;!--[if !IE]&gt;&lt;script&gt;if (/*@cc_on!@*/false) &#123; document.documentElement.className += \"ie10 \";&#125;&lt;/script&gt;&lt;!--&lt;![endif]--&gt; 上述脚本中，先使用条件注释 !IE来排除IE，以确保IE6-9不承认它。然后，再执行@ cc_on功能检测。 10.2.2 客户端脚本CSS很强大的一点是，它具有很强的向前兼容性：如果浏览器不识别某个属性或值，它会忽略这个声明；如果不识别某个选择器，它会忽略整个规则。 这意味着新的选择器、属性和值，不会对老的浏览器产生严重影响。因此，设计师就可以大胆的应用CSS3的高级规则和声明，而不必担心老浏览器是否能够识别。 事实上，这些高级规则确实给设计带来极大的便利，设计师都迫不及待的要使用它，并且希望它们在老的浏览器中，和现代浏览器中能够产生相同的效果。 幸运的是，网上存在大量的优秀脚本，可以让老的浏览器支持CSS3的一些高级特性。如，selectivizr、PIE、respond.js 等等。 selectivizrselectivizr 是一个非常优秀的Javascript工具，它可以让IE6-8浏览器支持CSS3的伪类选择器和属性选择器等。 selectivizr的使用非常简单，但是并不能直接使用，需要在页面的 &lt;head&gt; 标签中，先加载如jQuery、dojo、prototype、mootools等诸多流行的Javascript库中的任意一个。然后，再使用IE条件注释，让IE6-8版本加载 selectivizr 脚本，剩下的工作就交给 selectivizr 来完成：12345&lt;script src=\"[JS library]\"&gt;&lt;/script&gt;&lt;!--[if (gte IE 6)&amp;(lte IE 8)]&gt; &lt;script src=\"selectivizr.js\"&gt;&lt;/script&gt; &lt;noscript&gt;&lt;link rel=\"stylesheet\" href=\"[fallback css]\" /&gt;&lt;/noscript&gt;&lt;![endif]--&gt; 其中，JS library 是你要使用的Javascript库，selectivizr会自动检测最佳的Javascript库，如果你没有使用任何 Javascript 库，则伪类选择器和属性选择器等就不起作用。 需要注意的是，selectivizr只解析使用 &lt;link&gt; 标签引入或使用 @import 导入的外部样式表，而不解析在 &lt;style&gt; 标签中定义的样式，也不支持站外样式调用。 考虑到浏览器的安全机制，需要通过 http 或https协议访问页面才行，通过 file:// 协议访问页面，selectivizr则不能发挥它的正常功能。 PIEPIE.js 也是一款不错的Javascript工具，可以使IE6-8支持CSS3的部分渲染效果，如圆角、盒阴影、边框图像、多背景图像、渐变背景等。 PIE的使用也非常简单，只需在页面的 &lt;head&gt; 标签中，使用IE条件注释，让IE6-8版本加载 PIE 脚本，并调用 PIE.attach() 方法，将所有需要按CSS3进行渲染的选择器名称，添加到PIE对象：12345678910&lt;!--[if lt IE 9]&gt;&lt;script src=\"PIE.js\"&gt; &lt;/script&gt;&lt;script&gt;$(function() &#123; $(\".rounded\").each(function() &#123; PIE.attach(this); &#125;);&#125;); &lt;/script&gt;&lt;![endif]--&gt; 上述代码就表示，包含类 .rounded 的每一个元素，将按CSS3进行渲染。如果有多个选择器，需要按同样的方法都添加到PIE对象中。 使用Javascript 相对麻烦，因此，PIE还提供了 .htc 文件，使用起来更加方便，只需在相应的选择器中，通过 behavior 属性直接链接 pie.htc 文件即可。如：1234.rounded &#123; border-radius: 8px; behavior: url(pie.htc);&#125; respond.jsrespond.js 是一个快速、轻量的 Javascript 工具，它可以为IE6-8 提供媒体查询的 min-width 和 max-width 特性，使它们能够支持响应性设计。 respond的使用及其简单，只需在页面的头部，使用IE条件注释，让IE6-8版本加载 respond.js 脚本即可：123&lt;!--[if lt IE 9]&gt;&lt;script src=\"respond.js \"&gt;&lt;/script&gt;&lt;![endif]--&gt; 说明：.htc 文件.htc 文件是一种脚本文件，用来描述 web 行为，web 行为允许程序员把自定义的功能“连接”到现有的元素和控件，而不是必须让用户下载二进制文件来完成这个功能。由于只有IE才能认识 .htc 文件。因此，常常用来解决 IE 特有的问题。如，在 IE6 及更低版本中，只有链接元素 a 才支持 :hover 伪类选择器。csshover.htc 是一个脚本，只需下载该脚本，并在 body 的元素选择器中，通过 behavior 属性的 url 指向它，就可以让锚以外的元素支持 :hover 伪类选择器。如：1body &#123; behavior: url(csshover.htc); &#125; 这样一来，就可以在CSS中，定义诸如 div:hover、li:hover、p:hover、img:hover、自定义选择器:hover，使 IE6 及更低版本支持在图像、列表等元素上使用 :hover 伪类选择器。 10.2.3 浏览器私有前缀CSS3 规范从启动到成为W3C 的推荐标准，一般要经历数年。在W3C 开发标准的过程中，浏览器通常会提前实现这些特性。 浏览器厂商通常都是在属性名称前添加厂商的私有前缀，来测试这些尚未成为标准的特性。因此，可以借助私有前缀，来解决浏览器对CSS3的兼容性问题。 不同的内核都有各自的私有前缀，三大主流内核的私有前缀见表 内核 前缀 主要浏览器 Trident -ms- Internet Explorer Gecko -moz- Firefox Webkit -webkit- Chrome、Opera、Safari、Android 如，对border-radius属性，用它来指定元素的圆角，很多厂商就使用了私有前缀。而一旦标准充分成熟，浏览器厂商就会移除前缀，直接支持border-radius。代码如下：123456.round10 &#123; -ms-border-radius: 10px; /* Miscrosoft (Internet Explorer) */ -moz-border-radius: 10px; /* Mozilla(如Firefox) */ -webkit-border-radius: 10px; /* Webkit(如Chrome 、Opera、Safari) */ border-radius: 10px; /* W3C */&#125; 使用私有前缀时，如果私有特性和最后的标准特性不一致，就会出现兼容问题。因此，需要把浏览器的私有属性写在前面，把标准属性写在最后面，来确保在特性被完全支持时，能得到正确的效果。 列出每一种私有前缀是最理想的做法，但实际开发中，很少有人这样做。最好的作法是，在编写规则之前，检查哪些浏览器支持该特性，仅列出不支持该特性的私有前缀。如：1234.round10 &#123; -ms-border-radius: 10px; /* Miscrosoft (Internet Explorer) */ border-radius: 10px; /* W3C */&#125; 这样写会覆盖使用Webkit和Gecko内核，以及已经完全实现了该规则的任何浏览器，代码不会那么臃肿了，阅读起来也更方便了。更重要的是，可以大大减轻后期维护的负担。 10.3 IE的hasLayout在 IE 浏览器中，一个元素要么自己对自身的内容进行组织和计算尺寸，要么依赖于包含块来组织内容和计算尺寸。 为了协调这两种方式的矛盾，IE 浏览器的渲染引擎使用了一个私有属性 hasLayout，它是一个布尔型变量，取值为 true 或 false。 当一个元素的 hasLayout 属性取值为 true 时，就说这个元素“拥有布局”。 hasLayout是一个只读属性，无法通过 Javascript 进行设置，但可以通过 Javascript 读取它的值。如：1object.currentStyle.hasLayout； 在IE中，使用 hasLayout 来控制元素的尺寸和定位：当一个元素拥有布局时，由它自己来控制自身及后代元素的定位和尺寸；否则，将由最近拥有布局的祖先元素来控制。 由于浏览器要花费更多的代价来处理拥有布局的元素，为了提高性能，IE 设计者只让一部分元素默认拥有布局。这些元素包括： html、body table、tr、td img hr input、select、teatarea、button、fieldset iframe、embed、object、applet marquee 除了 IE 默认拥有布局的元素外，Web 开发者还可以使用特定的 CSS 属性使元素拥有布局，也被称作“使元素触发布局”。设置以下任一CSS属性，会自动使元素拥有布局： position: absolute float: left或right display: inline-block width: 除auto外的任何值 height: 除auto外的任何值 zoom: 除normal外的任何值（Microsoft属性，不能通过检测） writing-mode: tb-rl（Microsoft属性，不能通过检测） 另外，在IE7中，设置以下任一CSS属性，也会使元素触发布局： position: fixed overflow: hidden或scroll或auto min-width: 任何值 max-width: 除 none 外的任何值 min-height: 任何值 max-height: 除 none 外的任何值 特别注意的是，IE 8 使用全新的渲染引擎，并抛弃 hasLayout。因此，在实际开发中，只需针对 IE 8 以下的版本，为某些元素触发 hasLayout。 有经验的CSS开发人员都知道，hasLayout 可能是许多IE 问题的根源。一个典型例子，就是当一个元素内只包含浮动或绝对定的位元素时，会导致父元素的高度塌陷。在IE6或IE7中，为元素添加 zoom：1 就触发了haslayout，就可以修复高度塌陷的问题。 虽然 hasLayout 也会像 BFC 那样影响元素的尺寸和定位，但它却不是一套完整的标准。并且，默认情况下，只有部分元素拥有布局，这导致了 IE 下的诸多 Bug，触发布局的更大意义在于解决IE 下的一些Bug，而不是利用它的一些“副作用”来达到某些效果。 10.4 修复IE的常见BugCSS开发人员可能经常会碰到的一个现象是，一个页面在IE（特别是老版本的IE）中显示正常，而在现代浏览器中却完全变形了，或者情况完全相反。 常常能听到有人抱怨：“在IE上开发时间中，超过 60% 的时间，都是在与IE的Bug作斗争。”导致这一现象的根本原因，是不知道IE都有哪些 bug，也不知道如何解决这些 bug。在出现问题时，往往束手无措，更不要说预防 Bug 了。 因此，作为一位优秀的CSS开发人员，必须了解IE浏览器的常见 Bug，以及导致这些 Bug的各种因素，以便能够预防 Bug 的产生，或在出现问题后，能够及时发现并快速修复。 10.4.1 浮动元素双倍边距Bug浮动元素双倍边距 Bug，是IE6及更低版本中的一个经典Bug。当给元素设置了 float 属性，同时设置了与浮动方向相同margin值，则浮动元素的 margin就会加倍。 简单的说，就是左浮动元素的 margin-left 被加倍，而 margin-right 不会被加倍，右浮动元素的 margin-right 被加倍，margin-left 不会被加倍。 但是，当有多个元素都在一行内向相同方向浮动，且都有同方向的 margin 时，只有靠近浮动方向的第一个元素的 margin 会加倍，其他元素则不会。 假设在一个容器中，有两个元素：1234&lt;div id=\"wrapper\"&gt; &lt;div class=\"fl\"&gt;float&lt;/div&gt; &lt;div class=\"fl\"&gt;float&lt;/div&gt;&lt;/div&gt; 现在，让两个元素都向左浮动，并为它们设置 100px 的左外边距：123456.fl &#123; float: left; width: 100px; height: 60px; margin-left: 100px;&#125; 在IE6中及更低版本中，会发现第一个元素的左外边距，由 100px 被扩大为 200px。而第二个元素的左外边距仍然是 100px，没有被加倍。 修复这个 Bug 的方法很简单，只需将浮动元素的 display 属性设置为 inline，便可轻松解决问题。但是，这里的 display 属性，除了修复IE Bug外，并没有其它用处。1234567.fl &#123; float: left; width: 100px; height: 60px; margin-left: 100px; display: inline;&#125; 将浮动元素的 display 属性设置为 inline 并不会影响它的显示方式，还能阻止IE6及更低版本将它的外边距加倍。因此，每当让具有水平外边距的元素进行浮动时，都应该很自然地将它的 display 属性设置为 inline，以防止外边距被加倍。 10.4.2 文本3像素偏移Bug在IE6及更低版本中，当一个浮动元素与一个非浮动元素相邻时，在非浮动元素中，会莫名的为靠近浮动元素的内容添加 3 像素的间隙。 假设在一个容器中，有两个元素：1234&lt;div id=\"wrapper\"&gt; &lt;div class=\"fl\"&gt;float&lt;/div&gt; &lt;p&gt;...&lt;/p&gt;&lt;/div&gt; 左侧的 div 元素向左浮动，而右侧的 p 元素不浮动：12345.fl &#123; float: left; width: 100px; height: 60px;&#125; 在IE6中，就会发现在非浮动元素中的文本和浮动元素之间，莫名其妙会出现 3px 的间隙，一旦浮动停止，3px 的间隙就会消失。 由于这个间隙很小，在文本环绕浮动元素时，很难被注意到。但是，如果为 p 元素设置一个与浮动元素宽度相等的左外边距，则在浮动停止的时候，3px 的间隙就会消失，可以看到文本会突然出现一个台阶。 当然，如果这个Bug不影响布局，完全可以让它随风而去。但是，如果影响了布局，或者你不能容忍一点点瑕疵的话，就得想办法消除这 3px 的间隙。 如果希望段落文本环绕浮动元素，只需要使用IE hack，将浮动元素的右边距向左缩进 3 个像素，便可轻松解决问题。123456.fl &#123; float: left; width: 100px; height: 60px; _margin-right: -3px;&#125; 如果不希望段落文本环绕浮动元素，就可以通过任何一种方式，让 p 元素触发布局。触发布局的方法很多，最常用的莫过于 _zoom: 1 了。触发布局后，p 元素便会独立布局，3px 的间隙自然就消失了。 10.4.3 列表li的阶梯Bug在IE6及更低版本中，如果 li 元素中包含一些元素内容（如，链接元素），并且让其内容进行浮动，但 li 本身不浮动时，li 就会呈阶梯状。 假设在一个无序列表中，包含多个 li 元素，并在每个 li 中包含一个链接元素：123456&lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;产品中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新闻动态&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 如果让 a 元素向左浮动，而 li 本身不浮动，li 就会呈阶梯状。为了方便查看效果，清除无序列表的默认样式，并为链接设置了宽度、高度，及背景颜色：12345678910111213ul &#123; margin: 0; padding: 0; list-style: none;&#125;ul li a &#123; float: left; width: 130px; height: 30px; line-height: 30px; text-align: center; background: #fa7a20;&#125; 这个 Bug 很容易修复，只需让 li 元素也向左浮动，或将 li 元素的 display 属性设置为 inline，便可轻松解决问题。 10.4.4 列表li的底部空行Bug在IE6及更低版本中，如果在 li 元素中包含 display: block 的元素时，li 元素之间的空格将会转换为一个空行，夹在每个 li 的中间。 假设使用上一节的HTML结构来制作垂直导航，为了增大链接的点击区域，常常将 a 元素的 display 属性设置为 block，让它成为块级元素。为了方便查看效果，为链接设置背景颜色：1234li a &#123; display: block; background: #fa7a20;&#125; 导致这个问题的根本原因，是 li 元素后面的空格或换行符被转换为空行。如果在HTML代码中，将所有的 li 在一行内连续书写，中间没有空格，这个问题就不会出现。 然而，当存在很多 li 子元素时，在一行内书写会给阅读代码带来困难。事实上，除了在一行内显示外，这个问题还有很多解决方法。 方法一：为 li 元素设置 display: inline，让它在行内显示。由于内部的 a 元素是块级元素，这种方法不会产生任何负面影响。因此，这应该是最简单的解决方法。123li a &#123; display: inline;&#125; 方法二：为 a 元素显式定义一个宽度或高度，使它触发IE的hasLayout。1234li a &#123; … width: 200px; &#125; 如果使用高度来触发IE的hasLayout，可以同时定义 line-height 属性，并设置为height 属性相同的值，还可以让链接垂直居中，一举两得。 方法三：为每个 li 元素设置一个下边框。123ul li &#123; border-bottom: 1px solid #fff;&#125; 在解决问题的同时，这个边框还起到分隔 li 元素的作用，此方法可谓一举两得。但是，如果你偏偏不允许分隔 li 元素，这又带来新的问题，就是当边框颜色和背景颜色不一致时，将会影响显示效果。所以，最好将边框的颜色，设置成背景颜色。 当然，也可以为 li 元素设置一个与边框等宽的负值下外边距，这样，就不必为边框颜色而纠结了。1234ul li &#123; margin-bottom: -1px; border-bottom: 1px solid #fff;&#125; 方法四：让 a 元素进行浮动，同时清除浮动。12345li a &#123; … float: left; clear: left;&#125; 由于浮动会导致 a 元素的宽度收缩，又会增加额外的 clear 属性，并不推荐使用这种方法。但总归它是一种解决方法，应该会有合适的应用场景。 10.4.5 相对容器中绝对定位Bug在页面布局中，将绝对定位的元素嵌套在相对定位的容器中，是一种很常见的布局。假设有两个元素，#outter 为父元素，#inner 为子元素：123&lt;div id=\"outter\"&gt; &lt;div id=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 如果让父元素使用相对定位，子元素使用绝对定位，在 IE6 及更低版本中，它会有很多问题。最常见的问题有两个：一个问题是，当父元素的宽度为奇数时，子元素的 right 偏移值会错位；另一个问题是，当为父元素设置 padding 后，子元素的偏移起点位置错误。 先看看第一个问题，我们让父元素 width 属性的值是一个奇数，并通过 top 和 right 属性设置子元素的偏移：123456789101112#outter &#123; width: 205px; height: 80px; position: relative;&#125;#inner &#123; width: 100px; height: 60px; top: 0; right: 0; position: absolute;&#125; 正常情况下，子元素的顶部紧贴父元素的底部、右侧紧贴父元素的右侧。 究其原因，这是由于相对定位父元素的宽度为奇数所致，如果把宽度设置为偶数，问题就不会出现。 再来看第二个问题，为了方便查看效果，为父元素设置 30px 宽的边框，并为子元素设置宽度、高度、及 1px 的虚线边框：12345678910111213#outter &#123; padding: 20px; position: relative; border: 30px solid #ccc;&#125;#inner &#123; top: 0; left: 0; width: 100px; height: 20px; position: absolute; border: 1px dashed #f00;&#125; 正常情况下，绝对定位元素的偏移，是相对于其包含块边框的内边缘，即父元素 #outter 边框的内边缘。 而在IE6及更低版本中，top 的偏移是相对于其包含块边框的外边缘，left 的偏移是相对于其包含块 padding-box 的外边缘。 这个问题的原因，是相对定位的父元素没有触发布局，为了使IE6及更低版本中表现正确。可以为父元素显式设置宽度、或高度、或 zoom: 1，迫使父元素触发布局，使绝对定位子元素回到正确的位置。 但很多时候，根本无法给父元素指定一个合适的宽度和高度值，而 zoom: 1 又会导致父元素的 padding 失效。 因此，解决这个问题最好的办法，就是使用IE hack，把绝对定位子元素的 top 设置为父元素 border-top 的宽度，把 left 设置为等于父元素 padding-left 的负值。如：12345#inner &#123; … _top: 30px; _left: -20px;&#125; 10.4.6 相对定位子元素溢出Bug在页面上，常常使用 overflow 属性，来控制一个元素内容溢出时的处理方式。然而，在IE6和IE7中，当父元素设置了 overflow: auto 或 overflow: hidden，当子元素使用相对定位且高度大于父元素高度时，子元素就会溢出到父元素的外面。 假设页面上有两个元素，#outter 为父元素，#inner 为子元素：123&lt;div id=\"outter\"&gt; &lt;div id=\"inner\"&gt;当子元素的高度大于父元素高度时…&lt;/div&gt;&lt;/div&gt; 父元素设置了固定宽度和高度，并设置了 overflow: auto，让它在需要的时候出现滚动条。子元素也设置了固定宽度，并使用相对定位。为了方便查看效果，为父元素和子元素都设置了边框：1234567891011#outter &#123; width: 200px; height: 100px; overflow: auto; border: 1px solid #ccc;&#125;#inner &#123; width: 100px; position: relative; border: 1px dashed #666;&#125; 正常情况下，如果子元素中的内容超过了父元素的高度，则父元素会自动出现滚动条，并且隐藏溢出的内容。 而在 IE6 和 IE7 中，父元素也出现了滚动条，但是，子元素的内容却溢出到了父元素外面。 解决这个问题的方法很简单，只需为父元素设置 position: relative，让父元素也使用相对定位就可以了。 10.4.7 IE6重复字符Bug在IE6中，如果一个元素中包含多个浮动元素，某些情况下，最后一个浮动元素中的最后几个字符，会在该元素的下面重复出现，被称作“IE6重复字符Bug”。 当父元素的宽度减去最后一个浮动元素的宽度小于 3px 时，如果在第一个浮动元素和最后一个浮动元素之间，有多个 html 注释或 display：none 的元素，就会出现IE6重复字符Bug。并且，重复的字符数 =（注释的条数 + display：none的元素的数目）* 2 – 1。 假设在一个父元素中，有两个向左浮动的子元素，在两个浮动子元素之间有一条 html 注释。HTML代码如下：123456&lt;div style=\"width:200px;\"&gt; &lt;div style=\"float: left;\"&gt;&lt;/div&gt; &lt;!-- some comment--&gt; &lt;div style=\"display: none\"&gt;&lt;/div&gt; &lt;div style=\"float: left; width: 200px;\"&gt;买房无忧&lt;/div&gt;&lt;/div&gt; 由于父元素的宽度是 200px，最后一个浮动子元素的宽度也是 200px，就会出现IE6重复字符Bug。由于存在一条注释和一个 display：none的元素，就会出现 3 个重复字符。 避免这个问题最直接、最简单的办法，就是删除 html 注释和 display：none 的元素，但是 display：none 的元素也许会有独特的作用，不能随意删除。 而从现象看，IE6重复字符Bug 似乎与文本 3 像素偏移 Bug 都有或多或少的关系，因此，可以减小最后一个浮动元素的宽度或增大父元素的宽度，使父元素的宽度减去最后一个浮动元素的宽度小于 3px，或者给最后一个浮动元素加上 margin-right: -3px，来修复这个问题。 10.4.8 IE6躲猫猫Bug在IE6中，另一个很奇怪而且让人抓狂的 Bug，就是 peek-a-boo Bug。peek-a-boo 是大人把脸一隐一现，来逗小孩发笑的一种游戏。因此，中文把它称作IE6躲猫猫Bug。 IE6躲猫猫Bug出现的条件是：一个浮动元素后面跟着一些非浮动元素，接着是一个清理元素，所有元素都包含在一个有背景色或背景图片的父元素中。 现在，我们构造一个HTML结构，来重现这个 Bug。代码如下：1234567&lt;div class=\"father\"&gt; &lt;div class=\"fl\"&gt;float: left&lt;/div&gt; &lt;div&gt;这是一个非浮动元素&lt;/div&gt; &lt;div&gt;这是另一个非浮动元素&lt;/div&gt; &lt;div&gt;这是再一个非浮动元素&lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;/div&gt; 这里的浮动元素、非浮动元素、清理元素，都包含在一个具有背景颜色的父元素中。为了方便查看效果，为浮动元素设置了高度：12345678910.father &#123; background: #6FB934;&#125;.fl &#123; float: left; height: 60px;&#125;.clear &#123; clear: both;&#125; 为了能够一目了然地看到所有子元素，为所有的 div 子元素都设置 4px 的外边距和 1px 的实线边框：1234div &#123; margin: 4px; border: 1px solid #ccc;&#125; 正常情况下，所有子元素都从父元素的左内边界开始布局，并且，非浮动元素中的文本会环绕浮动元素。由于清理元素中没有任何内容，只显示出边框。 而在IE6中，中间的这些非浮动元素却不能正常显示出来，似乎莫名其妙地消失了。 事实上，这些非浮动元素并没有消失，只是它们被隐藏到了父元素的背景颜色或图像的后面，只有在刷新页面时，它们才重新出现。这也是它被称作IE6躲猫猫Bug的原因。 避免这个问题最直接、最简单的办法，就是去掉父元素上的背景颜色或图像。但是，如果父元素必须有背景的话，这个方法不是可行的。可以尝试使用以下任意一种方法，它们都能使这个 Bug 不再出现：避免清理元素和浮动元素相接触；为浮动元素或父元素指定一个 width 或 height 或 line-height；为浮动元素和父元素都设置 position: relative。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"HTML宝典","slug":"HTML宝典","date":"2018-07-21T01:10:00.000Z","updated":"2018-07-25T04:05:06.949Z","comments":true,"path":"2018/07/21/HTML宝典/","link":"","permalink":"http://yoursite.com/2018/07/21/HTML宝典/","excerpt":"一、HTML基础二、HTML元素三、表单及应用四、Canvas绘图基础五、客户端存储","text":"一、HTML基础二、HTML元素三、表单及应用四、Canvas绘图基础五、客户端存储 一、HTML基础1.1 认识HTML1.1.1 什么是HTMLHTML是Hyper Text Markup Language的缩写，中文的意思是“超文本标记语言”，它是制作网页的标准语言。由于网页中不仅包含普通文本，还包含超文本，故被称作超文本描述语言。 那什么是超文本呢？所谓超文本，就是指图像、视频、动画、声音、表格、链接等多媒体的内容。 HTML是网页的基本描述语言，由Tim Berners-Lee在1990年提出，其目的是方便地把一台电脑中的文本或图形，与另一台电脑中的文本或图形联系在一体，形成一个有机的整体，让人们不必考虑这些信息是在当前的电脑上，还是在网络上的其他电脑上。 HTML 不是一种编程语言，而是一种描述性的标记语言 (markup language)，它使用标签来描述网页，负责将网页内容进行格式化，使内容更具逻辑性。 HTML文档不需要编译，直接由浏览器解释执行，浏览器（IE、FireFox、Chrome、Opera、Safari、UC等）软件知道HTML的语法，知道如何解释HTML文档。目前互联网上的绝大部分网页，都是使用HTML编写的。 1.1.2 HTML发展史HTML经历了HTML 2.0、HTML 3.2、HTML 4.0、HTML 4.01、HTML5，共5个版本。最新版本HTML 5于2014年10月28日成为W3C推荐标准。 HTML 2.0于1995年11月作为RFC 1866发布，成为第一个正式规范。成为正式规范的目的是为了与当时的各种HTML标准区分开来，故使用2.0作为其版本号。HTML 2.0在RFC 2854于2000年6月发布之后被宣布已经过时。 HTML3.0规范是由当时刚成立的W3C于1995年3月提出，提供了很多新的特性，如表格、文字绕排和复杂数学元素的显示。虽然它是被设计用来兼容2.0版本的，但是实现这个标准的工作在当时过于复杂，在草案于1995年9月过期时，标准开发也因为缺乏浏览器支持而中止了。3.1版从未被正式提出，而下一个被提出的版本是开发代号为Wilbur的HTML 3.2，去掉了大部分3.0中的新特性，但是加入了很多特定浏览器，例如Netscape和Mosaic的元素和属性。HTML对数学公式的支持最后成为另外一个标准MathML。HTML 3.2于1997年1月14日成为W3C推荐标准。 HTML 4.0同样也加入了很多特定浏览器的元素和属性，但是同时也开始“清理”这个标准，把一些元素和属性标记为过时，建议不再使用它们。HTML的未来和CSS结合会更好。HTML 4.0于1997年12月18日成为W3C推荐标准。 HTML 4.01于1999年12月24日成为W3C推荐标准。只是对HTML 4.0的一些微小改进。 HTML 5草案的前身名为Web Applications 1.0。于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的HTML工作团队。在2008年1月22日，第一份正式草案发布。HTML 5于2014年10月28日正式成为W3C推荐标准。 1.2 HTML基础语法HTML文档由HTML元素组成，一个HTML元素由一个标签和一组属性组成。一个标签可以有一个或多个属性，属性以名称和值成对出现。 Web 浏览器读取HTML 文档，并以网页的形式显示出来，浏览器不会显示 HTML 标签，而是通过标签来解释网页的内容。 1.2.1 HTML元素HTML 不是一种编程语言，而是一种描述性的标记语言，并使用HTML标签来描述HTML元素。HTML标签是由尖括号（“&lt;”和“&gt;”）包围的关键词，HTML标签通常成对出现，一个是开始标签，一个是结束标签。开始标签告诉浏览器，从这里开始执行该标签所表示的功能；结束标签告诉浏览器，该功能到这里结束。 总结：一个HTML 元素由开始标签、内容、结束标签组成。开始标签是放在一对尖括号中的元素名称及可能包含的属性，结束标签是放在一对尖括号中的斜杠加元素的名称。语法格式：&lt;开始标签&gt;内容&lt;/结束标签&gt; 还有一些元素就是空元素（empty element 或 void element），它既不包含文本也不包含其他元素。这类元素无需单独的结束标签，只需在开始标签的“&gt;”前加一个可选的空格和斜杠即可。12如：&lt;img src=\"logo.jpg\" title=\"M\" alt=\"M\" /&gt; 1.2.2 HTML属性HTML属性包含了元素的额外信息，它总是出现在HTML开始标签中，并且，通常以名/值对的形式出现（空属性除外，它可以只有属性没有值）。属性的名称和值是大小写无关的，推荐使用小写。 HTML属性的值有以下四种表现形式： 1）空值：只有属性名称，隐含的意思是属性的值为布尔类型。在HTML5中，一切化繁为简，对于布尔型的属性，可以不提供属性的值。如果一定要提供一个值，值就是属性名本身。如：1&lt;input type=\"submit\" disabled=\"disabled\"&gt; 就可以直接写成1&lt;input type=\"submit\" disabled&gt; 2）无引号值：如果属性的值中不包含任何空格字符、单引号、双引号、等号、大于号、小于号，也不为空，就可以省略属性值两边的引号。如，&lt;input type=submit value=submit&gt;。 3）单引号值：如果属性的值中不包含任何单引号，也不为空，就可以把属性值放在单引号中。如，&lt;input type=&#39;submit&#39; value=&#39;submit&#39;&gt;。 4）双引号值：如果属性的值中不包含任何双引号，也不为空，就可以把属性值放在双引号中。如，&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;。 大多数的HTML元素都拥有多个属性，多个属性中，如果省略某个属性，则该属性使用默认值。在定义多个属性时，各属性之间没有先后次序，但属性的名/值对之间必须用空格分开。如，a 元素就拥有多个属性，每个属性都有各自的值。12345&lt;a href=\"http://en.wikipedia.org/wiki/M\" rel=\"external\" title=\"Learn more\"&gt;Learn More&lt;/a&gt;href是a的一个属性 后面是href的值rel也是a的一个属性 后面是rel的值title也是a的一个属性 后面是title的值 有的属性可以接受任何值，而有的属性则只能接受预定义的值（也称作枚举值），即必须从一个标准列表中选择一个值。如，link 元素的 href 属性就可以接受任意值，而 media 属性却只能设置为 all、screen、print 等预定义值中的一个。1234&lt;link rel=\"stylesheet\" media=\"screen\" href=\"style.css\" /&gt;screen 预定义值style.css 非预定义值 HTML的属性中，有些属性只能用于特定元素，而有些属性可以用于任何元素。可用于任何元素的属性被称作全局属性。 HTML4中，提供了 6 个全局属性，它们分别是 class、id、style、title、accesskey、tabIndex、dir，到了HTML5，又新增了 contenteditable、hidden、lang、spellcheck、translate、data-* 这6 个全局属性： 1.2.2.1 class属性class属性用来规定元素所使用的CSS类名（class name），该属性对 html、head、title、style、base、meta、param、script等这些元素无效。 一个元素的 class属性值中可以包含多个类名，类名之间用空格分隔，表示为该元素应用多个类选择器合并后的样式。 当元素应用多个类的样式时，类名不分先后顺序，元素的最终样式就是所有这些样式层叠后的效果。 1.2.2.2 id属性id属性用来规定一个元素的 id，在一个 HTML 文档中，id必须是唯一的。定义 id属性后，就可以通过 CSS 为带有指定 id 的元素添加样式，也可以通过 Javascript 来操作元素。通过 Javascript，可以对元素进行很多操作，如改变元素的内容、为元素添加样式等。可以为元素注册某事件，当事件发生时，对元素进行相应的操作。 如，为上述段落注册 onclick 事件，当用户在段落上点击时，调用 Javascript 函数来改变段落的内容：1&lt;p id=\"paragraph\" onclick=\"changeText()\"&gt;这里是段落的内容！&lt;/p&gt; HTML文档中的任何一个元素，都会生成一个DOM对象。通过Javascript 操作元素时，首先通过 document.getElementById() 方法获取对象的句柄，再通过 Javascript 的属性或方法来操作元素。如，通过innerHTML属性，就可以改变元素的内容。请将以下代码插入到HTML文档的头部：12345&lt;script&gt;function changeText() &#123; document.getElementById(\"paragraph\").innerHTML = \"Hello World!\";&#125;&lt;/script&gt; 上述代码就表示，当在段落上点击时，将段落的内容由“这里是段落的内容！”，动态修改为 “Hello World!”。 1.2.2.3 style属性style属性用来规定元素的内联样式。如：1&lt;p style=\"color: red;font-weight: bold;\"&gt;本段落的文本将显示为红色、粗体。&lt;/p&gt; 上述代码通过 p 元素的 style属性，为段落元素定义了一个内联样式，让段落中的文本以红色、粗体显示。 由于 style属性定义的样式优先级最高，它将覆盖任何在 &lt;style&gt; 标签或外部样式表中定义的全局样式。 1.2.2.4 title属性title属性用来规定元素的额外信息，当鼠标移到元素上时，会显示一个文本提示信息，信息的内容是 title属性的值。如：1&lt;p title=\"我是测试文本\"&gt;测试文本&lt;/a&gt; 上述代码就表示，当鼠标移到段落上时，会显示”我是测试文本”的提示信息。 为链接，特别是图片链接添加 title属性，当把鼠标移动到链接上时，就会显示 title属性的值，可以达到补充说明或者提示的效果。 另外，由于搜素引擎无法直接读取图像的信息，而 title属性可以为它提供文字信息，这对搜索引擎比较友好，是搜索引擎优化的重要内容。因此，强烈建议为所有的链接元素添加 title属性。 1.2.2.5 accesskey属性accesskey属性用来规定激活元素的快捷键，定义accesskey属性后，就可以通过快捷键来激活元素，使它获得焦点。 支持 accesskey属性的元素有 a、area、button、input、abel、legend、textarea。如，以下代码为链接元素定义的快捷键是字母 w：1&lt;a href=\"http://www.waibo.wang/\" accesskey=\"w\"&gt;歪脖网&lt;/a&gt; 不幸的是，不同浏览的快捷键和访问方式却不完全相同。IE和 Chrome 浏览器的快捷键是 ALT+w，FireFox 浏览器是 Alt+Shift+w。IE要先使用快捷键使链接获得焦点，再按回车，来跳转到链接指定的地址；而 FireFox 和 Chrome 浏览器，仅仅使用快捷键便能自动跳转链接指定的地址。 使用 accesskey属性能够增加应用的易用性，特别是对那些使用键盘的用户。因此，为菜单和导航定义 accesskey属性，是非常不错的选择。 1.2.2.6 tabIndex属性当页面上有很多元素的时候，就可以通过Tab键让元素获得焦点，并在元素间进行移动。默认情况下，可以通过Tab键访问的元素有 a、area、button、input、object、select、textarea，其他元素不能通过Tab键进行访问。 通过 tabIndex属性，任何元素（包括那些不能获得焦点的元素，如 &lt;span&gt; 或 &lt;div&gt;）都能被包含在Tab键的序列中，可以极大提高应用的易用性。 tabIndex属性的值大于0的元素，将按属性值从小到大设置Tab键顺序。使用Tab键访问元素时，tabIndex属性值最小的元素最先获得焦点。如果两个元素具有相同的 tabIndex属性值，则以它们在源码中出现的先后顺序，前面的元素先获得焦点。并且，tabIndex属性的值可以不是从 1 开始，也可以不连续，浏览器会自动进行排序。 tabIndex属性值等于 0的元素，将根据源代码（或默认页面行为）的顺序设置Tab键顺序，并且排在所有 tabIndex属性值大于 0 的元素之后。 tabIndex属性值为负值（如，tabIndex = “-1”）的元素，将变成可由代码获得焦点，但它本身并不在Tab键序列中。也就是说，在按下Tab键时，该元素不能获得焦点，但可以通过代码让它获得焦点。 假设页面上有三个链接元素，它们的 tabIndex属性值依次是5、1、8：123&lt;a href=&quot;#&quot; tabIndex =&quot;5&quot;&gt;商品分类&lt;/a&gt;&lt;a href=&quot;#&quot; tabIndex =&quot;1&quot;&gt;联系我们&lt;/a&gt;&lt;a href=&quot;#&quot; tabIndex =&quot;8&quot;&gt;关于我们&lt;/a&gt; 在通过Tab键遍历这些链接元素时，它们的访问顺序依次是联系我们-&gt;商品分类-&gt;关于我们，而不是源码中定义的顺序。 1.2.2.7 dir属性dir属性用来规定元素内容的文本书写方向，该属性对 base、br、frame、frameset、hr、iframe、param、script 等这些元素无效。 dir属性的取值为 ltr | rtl，默认值为 ltr。ltr表示从左向右的文本书写方向，而 rtl 表示从右向左的文本书写方向。 假设页面上有两个段落，第一个段落的 dir属性设置为 ltr，第二个段落的 dir属性设置为 rtl：12&lt;p dir=\"ltr\"&gt;这段落文本从左到右书写。&lt;/p&gt;&lt;p dir=\"rtl\"&gt;这段落文本从右到左书写。&lt;/p&gt; 1.2.2.8 contenteditable属性在HTML4中，只有 type 属性值为 text、password、file 的 input 元素，以及 textarea 元素的内容是可编辑的。 到了HTML5，通过 contenteditable属性，可以让任何元素的内容可编辑。如果一个元素没有显式设置 contenteditable属性，它将从其父元素继承该属性的值。 contenteditable属性是布尔属性，取值为 true | false，默认值为false。true 表示元素的内容可编辑，false 表示元素的内容不可编辑。 如果一个元素的内容被设置为可编辑，当用户用鼠标单击该元素后，浏览器会向用户提供一个插入符号，提示用户该元素的内容允许编辑，用户就可以编辑该元素的内容。 假设页面上有一个段落，它的contenteditable属性被设置为 true，则用户可以编辑段落中的内容：1&lt;p contenteditable=\"true\"&gt;这是一个可编辑的段落。&lt;/p&gt; 在HTML5中，一切化繁为简，对于任何布尔属性，如果只提供属性名，就等价于把该属性设置为 true，如果没有提供属性名，就等价于把该属性设置为 false。因此，上述代码也可以写成：1&lt;p contenteditable&gt;这是一个可编辑的段落。&lt;/p&gt; 非常有趣的是，如果在现代浏览器地址栏输入data:text/html, &lt;html contenteditable&gt;，即可打开一个简单的在线文本编辑器。 1.2.2.9 hidden属性hidden属性用来规定元素是否在页面上显示出来。该属性是布尔属性，取值为 true | false，默认值为true。true 表示显示元素，false 表示不显示元素。 假设整个页面上只有一个段落，它被设置了 hidden属性：1&lt;p hidden&gt;You can't see me!&lt;/p&gt; 当一个元素设置了hidden属性后，它的表现跟CSS的 display: none 作用非常相似，元素将会消失，而且不占用任何页面空间。因此，运行上述代码，页面空空如也，看不到任何内容。 1.2.2.10 lang属性lang属性用来规定元素内容所使用语言，其值为语言标记。语言标记用于帮助识别说话、书写、或其他方式进行交流时的语言。格式为：123456langtag = language [\"-\" script] [\"-\" region] *(\"-\" variant) *(\"-\" extension) [\"-\" privateuse] 由于 extension 和 privateuse 很少有人使用，这里只对比较常用的language、script、region、variant 进行简单介绍： 1）language表示语言的文字种类，该属性对 base、br、frame、frameset、hr、iframe、param、script 等这些元素无效。语言的文字种类包含主要语言文字种类和扩展语言文字种类两部分内容，两者之间通过 “-“ 连接起来。主要语言文字种类可以是 2 个字母，如zh（中文）、en（英文），也可以是 3 个字母，如cmn（普通话或國語发音）、yue（粤语发音）；扩展语言文字种类必须为3个字母，如cmn、yue、lzh（Literary Chinese，文言文）。 2）script表示文本的书写格式，必须是4个字母，如Hans（s 表示 simplified，即简体中文）、Hant（t 表示 traditional ，即繁体中文）。 3）region表示语言的国家地区，可以为2个字母，如CN（中国）、HK（香港），也可以为3个字母。 4）variant表示方言，它必须在IANA注册后，才能使用。 以下代码定义了三个段落，第一个段落的语言为文言文的简体中文，第二个段落的语言为文言文的繁体中文，第三个段落的语言为简体中文的大陆语言（非香港语言）：123&lt;p lang=\"zh-lzh-Hans\"&gt;驴不胜怒，蹄之&lt;/p&gt;&lt;p lang=\"zh-lzh-Hant\"&gt;驢不勝怒，蹄之&lt;/p&gt;&lt;p lang=\"zh-Hans-CN\"&gt;驴非常愤怒，用蹄子踢它&lt;/p&gt; 浏览器渲在染页面时，并不关心 lang属性，无论 lang属性的值是什么，它都会将元素中的文本内容原封不动显示出来。 然而，搜索引擎、语音合成工具、翻译工具等，却要通过 lang属性来确定内容所使用的语言。因此，强烈建议为 html 根元素或某些特定语言的元素指定 lang属性，来为文档或相应元素设置正确的语言，这将有助于搜索引擎根据语言搜索、或语音合成工具根据语言确定发音、或翻译工具根据语言确定遵守的规则等等。 1.2.2.11 translate属性translate属性规定是否应该翻译元素的内容，目前为止，所有主流浏览器都无法正确地支持 translate属性。 1.2.2.12 spellcheck属性spellcheck属性规定是否对元素的文本内容进行拼写或语法检查。只有当元素在可编辑状态时，sepllcheck属性才有意义。因此，一般是针对input[text]、textarea、contenteditable属性值为 true 的元素进行拼写和语法检查。如：1&lt;textarea cols=\"53\" rows=\"3\" spellcheck &gt;&lt;/textarea&gt; 设置 spellcheck属性后，浏览器会帮助对元素的文本内容进行拼写或语法检查，若发现拼写或语法错误，则用红色的波浪下划线进行标识。 当在被标识的文本上单击鼠标右键，浏览器就会给出相应的提示，供用户选择。 1.2.2.13 data- * 属性data-*属性允许开发人员为一个元素自定义私有属性，通过这些私有属性的值来存储页面或应用程序的私有数据。如，1&lt;p id=\"user\" data-user-list=\"Bill Gates,Bill Clinton\"&gt;用户列表&lt;/p&gt; 一个元素允许定义多个私有属性，属性值可以是任意字符串，但属性名不允许包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符。 定义私有属性后，就可以通过 Javascript 读写私有属性的值。可以通过 dataset 对象的 “.” 操作，也可以通过 setAttribute() 和 getAttribute() 方法来操作私有属性的值。 1）使用 dataset 对象 当使用 dataset 对象时，属性名要去掉 “data-“ 前缀，如果属性名中包含连字符，还需要转化为驼峰命名。因此，上述代码中，私有属性名为 user-list，当使用 dataset 对象操作私有属性时，需要转化为驼峰命名，即userList。如：123var user = document.getElementById(\"user\");alert(user.dataset.userList); // 读取属性值user.dataset.userList = \"Barack Hussein Obama\"; // 设置属性值 当然，也可以使用 jQuery，不过要记住的是，jQuery使用的是 data 方法来操作私有属性。如：12alert($(\"#user\").data('userList')); // 读取属性值$(\"#user\").data(\"userList\", \"Barack Hussein Obama\"); // 设置属性值 2）使用 setAttribute() 和 getAttribute() 方法 由于 setAttribute() 和 getAttribute() 方法可以操作任何属性，它并不关心这个属性是否为私有属性。因此，属性名不必去掉 “data-“ 前缀，也无需转化为驼峰命名。如：12alert(user.getAttribute(\"data-user-list\")); // 读取属性值user.setAttribute(\"data-user-list\", \"Barack Hussein Obama\"); // 设置属性值 1.2.3 HTML注释在HTML代码中，标签之间的文本是文档的注释，注释的内容不会被显示在浏览器页面上。只有在文本编辑器中，或浏览器的“查看源代码”选项打开文档时，才能看到注释。 HTML中的注释有两种类型，一种是HTML代码注释，一种是IE条件注释。 1、HTML代码注释 在一个大文档中，通过注释来标明区块的开始合结束的位置，可以方便查找，也可以通过注释来阻止某些内容显示。 当编写了大量代码时，对关键代码进行注释是一个良好的习惯，通过注释来说明某段代码的意图，有助于提醒自己或需要在这个网站上工作的其他人，了解这段代码的作用。 2、IE条件注释 IE条件注释（Conditional comments），是IE浏览器对HTML代码注释的一种扩展，它是一种非标准逻辑语句，可以灵活的为不同版本的IE导入不同html元素，如样式表、html标签等。 条件注释在IE5首次出现，并得到后续版本的支持，其语法就是一个普通的HTML注释，IE以外的浏览器会把它作为注释而忽略。因此，它能通过W3C的校验，也不会对其他浏览器造成影响。 条件注释的功能非常强大，可以进行 if 条件判断，并根据判断结果是true 或 false，来决定是否要解析条件注释里的内容。 条件判断以&lt;!--[if 条件]&gt; 开始，以&lt;![endif]--&gt;结束，可以根据IE、非IE进行判断，还可以根据IE的版本号进行判断，版本号可以精确到小数点后4位。如：12&lt;!--[if IE]&gt; &lt;![endif]--&gt; /* 所有IE，无论哪个版本 */&lt;!--[if IE 6]&gt; &lt;![endif]--&gt; /* 如果IE版本是6 */ 条件判断中，还支持大于（gt: greater than）、小于（lt: less than）、大于等于（gte: greater than or equal）、小于等于（lte: less than or equal）、或（|）、与（&amp;）、非（!）、括号。如：12345&lt;!--[if gt IE 6]&gt; &lt;![endif]--&gt; /* 如果IE版本大于6 */&lt;!-- [if lte IE 9]&gt; &lt;![endif]--&gt; / * 如果IE版本小于等于9 * /&lt;!--[if IE 6 | IE 7]&gt; &lt;![endif]--&gt; /* 如果IE版本是6或7 */&lt;!--[if ! IE 5.5]&gt; &lt;![endif]--&gt; /* 如果IE版本不是5.5 */&lt;!-- [if (gt IE 6) &amp; (lte IE 9)]&gt; &lt;![endif]--&gt; / * 如果IE版本大于6，且小于等于9 * / 借助条件注释，可以解决很多IE兼容性问题。如，IE9以下的版本不支持HTML5的新元素 header、nav、aside、footer等，而在Internet上存在大量的 html5shiv脚本可以解决该问题。只需下载相应的脚本，并在页面的头部，通过IE条件注释，让IE9以下的版本加载该脚本，就可以让这些老浏览器支持HTML5的新元素。123&lt;!--[if lt IE 9]&gt;&lt;script src=\"http://html5shiv.googlecode.com/svn/trunk/html5.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 也可以使用同样的方法，来解决CSS的兼容性问题。如，IE6不支持一些CSS新特性，就可以专门针对IE6编写CSS文件，并只让IE6加载它：123&lt;!--[if IE 6]&gt;&lt;link rel=\"stylesheet\" href=\"css/ie6.css\" /&gt;&lt;![endif]--&gt; 一个好消息是，从IE10版本开始，不再支持条件注释。这标志着IE从此走向成熟、走向标准，Web设计师再也不必为IE的兼容性问题所困扰了。 1.3 HTML文档结构HTML文档，也被称为网页，包括头部和主体两大部分。头部主要描述浏览器和搜索引擎所需要的信息，浏览器不会将这些信息呈现给访问者；主体是文档的正文，是网页中真正要传达的信息，这些信息将在浏览器窗口的正文部分呈现给访问者。 HTML文档总是以 标签开始，以 标签结束，在 &lt;head&gt;…&lt;/head&gt; 标签之间的内容是头部信息，&lt;body&gt;…&lt;/body&gt; 标签之间的内容是主体部分，即文档的正文。此外，还要在文档的最开头，通过 &lt;!DOCTYPE&gt; 声明这是一个HTML文档。12345&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.3.1 &lt;!DOCTYPE&gt;&lt;!DOCTYPE&gt; 声明必须是HTML文档的第一行，位于 &lt;html&gt; 标签之前。该声明不是HTML标签，它是告诉浏览器该HTML文档的DTD类型（Document Type Definition，文档类型定义）。 在HTML5之前，有多种DTD类型，分别为Transitional类型、Strict类型、Frameset类型，而不同类型对文档标签严格程度的要求不同，并且&lt;!DOCTYPE&gt;的写法非常复杂，估计也没有人能够完全记住这些写法，这给开发带来了混乱。 到HTML5之后，一切化繁为简，只需声明&lt;!DOCTYPE html&gt;即可，它就告诉浏览器，该文档是一个HTML5文档。 1.3.2 HTML根元素HTML文档的根元素是 html 元素，从 &lt;html&gt; 标签开始，到 标签结束。根元素的作用就是告诉浏览器，在 &lt;html&gt; 和 &lt;/html&gt; 之间的内容是HTML类型，浏览器便按HTML进行解析其中的内容。 html 元素有两个属性，分别是 lang属性和 manifest 属性： lang属性指定页面内容所使用的默认语言。指定文档所使用的语言，有助于语言合成工具选择发音语言，或者翻译工具选择翻译规则。如，&lt;html lang=&quot;zh&quot;&gt;，表示本文档使用中文。 manifest属性给出离线缓存文件的URL。HTML5 引入了应用程序缓存，这意味着 web 应用可被缓存，并可进行离线访问。如，&lt;html manifest=&quot;waibo.manifest&quot;&gt;，表示离线缓存文件为waibo.manifest。 1.3.3 HTML头部head元素用于定义文档的头部信息，出现在 &lt;head&gt;…&lt;/head&gt; 标签之间的内容，是文档的头部信息。头部定义的内容不会在浏览器窗口的正文部分显示出来。 head元素比较特殊，只有一些特定的标签才允许放在 &lt;head&gt; 标签内，它们分别是 &lt;title&gt;、&lt;base&gt;、&lt;meta&gt;、&lt;scirpt&gt;、&lt;link&gt;、&lt;style&gt;，接下来对这些标签进行分别介绍。 1.3.3.1 &lt;title&gt;标签&lt;title&gt;标签的唯一作用，就是定义页面的标题，标题是对当前页面核心内容的一个简短的、概括性描述。在大多数浏览器中，页面的标题被显示在浏览器窗口或标签页的标题栏，还会出现在访问者浏览历史列表和书签中。 更重要的是，搜索引擎会通过页面的标题来大致了解页面的内容，并将页面的标题作为搜索结果中每一个条目的链接文本，也是判断搜索结果中页面相关度的重要因素。因此，页面标题是SEO的重要内容，一个好的页面标题可以提升搜索引擎的结果排名，并能获得更好的用户体验。 1.3.3.2 &lt;base&gt;标签&lt;base&gt;标签是一个单标签，它为页面上的所有链接规定默认地址和默认目标窗口，并通过 href 属性设置默认URL地址，通过 target 属性设置默认目标窗口。 规定默认地址或默认目标窗口后，点击页面上的任何链接时：对未带http的链接，浏览器会在地址前插入base中 href 设置的URL地址；对未设置 target 属性的链接，会按base中 target 设置的目标打开窗口。 &lt;base&gt;标签的主要作用，是确保网页中所有的相对URL都可以被解析为正确的地址，以便在文档被移动的情况下，所有的相对URL都能够被正确解析。 1.3.3.3 &lt;meta&gt;标签标签又叫“元数据标签”，是网页头部的一个辅助性标签，用于为网页定义元数据（metadata）信息，一般用来定义页面的关键字、页面的描述等。 标签提供的信息对用户不可见，也不会显示在页面上，但却对搜索引擎可见，可以方便搜索引擎蜘蛛搜索到这个页面上的信息。因此，这些信息都是SEO的重要内容，可以大大提高网站被搜索引擎搜索到的可能性。 标签共有两个重要属性，分别是 name 属性和 http-equiv 属性，并通过 name 或 http-equiv属性来指定元数据的类型，通过 content 来指定元数据的内容，不同的元数据实现了不同的网页功能。 1、name属性 name属性主要用于描述网页，最常见的就是描述网页的关键字、网页内容描述、搜索引擎向导、作者、版权声明等，以便搜索引擎对网页的信息进行查找和分类。如：1234567&lt;head&gt;&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;Study HTML, CSS&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;&lt;meta name=&quot;author&quot; content=&quot;M&quot; /&gt;&lt;meta name=&quot;copyright&quot; content=&quot;233&quot; /&gt;&lt;/head&gt; name属性的主要取值及功能见表属性值|功能描述:–:|:–:keywords|网页的关键字。通常指定网页的核心关键字列表，各关键字间用英文逗号隔开description|网页的主要内容。通常是网页内容的概括描述，以方便搜索引擎蜘蛛抓取网页的内容robots|页面是否允许被索引，以及页面上的链接是否允许被查询，取值all、none、index、noindex、follow、nofollow，index 表示页面允许被索引，follow 表示页面上的链接允许被查询。默认值是all，即允许文件被索引，且页面上的链接允许被查询author|注明网页的作者，其内容可以是作者的名字、Email、微博、微信等任何联系信息copyright|注明网页的版权信息 2、http-equiv属性 顾名思义，http-equiv 就相当于HTTP头部的作用，用于向浏览器提供一些有用的信息，以帮助浏览器正确和精确地显示网页内容。 http-equiv属性主要用定义网页的编码字符集、刷新频率、网页的有效期等： 1）网页的编码字符集 在HTML4中，通过Content-Type属性值来指定文件的媒体格式类型（MIME类型）和所使用的编码字符集，浏览器将以此来决定以什么形式、什么编码来读取这个文件，并显示文件的内容。 HTML文件的MIME类型固定为text/html，而编码字符集可以根据需要来指定。如：12&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\"&gt; 到了HTML5，一切化繁为简，只需在 meta 元素中，直接使用 charset 属性来定义网页所使用的编码字符集即可。如：1&lt;meta charset=\"utf-8\" /&gt; 在HTML5中，上述两种方式均有效，但只能使用一种，不能同时混合使用两种方式。并且，推荐使用 utf-8 编码字符集。 2）刷新频率Refresh 通过 refresh 属性值来指定让网页多长时间（秒）刷新自己，或在多长时间后自动跳转到指定的网页。如，让网页在当前页面停留 5 秒后，自动跳转到 http://www.w3school.com.cn/1&lt;meta http-equiv=\"refresh\" content=\"5; url=http://www.w3school.com.cn/\" /&gt; 3）网页的有效期 通过Expires属性值来指定网页在缓存中的过期时间，一旦网页过期，必须从服务器上重新加载。时间必须使用GMT格式（格林威治时间格式）。如：1&lt;meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2099 23:00:00 GMT\" /&gt; 1.3.3.4 样式表样式表，即CSS（Cascading Style Sheet层叠样式表），用它来控制网页的表现，如果要让网站看起来很吸引人，就离不开CSS。 在HTML文档的头部，可以通过两种方式来为网页定义样式： (1) 使用link元素 在HTML文档的头部，可以通过link元素链接到外部样式表，让网页应用该外部样式表定义的样式规则。 在link 标签中，通过的 rel 属性来定义本HTML文档与被链接文档之间的关系，rel = “stylesheet” 表明引入的文件是样式表；通过href属性定义外部资源（即CSS文件）的URL地址，URL可以是相对路径，也可以是相对路径，相对路径是相对于本HTML文档而言的。 可以在一个HTML文档中添加多个 link 元素，让它们分别指向不同的样式文件，就可以给一个网页添加多个样式表。 由于 link 元素为空元素，它只有开始标签，没有结束标签，所以，要在开始标签的结尾处加上 / 来结束该元素。如：1&lt;link rel=\"stylesheet\" href=\"reset.css\" /&gt; 上述代码表示，为本文档引入文件名称为 reset.css 的外部样式表，该样式表文件与本文档位于相同目录下。 (2) 使用style元素 可以在HTML文档的头部插入一个 style 元素，让网页应用该 style 元素中定义的样式规则。如：1234&lt;style&gt;body &#123; background-color:yellow; &#125;p &#123; color:blue; &#125;&lt;/style&gt; 1.3.3.5 脚本在HTML文档中，可以通过Javascript 脚本主要用来定义特殊的行为，但Javascript并不是必需的。 大多数情况下，Javascript 都是在由HTML和CSS 构建的核心体验的基础上，增强访问者的体验，主要用来增强页面的交互性，如实现表单验证、动态显示隐藏内容、加载数据并动态地更新页面、操作 audio 和 video 元素控件等等。 HTML文档中，有两个用于标识脚本的元素，它们是 script 元素和 noscript 元素： 1、script 元素 script 元素既可以直接在页面中嵌入Javascript脚本，也可以从外部文件加载脚本。 (1) 嵌入脚本 就是直接在 script 元素中书写Javascript代码。如：123&lt;script&gt; alert(\"Hello, world!\");&lt;/script&gt; 一个HTML文档，也支持多个 script 元素。这种方式定义的脚本，只对本文档有效，并且脚本代码需要放在HTML文件，而不是脚本文件中，脚本通常会散落在多个地方，不便于维护，也容易出错。所以，不推荐使用这种方法。 (2) 加载外部脚本 通过 script 元素的 src 属性指定外部脚本文件的URL，可以把外部脚本加载到本HTML文档中。URL可以是绝对路径，也可以是相对路径。相对路径是相对本HTML文档而言的。 在一个HTML文档中，可以添加多个 script 元素，让它们分别指向不同的脚本文件，就可以为一个网页载入多个脚本文件。当加载外部脚本时，script 元素必须是空元素，即在开始和结束标签之间不得有任何内容。如：1&lt;script src=\"engine.js\"&gt;&lt;/script&gt; 上述代码表示，文档会载入外部脚本，脚本文件名称是engine.js，脚本文件与本HTML文档位于相同目录下。 这种方式是最好的引入的脚本方法，多个页面可以加载同一个脚本文件。并且，脚本存放在单独的文件中，需要对脚本进行修改时，只需编辑一个文件，而不是在各个页面中更新相似的脚本，维护起来极其方便。 2、noscript 元素 noscript 元素是一个检测工具，当检测到 script 中的脚本内容无法执行时，即如果浏览器不支持Javascript或用户禁用了Javascript时，就会显示 noscript 元素中的文本。如：1&lt;noscript&gt;您的浏览器不支持Javascript&lt;/noscript&gt; 注意：默认情况下，浏览器会按照脚本在HTML中出现的顺序，依次对每个脚本进行下载（对于外部脚本）、解析和执行。在处理脚本的过程中，浏览器既不会下载该 script 元素后面出现的内容，也不会呈现这些内容，这称为阻塞行为（blocking behavior）。这条规则对嵌入脚本和外部脚本都有效。可以想象，阻塞行为会影响页面的呈现速度，影响的程度取决于脚本的大小和它执行的动作。因此，建议最好在页面的最末尾加载脚本，即应该尽可能地将脚本元素放在的前面，而不是放在 head 元素中。 1.3.4 HTML主体 标签用于定义文档的正文内容，成对出现。在&lt;body&gt;… &lt;/body&gt;之间的内容即为页面的主体内容，可以是文本、图像、音频、视频、表单及其他交互式内容，它们才是真正要在浏览器中显示，并让访问者看到的内容。 由于HTML元素可以相互嵌套，通过元素层层嵌套，就构成了千变万化的网页。当一个元素包含另一个元素时，把外层元素称作父元素，内层元素称作子元素。子元素还可以再包含子元素，子元素中包含的任何元素，都是外层父元素的后代。 需要注意的是，当一个元素中包含其他元素时，每个元素都必须正确的嵌套，这些元素的开始标签和结束标签对，不允许相互交叉。 1.4 动态网页技术从网页的主要构成来说，一个标准的网页一般有4个部分组成：内容、结构、表现和行为。 内容是网页中要传达的信息，包括文本、数据、图片、视频等，一般由HTML（XHTML）来完成，也就是页面中的各种页面元素对象，它们是被动态操纵的内容； 结构是使用结构化的方法对网页中用到的信息进行分类和整理，使内容更具条理性、逻辑性和易读性； 表现是使用表现技术对已经结构化的信息进行表现上的控制，如版式、文本大小、文本颜色等，一般由CSS来完成； 行为就是网页的交互操作，实现对网页的动态控制，一般由Javascript、AJAX等技术完成，用它来操纵Web页上的HTML和CSS。 在这4部分中，内容可以由HTML来实现，结果由DOM，表现通过CSS技术实现，行为一般通过javascript技术实现。 DHTML是Dynamic HTML的简称，称作动态HTML，它是相对传统的静态的HTML而言的一种制作网页的概念。 其实，DHTML并不是一门新的语言，它只是HTML、CSS和客户端脚本的一种集成，即一个页面中包括html+css+javascript，其中css和客户端脚本是直接在页面上写而不是链接上相关文件。DHTML不是一种技术、标准或规范，也不是一门新的语言，只是一种将目前已有的网页技术、语言标准整合运用，制作出能在下载后仍然能实时变换页面元素效果的网页设计概念。 DHTML 是一种使 HTML 页面具有动态特性的艺术，是一种创建动态和交互 WEB 站点的技术集。对大多数人来说，DHTML 意味着 HTML、CSS和 JavaScript 的组合。 使用DHTML技术，可使网页设计者创建出能够与用户交互并包含动态内容的页面。实际上，DHTML使网页设计者可以动态操纵网页上的所有元素——甚至是在这些页面被装载以后。利用DHTML，网页设计者可以动态地隐藏或显示内容、修改样式定义、激活元素以及为元素定位。DHTML还可使网页设计者在网页上显示外部信息，方法是将元素捆绑到外部数据源（如文件和数据库）上。所有这些功能均可用浏览器完成而无需请求Web服务器，同时也无需重新装载网页。这是因为一切功能都包含在HTML文件中，随着对网页的请求而一次性下载到浏览器端。 通过 DHTML，Web 开发者可控制如何在浏览器窗口中显示和定位 HTML 元素。通过 HTML 4.0，所有的格式化（信息）可移出HTML文档，并写入一个独立的样式表中。 通过 CSS，就得到了一种用于 HTML 文档的样式和布局模型，它使开发者有能力同时控制多个网页的样式和布局。并把文档的表现从其结构中分离，在不搞乱文档内容的情况下，自由控制网页的表现。 HTML DOM 是针对 HTML 的文档对象模型，它定义了针对 HTML 的一套标准的对象，以及访问和处理 HTML 对象的标准方法，它允许程序和脚本动态地访问和更新文档的内容、结构及样式。 二、HTML元素2.1 结构语义元素所谓语义元素，就是为元素（标签）赋予了某种意义，元素的名称就能能清晰表达元素的作用。 使用结构语义元素，可以使页面结构清晰、易于维护，有助于屏幕阅读器和其他辅助工具的读取，有利于搜索引擎机器人快速了解页面结构，收集页面的信息。 HTML4中的结构语义元素只有标题元素 h1~h6，HTML5中，又新增了article、section、nav、main、aside、header、footer、address 这些结构语义元素，元素名称能够望文生义，从名称就可以看出元素的功能，如，nav 表示导航、footer 表示页脚等。 2.1.1 h1~h6元素在HTML中，共有6级标题，分别是h1、h2、h3、h4、h5、h6，标题的重要性是有区别的，h1 表示一级标题，也是最重要的标题，h2 表示二级标题，以此类推。默认情况下，浏览器会把标题渲染为加粗字体，h1的字体最大，h6的字体最小，表示内容的重要性逐级降低。并且，为了防止标题和内容过分拥挤，浏览器通常会在标题的上下，各留出一定的间隙。 对于任何页面来说，分级标题都可以说是最重要的HTML元素，标题通常传达的是页面的主题，因此，对搜索引擎而言，如果标题与搜索词匹配，这些标题就会赋予很高的权重。 在构建一篇复杂文档时，建议把各章、节、小节的标题封装在h1~h6标题中，把每一章的内容封装在 article 元素中，把节和小节的内容封装在 section 中。这样，整个文档的结构就非常清晰，对搜索引擎也非常友好。 2.1.2 header元素header元素是一种具有引导和导航作用的结构元素，通常表示整个页面或页面上的一个内容块的头部，它可以包含标题元素 h1 ~ h6（当并非必需的），也可以包含其他的内容，如导航、logo、搜索表单等等。 如果一个页面上包含多个内容块，就可以为每个内容块分别加上一个header元素，也就是说，一个页面上可以有任意数量的 header元素，它们的含义可以根据上下文而有所不同。 出现在页面的顶端或接近这个位置的 header元素，就成为整个页面的页眉，页眉通常会包含网站的logo、网站名称、网站主导航、甚至搜索框等。1234567891011121314151617&lt;body&gt;&lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/games\"&gt;Games&lt;/a&gt; &lt;li&gt;&lt;a href=\"/forum\"&gt;Forum&lt;/a&gt; &lt;li&gt;&lt;a href=\"/download\"&gt;Download&lt;/a&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;h1&gt;Little Green Guys With Guns&lt;/h1&gt; &lt;h2&gt;Important News&lt;/h2&gt; &lt;p&gt;To play today's games you will need to update your client.&lt;/p&gt; &lt;h2&gt;Games&lt;/h2&gt; &lt;p&gt;this starts a third subsection.&lt;/p&gt;&lt;/header&gt;&lt;/body&gt; header元素也很适合作为页面上的一组介绍性内容的头部，此时，就会稍微简单一点，通常会包含其自身的 h1 ~ h6 标题等信息：123456&lt;section&gt; &lt;header&gt; &lt;h1&gt;Voidwars!&lt;/h1&gt; &lt;p&gt;Welcome to...&lt;/p&gt; &lt;/header&gt;&lt;/section&gt; 当然，应该只在必要时使用 header元素，大多数情况下，如果使用 h1~h6 就能满足需求，就没必要用 header 将它们包起来。不能在 header 里嵌套 footer 或 另一个 header元素，也不能在 footer 或 address 元素里嵌套 header元素。 2.1.3 nav元素nav元素代表页面的导航区域，通常包含一组比较重要的导航链接，这些链接可以指向当前页面的其他部分，也可以指向其他页面或资源。如，使用 nav元素定义页面的主导航：123456789&lt;nav&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;产品中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;工程案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新闻动态&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;联系我们&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt; 一个页面中可以存在多个nav元素，作为页面整体或者不同部分的导航。但是，并非页面上的所有链接组都要包含在 nav元素中，只有具有导航作用的链接才适用。如，页脚中的友情链接，虽然它们是一个链接组，把它们包含在 nav元素中却不合适。 2.1.4 main元素main元素代表文档的主内容区，它应当与文档直接相关，或者是文档的中心主题的扩展，并且，应当是文档中独一无二的，不会在文档中其他任何地方（如，侧边栏、导航栏、版权信息、搜索框）重复出现的内容。1234567891011121314151617181920&lt;!-- other content --&gt;&lt;main&gt; &lt;h1&gt;Skateboards&lt;/h1&gt; &lt;p&gt;The skateboard is the way cool kids get around&lt;/p&gt; &lt;article&gt; &lt;h2&gt;Longboards&lt;/h2&gt; &lt;p&gt;Longboards are a type of skateboard ...&lt;/p&gt; &lt;p&gt;... &lt;/p&gt; &lt;p&gt;... &lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;Electric Skateboards&lt;/h2&gt; &lt;p&gt;These no longer require ...&lt;/p&gt; &lt;p&gt;... &lt;/p&gt; &lt;p&gt;... &lt;/p&gt; &lt;/article&gt;&lt;/main&gt;&lt;!-- other content --&gt; 一个页面中只能有一个main元素，不能将 main元素放在 article、aside、header、footer、nav 元素的里面，即main元素的级别不能低于这些元素。 2.1.5 article元素article元素代表文档、页面、应用程序、或网站中一个独立的、完整的、可以独自被外部引用的内容，它可以是一篇论坛帖子、一篇文章、一篇新闻报道、一篇博客文章等任何独立的内容块，它通常有自己的标题、页脚等。因此，article元素里面可包含独立的 header、footer 等结构化元素。如：1234567891011&lt;article&gt; &lt;header&gt; &lt;h1&gt;The Very First Rule of Life&lt;/h1&gt; &lt;p&gt;&lt;time datetime=\"2016-8-8\"&gt;3 days ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt;&lt;p&gt;If there's a microphone anywhere ...&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;footer&gt; &lt;a itemprop=\"discussionUrl\" href=\"?comments=1\"&gt;Show comments...&lt;/a&gt;&lt;/footer&gt;&lt;/article&gt; 上述代码通过一个article元素，定义了一篇完整的文章，文章由三部分组成，分别是头部、正文和尾部。头部和尾部则通过独立的 header、footer 结构化元素来定义，使文章的结构非常清晰。 一个页面可以有多个 article元素（也可以没有），如博客的主页通常包括多篇文章，每篇文章就可以是一个 article元素。并且，可以将一个 article元素嵌套在另一个 article元素中，主要内层的 article元素与外层 article元素是部分与整体的关系。在 article元素元素中包含独立的 h1~h6 标题，也是很好的做法。 2.1.6 section元素section元素代表文档或应用的一个一般的区块，一个区块通常是具体相同主题的一组内容通常会包含一个标题元素（h1~h6），通过标题元素来确定一个区块的主题。如：1234567891011121314&lt;article&gt; &lt;header&gt; &lt;h1&gt;The Very First Rule of Life&lt;/h1&gt; &lt;p&gt;&lt;time datetime=\"2016-8-8\"&gt;3 days ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;Red Delicious&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;Granny Smith&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; section 可以是章节、标签式对话框中的各种标签页、论文值带编号的区块。如网站的主页可以分成介绍、新闻条目、联系信息的区块。 可以将 section 嵌套在 article 中，来显式的标示出一篇文章、一篇新闻报道、一篇博客等文章的不同部分或不同章节。 当然，如果一块内容仅仅在视觉上是一个整体，语义上并非一个主题，建议使用 div，而不要使用 section元素。 2.1.7 aside元素aside元素代表跟文档的主内容区相关，但它又独立于主内容区，并且可以被单独拆分出来，而不会对整体内容产生影响。 aside通常表现为侧边栏、说明、提示、引用、附加注释、广告等。如，在经典的页面布局中，页面被分为 header、main、aside、footer 四个部分：12345&lt;body&gt;&lt;header&gt;header&lt;/header&gt;&lt;main&gt;main&lt;/main&gt;&lt;aside&gt;aside&lt;/aside&gt;&lt;footer&gt;footer&lt;/footer&gt;&lt;/body&gt; 顶部header中间左侧main 右侧aside底部footer 在这个经典布局中，aside 就表现为侧边栏，通常用来放置非主要内容，如个人信息、博客的相关链接、广告等。 考虑到内容优先、可访问性（特别是对使用屏幕阅读器的用户）和SEO，在HTML代码中，应该将 aside元素放在 main 元素之后，然后通过CSS来改变它们的显示顺序。 2.1.8 footer元素footer元素代表整个页面、文章或区域的页脚（或脚注），常常位于页面或内容块的结尾，通常包含页面或内容块的脚注信息，如作者、版权、相关文档的链接、联系信息等。 如果 footer元素是 body 元素的子元素，它就成为整个文档的页脚，通常出现在页面的结尾，并包含一组链接、版权、许可协议等信息。如：1234567891011&lt;body&gt;&lt;footer&gt;&lt;p&gt; &lt;a href=\"\"&gt;关于我们&lt;/a&gt; | &lt;a href=\"\"&gt;联系我们&lt;/a&gt; | &lt;a href=\"\"&gt;网站地图&lt;/a&gt; | &lt;a href=\"\"&gt;诚聘英才&lt;/a&gt; | &lt;a href=\"\"&gt;商务合作&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Copyright © 2016&lt;/p&gt;&lt;/body&gt; 如果 footer元素是 article 或 section 元素的子元素，它就成为文章或内容块的脚注，其中可以包含相关文章的链接、文章的发布日期、分类等。如，可以用来显示“上一篇”、“下一篇”的链接：123456&lt;article&gt; ... &lt;footer&gt; &lt;a href=\"#\"&gt;上一篇&lt;/a&gt; | &lt;a href=\"#\"&gt;下一篇&lt;/a&gt; &lt;/footer&gt;&lt;/article&gt; 当然，footer元素并不一定总是在页面、文章或区域的结尾，但是它通常是在那个位置。并且，一个页面里可以有多个 footer元素，出现次数也没有限制。 2.1.9 address元素address元素用来定义整个页面、文章或区域的作者或拥有者的联系信息，可以包括作者或拥有者的名字、站点链接、电子邮箱、真实地址、电话号码等各类联系信息。标记为联系信息后，可以让屏幕阅读器和搜索引擎找到地址或电话号码。 address 一般放在 footer 中，有时也放在 header 中，视情况而定。大多数浏览器会在 address元素的前后添加一个换行符，当然，如果必要的话，也可以根据需要在 address 的内容中添加额外的换行符。如：12345&lt;address&gt;Email: &lt;a href=\"mailto:contact@waibo.wang\"&gt;contact@waibo.wang&lt;/a&gt;&lt;br /&gt;QQ: 123456&lt;br /&gt;Phone: +86 12345678&lt;/address&gt; 默认情况下，浏览器会将 address 的内容呈现为斜体。不过，Web设计师可以根据上下文设置合适的样式。 需要注意的是，address 的字面意是“地址”，但其实并非如此。HTML5规范明确指出，address 代表文档或者文章作者或拥有者的联系信息。这很容易发生混淆，因此，笔者认为这个元素的名称还是改为 contact 比较合适。 2.2 内容分组元素2.2.1 div元素div元素可以把文档分割为独立的、不同的区域，每个区域就相当于一个块级容器，其中可以放置段落、标题、表格、图片、乃至任何HTML元素。 事实上，div元素本身并没有任何特定的语义，它的真正目的是把页面进行分块，然后通过CSS对它们进行格式化，来实现页面布局，也就是传说中的 DIV + CSS 布局。因此，可以说 div元素是一个通用容器，一个没有任何语义的容器。 如，使用 div元素把页面划分为 .header、.main、.aside、.footer 四个部分：12345&lt;body&gt;&lt;div class=\"header\"&gt;header&lt;/div&gt;&lt;div class=\"main\"&gt;main&lt;/div&gt;&lt;div class=\"aside\"&gt;aside&lt;/div&gt;&lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt; 由于 div元素自身没有任何默认样式，因此，通过CSS控制各部分的样式，可以轻松实现任何想要的布局，包括经典的页面布局。 CSS是Cascading Style Sheet的简称，中文含义为“层叠样式表”，简称“样式表”，是W3C推出的格式化网页内容的标准技术，是网页设计者必须掌握的核心技术之一。 DIV + CSS是Web设计标准，它是一种网页的布局方法，能够真正做到网页表现与内容相分离。 2.2.2 p元素HTML会忽略在文本编辑器中输入的回车符合其他额外的空格，要在网页中开始一个新的段落，应该使用p元素（p 是 paragraph 的缩写）。 p元素是一个有特定语义的元素，以 标签开始，以 标签结束。但是，当 p元素后紧跟 address、article, aside、blockquote、div、dl、fieldset、footer、form、h1~h6、header、hgroup、hr、main、nav、ul、ol、p、pre、section、table元素时，或 p元素的父元素中再没有其他内容时，可以省略结束标签。 p元素最常见的用法就是放置文本，浏览器会在每个段落结束的地方，自动插入一个换行符，让段落自动换行。并且，为了防止段落之间过于拥挤，大部分的浏览器都在段落与段落之间设置一定的空白。 段落中除了可以放置文本外，还可以放置其他元素，如在表单中使用 p元素来对表单元素进行分块。如：12345&lt;fieldset&gt; &lt;legend&gt;用户登录：&lt;/legend&gt; &lt;p&gt;&lt;label&gt;用户名: &lt;input name=\"user\"&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;密 码: &lt;input name=\"password\"&gt;&lt;/label&gt;&lt;/p&gt;&lt;/fieldset&gt; 另外，还可以使用 br 元素来段落内部手动强制换行。 2.2.3 hr元素hr元素用于创建一个水平分隔线（horizontal rule），可以在视觉上将文档分隔成不同的部分。hr 标签是一个单标签，需要使用“/”来正确地关闭，其格式为 。 2.2.4 pre元素一般情况下，浏览器会将网页中所有额外的回车和空格进行压缩，并根据窗口的大小自动换行。如果希望文本能够按预先定义好的格式原样显示，就可以使用pre元素。 pre元素表示一块被格式化的文本，其作用是保留原始文本的排版效果，也就是说，被包围在 pre元素中的文本，通常会保留回车、换行、空格、制表符等。因此，它是展示计算机程序源代码的理想元素。 当用 pre元素来展示源代码时，最好的方式是用 code 元素来包裹代码，这样既可以保持格式，又不失其语义。1234567&lt;pre&gt;&lt;code&gt; for (int i = 0; i &lt; 10; i++) &#123; printf(\"Hello world!\\n\"); &#125;&lt;/code&gt;&lt;/pre&gt; pre元素中的文本，也可以是HTML元素，如链接、图像和水平分隔线。当把其他标签，如 &lt;a&gt;标签，放到 pre元素中时，会被直接渲染为正常元素。因此，需要将 pre元素中的特殊符号被转换为符号实体。如，将 “&lt;” 转换为 “&amp;lt;“，将 “&gt;” 转换为 “&amp;gt;“ 等等。 2.2.5 figure元素在HTML中，通过 figure元素来定义一块独立的内容，如图像、图表、照片、图形、插图、代码片段等。并且，figure元素的内容应该与主内容相关，而且独立于上下文，如果删除，也不应对文档流产生影响。 在 figure元素中，通过 figcaption元素来定义内容的标题（caption）。figcaption元素并不是必需的，但如果包含它，它就必须是 figure元素的第一个子元素或最后一个子元素。并且，一个 figure元素可以包含多个内容块，但无论 figure元素里面有多少个内容块，最多只允许有一个 figcaption元素。如：1234&lt;figure&gt; &lt;figcaption&gt;Browser market share, April, 2011&lt;/figcaption&gt; &lt;img src=\"broswer.png\"&gt;&lt;/figure&gt; 除图片外，figure元素中还可以放置代码块、视频、音频片段、引用、表格、代码、广告，或任何与这些相关的组合。如，以下代码使用 figure元素来标记核心接口API列表：123456789101112&lt;figure&gt; &lt;figcaption&gt;List4 The primary core interface API declaration.&lt;/figcaption&gt; &lt;pre&gt; &lt;code&gt; interface PrimaryCore &#123; boolean verifyDataLine(); void sendData(in sequence&amp;lt;byte&gt; data); void initSelfDestruct(); &#125; &lt;/code&gt; &lt;/pre&gt;&lt;/figure&gt; 2.2.6 blockquote元素blockquote元素用于定义单独存在的引用，引用的内容可长可短，但必须来自另一个引用源。如果引用源有一个地址的话，还可以通过 blockquote元素的 cite 属性，来提供内容的引用源。 可以使用任意元素来包裹被引用的内容，如使用 figure元素来包裹 blockquote元素，使用 p 元素来对引用的内容进行分段。如果要添加署名，署名应该放在 blockquote元素的外面，如 figcaption 中：12345678&lt;figure&gt;&lt;blockquote cite=\"http://en.wikipedia.org/wiki/Skeptical Enquirer\"&gt;&lt;p&gt;The truth may be puzzling … we desperately want tobe true. &lt;/p&gt;&lt;/blockquote&gt;&lt;figcaption&gt; -- the &lt;cite&gt;Skeptical Enquirer&lt;/cite&gt; Volume 19… (January-February1995)&lt;/figcaption&gt;&lt;/figure&gt; blockquote元素中的所有文本都会从常规文本中分离出来，默认在新行中显示，并在左、右两侧进行缩进（增加外边距），有的浏览器会使用斜体显示。 当然，也可以不使用 blockquote元素的 cite 属性，而是单独使用 cite 元素来定义引用的来源。如：1234&lt;blockquote&gt; &lt;p&gt;The people recognize themselves … split-level home, kitchen equipment. &lt;p&gt; -- &lt;cite&gt;&lt;a href=\"http://en.wiki.org/wiki/Herbert\"&gt;Herbert Marcuse&lt;/a&gt;&lt;/cite&gt; &lt;/blockquote&gt; blockquote和 q的区别本质上，blockquote元素跟 q 元素是一样的，不同之处在于它们的应用和显示。q 元素用于简短的引用，如句子中的引用，而 blockquote 一般用于独立的、较长的引用块，引用的内容必须包括块级元素，如标题、列表、段落或div元素。浏览器会把 blockquote元素显示为一个独立的块，并为它插入换行和外边距；而 q 元素的内容，仅仅是加上双引号而已。 2.2.7 列表元素HTML 包含专门用于创建列表的元素，共有 3 种类型的列表，分别是无序列表、有序列表、描述列表。 可以在一个列表中其他另外一个或者多个列表，并且，一种类型的列表可以与任意类型的列表相互嵌套。列表的表项可以与任何HTML元素（如段落、图片、链接等）交叉定义。 所有的列表都是由父元素和子元素构成，父元素用于指定要创建的列表类型，子元素用于指定要创建的列表项。 2.2.7.1 无序列表无序列表，是指所有表项之间没有先后顺序的列表。如果列表项的顺序不太重要，就要使用无序列表。 无序列表的父元素为 ul（unorder list）元素，列表项为 li（list item）元素。如：12345&lt;ul&gt; &lt;li&gt;表项1&lt;/li&gt; &lt;li&gt;表项3&lt;/li&gt; &lt;li&gt;表项2&lt;/li&gt;&lt;/ul&gt; 默认情况下，无序列表的项目符号为实心圆。不过，可以使用CSS的list-style-type属性来定义项目符号的样式。 2.2.7.2 有序列表有序列表，是指所有表项之间有先后顺序的列表。如果列表项的顺序对于列表来说非常关键，那么这种情况有序列表就是恰当的选择。 使用有序列表的好处是，列表项的序号由浏览器自动维护，可以随意增删列表项，而不必担心序号发生混乱。 有序列表的父元素为 ol（order list）元素，列表项为 li 元素。在 ol 元素中，通过start属性指定列表项的起始编号；通过reversed属性指定列表项的序号是否倒序排列，该属性是布尔类型，如果设置，则会倒序排列。如：12345&lt;ol start = \"3\" reversed&gt; &lt;li&gt;表项1&lt;/li&gt; &lt;li&gt;表项2&lt;/li&gt; &lt;li&gt;表项3&lt;/li&gt;&lt;/ol&gt; 列表项的序号按3、2、1倒序排列。并且，默认情况下，有序列表的项目符号为数字1、2、3，也可以使用CSS的list-style-type属性定义项目符号的样式。 2.2.7.3 描述列表描述列表，是指用于描述成组出现的名称或术语及其值的列表。可以创建由名称和值构成的组合，如术语和定义、元数据和值、问题和答案，以及任何其他的名/值组。 在HTML5中，把这种列表称作描述列表（description list），而在HTML的早期版本值则称为定义列表（definition list）。 描述列表的父元素为 dl元素，而其中的每个名/值组，则包含一个或多个dt（description title）元素，以及一个或多个dd（description description）元素。dt 元素用来定义名称或术语，dd元素用来定义名称或术语的值。如：12345678910&lt;dl&gt; &lt;dt&gt;列表标题1：&lt;/dt&gt; &lt;dd&gt;表项描述1-1&lt;/dd&gt; &lt;dd&gt;表项描述1-2&lt;/dd&gt; &lt;dd&gt;表项描述1-3&lt;/dd&gt; &lt;dt&gt;列表标题2：&lt;/dt&gt; &lt;dd&gt;表项描述2-1&lt;/dd&gt; &lt;dd&gt;表项描述2-2&lt;/dd&gt; &lt;dd&gt;表项描述2-3&lt;/dd&gt;&lt;/dl&gt; 描述列表是没有项目符号的。虽然它也是列表，但不能使用CSS的list-style-type属性定义列表项目符号的样式。 2.3 文本语义元素HTML中，根据逻辑来划分和识别文本在网页中所起的作用，给文本添加内涵，即所谓文本语义元素。 除了标题元素之外，HTML还提供了许多其他的元素，来为内容作上标记，以便能够识别它们在网页中所起的作用。其中最常见的有表示文本段落的 p 元素，表示换行的 br 元素等。还有其他鲜为人知的，用来表示非常特殊的网页内容的元素，如，kbd表示由键盘输入的文本。 HTML5中的文本语义元素及其功能描述和示例见表 元素 功能描述及示例 q 定义一段比较短的引用内容（q 是 quote 的缩写），浏览器默认会该引用的内容加上双引号judge said You can drink water from the fish tank but advised against it.```1dfn|定义一个术语（dfn 是 defining instance 的缩写），浏览器会渲染为斜体&lt;br&gt;```The term &lt;dfn&gt;organic food&lt;/dfn&gt; refers to food produced without synthetic chemicals. abbr|定义一个缩写文本（abbr 是 abbreviation 的缩写），建议在 abbr 的 title属性中描述缩写的全称，当鼠标悬停在缩写上，会提示其全称food in Ireland is certified by the","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"HTTP相关知识点","slug":"HTTP相关知识点","date":"2018-07-20T13:49:35.000Z","updated":"2018-07-20T15:21:30.048Z","comments":true,"path":"2018/07/20/HTTP相关知识点/","link":"","permalink":"http://yoursite.com/2018/07/20/HTTP相关知识点/","excerpt":"http 和 https 有何区别？如何灵活使用？常见的HTTP状态码","text":"http 和 https 有何区别？如何灵活使用？常见的HTTP状态码 http 和 https 有何区别？如何灵活使用？http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份 常见的HTTP状态码2开头 （请求成功）表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"浏览器内核知识大科普","slug":"浏览器内核知识大科普","date":"2018-07-20T12:48:27.000Z","updated":"2018-07-25T04:09:53.222Z","comments":true,"path":"2018/07/20/浏览器内核知识大科普/","link":"","permalink":"http://yoursite.com/2018/07/20/浏览器内核知识大科普/","excerpt":"一、Trident ([‘traɪd(ə)nt])二、Gecko ([‘gekəʊ])三、Webkit四、Chromium/Blink五、Presto ([‘prestəʊ])六、移动端七、排版引擎","text":"一、Trident ([‘traɪd(ə)nt])二、Gecko ([‘gekəʊ])三、Webkit四、Chromium/Blink五、Presto ([‘prestəʊ])六、移动端七、排版引擎 一、Trident ([‘traɪd(ə)nt])说起 Trident，很多人都会感到陌生，但提起IE（Internet Explorer）则无人不知无人不晓。 该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。 Trident 实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器(壳浏览器)涌现。 由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核长期一家独大。 但是由于微软长时间没有更新 Trident 内核，则导致了两个后果：一是 Trident 内核曾经几乎与 W3C 标准脱节（2005年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器。Firefox和Opera就是这个时候兴起的。非Trident内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非IE浏览器的浏览效果问题。 补充：IE从版本11开始，初步支持WebGL技术。IE8的JavaScript引擎是Jscript，IE9开始用Chakra，这两个版本区别很大，Chakra无论是速度和标准化方面都很出色。 1.1 Trident内核的常见浏览器有： IE6、IE7、IE8（Trident4.0）、IE9（Trident 5.0）、IE10（Trident 6.0） 360安全浏览器（1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink），360极速浏览器（7.5之前为Trident+Webkit，7.5为Trident+Blink） 猎豹安全浏览器（1.0-4.2版本为Trident+Webkit，4.3及以后版本为Trident+Blink），猎豹极轻浏览器 傲游浏览器（傲游1.x、2.x为IE内核，3.x为IE与Webkit双核） 百度浏览器（早期版本） 世界之窗浏览器（最初为IE内核，2013年采用Chrome+IE内核）、2345浏览器、腾讯TT、淘宝浏览器、采编读浏览器、搜狗高速浏览器（1.x为Trident，2.0及以后版本为Trident+Webkit）、阿云浏览器（早期版本）、瑞星安全浏览器、SlimBrowser、 GreenBrowser、爱帆浏览器（12 之前版本）、115浏览器、155浏览器、闪游浏览器、N氧化碳浏览器、糖果浏览器、彩虹浏览器、瑞影浏览器、勇者无疆浏览器、114浏览器、蚂蚁浏览器、飞腾浏览器、速达浏览器、佐罗浏览器、海豚浏览器（iPhone/iPad/Android）、UC浏览器（Blink内核+Trident内核）等。 1.2 兼容模式其中部分浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。 1.3 EdgeHTML 内核Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 二、Gecko ([‘gekəʊ])2.1 开源内核Gecko(Firefox 内核)：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。 2.2 Firefox 内核事实上，Gecko 引擎的由来跟 IE 不无关系，前面说过 IE 没有使用 W3C 的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape 的一些员工一起创办了 Mozilla，以当时的 Mosaic 内核为基础重新编写内核，于是开发出了 Gecko。不过事实上，Gecko 内核的浏览器仍然还是 Firefox (火狐) 用户最多，所以有时也会被称为 Firefox 内核。此外 Gecko 也是一个跨平台内核，可以在Windows、 BSD、Linux 和 Mac OS X 中使用。 补充：JavaScript引擎是SpiderMonkey。 2.3 Gecko内核常见的浏览器： Mozilla Firefox、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）、K-Meleon 三、Webkit3.1 Safari 浏览器只要提到 Webkit，大多数人立马想到的必然是 Chrome，结果导致如今有了把 webkit 称为 chrome 内核的错误说法，即使 chrome 的内核已经是 blink，其实 Webkit 的祖先是 Safari，也就是苹果系列产品的专属浏览器。 3.2 WebKit 是 KHTML 的分支WebKit 的前身是苹果公司使用 KDE（Linux桌面系统）开发的 KHTML 开源引擎，可以说 WebKit 是 KHTML 的一个开源分支。 3.3 WebKit内核常见的浏览器：傲游浏览器3、 Apple Safari(Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器 四、Chromium/Blink4.1 Chromium Fork webkit2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。chromium fork 自开源引擎 webkit，并提高了 WebKit 的代码可读性和编译速度。 4.2 V8 引擎谷歌公司还研发了自己的 Javascript 引擎，V8，极大地提高了 Javascript 的运算速度。 4.3 Blink 是 WebKit 的分支Google 的 Chromium 项目最初一直使用 WebKit(WebCore) 作为渲染引擎，但由于后来苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发）。 相关新闻2013年4月3日，谷歌在Chromium Blog上发表博客，称将与苹果的开源浏览器核心Webkit分道扬镳，在Chromium项目中研发Blink渲染引擎（即浏览器核心），内置于Chrome浏览器之中。苹果在Safari中采用Webkit核心，并于2005年将Webkit公开为开源软件。谷歌当时采用苹果的Webkit核心打造了Chrome浏览器。Opera也宣布称将会转向Webkit核心，但是谷歌宣布此举后，Opera表示将会跟随谷歌采用其Blink浏览器核心，同时参与了Blink的开发。谷歌转向研发Blink浏览器内核意义重大，谷歌此举欲降低Webkit即苹果在浏览器市场的影响力。截止2012年底，Webkit浏览器内核占总浏览器市场份额约40%。谷歌解释称，Chromium多处理架构系统与其他Webkit浏览器很不相同。谷歌工程师Adam Barth在博客中表示，随着浏览器的发展，苹果的Webkit已经不能满足用户需求，同时也有碍浏览器技术的创新步伐。但是他也表示，谷歌自主研发Blink内核绝非易事，但是新内核将会提升整个开源网络生态系统的机能。谷歌做出此举之际，Mozilla与三星也达成合作协议开发“下一代”浏览器渲染引擎Servo。 五、Presto ([‘prestəʊ])5.1 Opera 浏览器Presto 是 Opera 自主研发的渲染引擎，Opera12.17及更早版本曾经采用的内核，现已停止开发并废弃，该内核在2003年的Opera7中首次被使用，该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。 实际上这是一个动态内核，与前面几个内核的最大的区别就在脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。此外该内核在执行Javascrīpt的时候有着最快的速度，根据在同等条件下的测试，Presto内核执行同等Javascrīpt所需的时间仅有Trident和Gecko内核的约1/3（Trident内核最慢，不过两者相差没有多大），本文的其中一个修改者认为上述测试信息过于老旧且不完整，因为他曾做过的小测试显示Presto部分快部分慢，各内核总体相当。那次测试的时候因为Apple机的硬件条件和普通PC机不同所以没有测试WebCore内核。只可惜Presto是商业引擎，使用Presto的除开Opera以外，只剩下NDSBrowser、WiiInternet Channle、Nokia 770网络浏览器等，这很大程度上限制了Presto的发展。 然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎。 在 Chrome 于 2013 年推出 Blink 引擎之后，Opera 也紧跟其脚步表示将转而使用 Blink 作为浏览器核心引擎。 六、移动端移动端的浏览器内核主要说的是系统内置浏览器的内核。目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。 1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。 2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android 4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。 3、Windows Phone 8 系统浏览器内核是 Trident。 七、排版引擎WebCoreWebCore是苹果公司开发的排版引擎，它是在另外一个排版引擎“KHTML”的基础上而来的。使用WebCore的主要有Safari，此外还有OmniWeb、Shiira、Swift等。Safari现支持Windows，但效果不如iOS上的。 KHTMLKHTML，是HTML网页排版引擎之一，由KDE所开发。KDE系统自KDE2版起，在档案及网页浏览器使用了KHTML引擎。该引擎以C++编程语言所写，并以LGPL授权，支援大多数网页浏览标准。由于微软的Internet Explorer的占有率相当高，不少以FrontPage制作的网页均包含只有IE才能读取的非标准语法，为了使KHTML引擎可呈现的网页达到最多，部分IE专属的语法也一并支援。KHTML拥有速度快捷的优点，但对错误语法的容忍度则比Mozilla产品所使用的Gecko引擎小。苹果电脑于2002年采纳了KHTML，作为开发Safari浏览器之用，并发布所修改的最新及过去版本源代码。后来发表了开放源代码的WebCore及WebKit引擎，它们均是KHTML的衍生产品，在开发网站列出引擎改变内容，并会传回至KDE计划。由于两个衍生产品各走不同路线，使两者源代码偏离，在与KDE交换更新会出现困难。其中一个原因，是苹果在对外公开源代码之前，以一年时间编修他们的KHTML。另外，苹果传送更新至KDE计划的方式，多是一口气把大量改动一起传送，KDE在整理资料也出现一定的困难，及后苹果表示会以CVS格式来传送。再者，苹果所作出的改动包括Mac OS X系统独有的事物，如Objective-C、KWQ等，在Linux及KHTML是没有的。但KDE方面仍透过这些改动，为KHTML加入新功能及加快其排版速度。基于KHTML内核的内核：WebKit、WebCore。","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"关于居中","slug":"关于居中","date":"2018-06-04T02:00:18.000Z","updated":"2018-07-23T15:12:08.479Z","comments":true,"path":"2018/06/04/关于居中/","link":"","permalink":"http://yoursite.com/2018/06/04/关于居中/","excerpt":"水平居中 垂直居中 水平垂直居中","text":"水平居中 垂直居中 水平垂直居中 水平居中行内元素给其父元素设置 text-align:center 块级元素给该元素设置 margin:0 auto 子元素包含 float:left 属性则可让父元素宽度设置为fit-content,并且配合margin, 做如下设置123456.parent &#123; width: -webkit-fit-content; width: -moz-fit-content; width: fit-content; margin: 0 auto;&#125; 元素宽度不定1.利用flex布局（2009年版），父元素设置1234567891011121314151617.parent &#123; display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center;&#125; 2.利用flex布局（2012年版），子元素设置1234.son &#123; display: flex; justify-content: center;&#125; 3.利用CSS3中transform属性，子元素设置12345.son &#123; position: absolute; transform: translate(-50%,0); left: 50%;&#125; 元素宽度固定1.利用绝对定位，margin-left负值，子元素设置123456.son &#123; position: absolute; width:固定; left: 50%; margin-left: -0.5宽度;&#125; 2.利用绝对定位，left:0;right:0;margin:0 auto;，子元素设置1234567.son &#123; position: absolute; width:固定; left: 0; right: 0; margin: 0 auto;&#125; 垂直居中单行文本则可设置 line-height 等于其父元素高度。 行内块级元素利用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央12345678.parent::after, .son &#123; display: inline-block; vertical-align: middle;&#125;.parent::after &#123; content: ''; height: 100%;&#125; 元素高度不定1.利用 vertical-align 属性（其只有在父层为 td 或者 th 时， 才会生效，对于其他块级元素，例如 div、p 等，默认情况是不支持的。）1234567.parent &#123; display: table;&#125;.son &#123; display: table-cell; vertical-align: middle;&#125; 优点：元素高度可以动态改变，不需再CSS中定义， 如果父元素没有足够空间时，该元素内容也不会被截断。 2.利用flex布局（2009年版），父元素设置12345.parent &#123; display: box; box-orient: vertical; box-pack: center;&#125; 优点：实现简单，扩展性强。缺点：兼容性差，不支持IE。 3.利用flex布局（2012年版），父元素设置1234.parent &#123; display: flex; align-items: center;&#125; 优点：内容块的宽高任意，优雅的溢出。可用于更复杂高级的布局技术中。缺点：IE8/IE9不支持，需要浏览器厂商前缀。 4.利用CSS3中transform属性。123456789.parent &#123; position:relative;&#125;.son &#123; top:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; 优点：代码量少。缺点：IE8不支持, 属性需要追加浏览器厂商前缀，可能干扰其他 transform 效果， 某些情形下会出现文本或元素边界渲染模糊的现象。 元素高度固定1.利用绝对定位，margin-top负值123456789.parent &#123; position: relative;&#125;.son&#123; position: absolute; top: 50%; height: 固定; margin-top: -0.5高度;&#125; 优点：适用于所有浏览器。缺点：父元素空间不够时，子元素可能不可见(当浏览器窗口缩小时，滚动条不出现时)。如果子元素设置了overflow:auto，则高度不够时，会出现滚动条。 2.利用绝对定位，top:0;bottom:0;margin:0 auto;1234567.son &#123; position: absolute; height: 固定; top: 0; bottom: 0; margin:auto 0;&#125; 优点：简单缺点：没有足够空间时，子元素会被截断, 但不会有滚动条。 总结水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣 ① text-align:center; ② margin:0 auto; ③ width:fit-content; ④ 盒模型 ⑤ flex ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法 垂直居中, 共提供了8种方法. ① 单行文本, line-height ② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现 ③ vertical-align ④ 盒模型 ⑤ flex ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法其中，盒模型，flex，transform，绝对定位，这几种方法同时适用于水平居中和垂直居中。 水平垂直居中固定高度1.利用height + line-height的方式，设置同样的值，配合text-align的使用，即可实现文本的水平垂直居中对齐。1&lt;div class=\"container\"&gt;Hello World！&lt;/div&gt; 1234567.container &#123; width: 300px; height: 300px; line-height: 300px; text-align: center; border: 1px solid red;&#125; 缺点：固定高度，无法实现两行文本的垂直居中对齐。 2.使用绝对定位的方法，配合margin负值使用。1&lt;div class=\"container\"&gt;Hello World！&lt;/div&gt; 12345678910.container &#123; position: absolute; width: 300px; height: 300px; left: 50%; top: 50%; margin-left: -150px; margin-top: -150px; border: 1px solid red;&#125; 可以使用CSS3的calc函数简化上面的CSS代码12345678.container &#123; position: absolute; width: 300px; height: 300px; left: calc(50% - 150px); top: calc(50% - 150px); border: 1px solid red;&#125; 缺点：固定高度，高度无法自适应内容。元素脱离文档流。 3.使用绝对定位的方法，配合 margin:auto 使用。1&lt;div class=\"container\"&gt;Hello World！&lt;/div&gt; 1234567891011.container &#123; width: 200px; height: 200px; background: green; position:absolute; left: 0; top: 0; bottom: 0; right: 0; margin: auto;&#125; 缺点：固定高度，高度无法自适应内容。元素脱离文档流。 4.添加空标签的方式，并且使该元素浮动，脱离文档流，避免影响其他元素的布局。123456&lt;div class=\"space\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt; hello world！ &lt;/div&gt;&lt;/div&gt; 123456789101112.space &#123; float: left; height: 50%; margin-top: -150px;&#125;.container &#123; clear: both; height: 300px; border: 1px solid red; position: relative;&#125; 缺点：这种方式下的垂直居中需要固定高度，无法实现内容自适应高度。同时，出现多余的空div元素。 高度自适应1.CSS3中有transform属性，此属性下有一个translate移动函数，此函数接受两个参数。如果两个参数都为百分比值，此时会基于自身宽度和高定进行移动。此函数移动的机制同position:relative相似。1&lt;div class=\"container\"&gt;Hello World！&lt;/div&gt; 1234567.container &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); // 自身宽度和高度的一半 border: 1px solid red;&#125; 优点：无需定高度。高度随内容自适应。缺点：元素脱离文档流。如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视口裁切掉。 2.使用margin，配合vh来实现。CSS中存在一个vh（视口高度）,也就相当于DOM中document.body.clientHeight或者document.documentElement.clientHeight的高度，1vh=1%，即1vh等于视口高度的1%。1&lt;div class=\"container\"&gt;Hello World！&lt;/div&gt; 123456.container &#123; width: 300px; margin: 50vh auto 0; transform: translateY(-50%); border: 1px solid red;&#125; 3.使用flex布局（伸缩布局盒模型，也叫弹性布局盒模型）。12345&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt; &lt;p&gt;hello world!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678.container &#123; display: flex; height: 100vh;&#125;.inner &#123; margin: auto;&#125; 当我们使父元素display: flex时，margin: auto不仅可以水平居中，也能够实现垂直居中。这是因为auto外边距会平分水平或垂直方向上的额外空间。 可以使用justify-content: center来定义弹性项目主轴的对齐方式（水平方向），align-items: center来定义弹性项目侧轴的对齐方式（垂直方向）。 12345&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456.container &#123; display: flex; justify-content: center; align-items: center; height: 100vh;&#125; 4.使用display: table来模拟表格，并给子元素设置display: table-cell，让其成为表格的某个单元格，同时设置vertical-align: middle，即可实现垂直居中布局。12345&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt; hello world！ &lt;/div&gt;&lt;/div&gt; 1234567891011.container &#123; display: table; /* 让div以表格的形式渲染 */ width: 100%; border: 1px solid red;&#125;.inner &#123; display: table-cell; /* 让子元素以表格的单元格形式渲染 */ text-align: center; vertical-align: middle;&#125; 参考文章louis-16种方法实现水平居中垂直居中TigerZhang-CSS(3)多种方法实现水平垂直居中效果","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hexo日常使用","slug":"Hexo日常使用","date":"2018-06-02T09:02:29.000Z","updated":"2018-07-20T13:39:37.432Z","comments":true,"path":"2018/06/02/Hexo日常使用/","link":"","permalink":"http://yoursite.com/2018/06/02/Hexo日常使用/","excerpt":"主题设置 常用指令","text":"主题设置 常用指令 主题设置更换为yilia主题。 安装主题MyBlog\\hexo\\themes文件夹下，右键→Git Base Here输入指令： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia修改站点配置文件修改站点目录中的_config.yml文件：123456theme: yilia //启用yilia主题，默认为landscape# Sitetitle: Ming-dm blog //网站标题author: Ming-dm //作者language: zh-CN //语言 修改themes/yilia/_config.yml文件：可根据自己的需求，对界面进行修改123456favicon: /favicon.png网站图标地址：MyBlog\\hexo\\themes\\yilia\\source#你的头像urlavatar: /blue.jpg头像地址：MyBlog\\hexo\\themes\\yilia\\source 点击所有文章，发现有缺失模块，根据提示在站点目录下执行指令：npm i hexo-generator-json-content --save在站点配置文件_config.yml最后添加配置：123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 运行测试1234567hexo clean //清空之前主题hexo g //生成静态文件hexo s //在本地运行hexo d //发布到github的page上 更新主题12cd themes/yiliagit pull 常用指令生成静态页面hexo generatehexo g 本地预览hexo serverhexo s 新建文章hexo new post &quot;title&quot;文件路径：MyBlog\\hexo\\source_posts下 文章基本设置123456---title: Hexo日常使用date: 2018-06-02 17:02:29tags: #标签- hexo--- 新建页面hexo new page &quot;title&quot;文件路径：MyBlog\\hexo\\source下 创建标签页面hexo new page tags12345---title: tagsdate: 2018-6-02 18:01:24type: \"tags\"--- 创建分类页面hexo new page categories12345---title: categoriesdate: 2018-6-02 18:01:24type: \"categories\"--- 部署并生成hexo d -g 清楚生成的文件和缓存hexo clean","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2018-06-01T03:15:34.000Z","updated":"2018-06-02T11:53:31.245Z","comments":true,"path":"2018/06/01/Markdown基本语法/","link":"","permalink":"http://yoursite.com/2018/06/01/Markdown基本语法/","excerpt":"序言：Markdown的理念是让文档更容易读、写和随意改。因此，它是一种可以使用普通文本编辑器编写的标记语言，通过简单的语法使得普通文本内容具有一定的格式。","text":"序言：Markdown的理念是让文档更容易读、写和随意改。因此，它是一种可以使用普通文本编辑器编写的标记语言，通过简单的语法使得普通文本内容具有一定的格式。 小书匠概要：小书匠编辑器是一款专为Markdown写作设计的编辑器。主要功能： 多种编辑模式 多种编辑器实现 多种主题选择 丰富的语法支持 代码块文字格式语法 第三方同步 支持evernote，印象笔记 强大的文件管理功能 发布功能 邮件发送功能 sourceMap对照功能 ppt ppt跨屏演示 pdf预览 typewrite scrolling autocomplete 和 snippets 功能 常用语法一、标题总共六级标题，有两种实现语法。 [ # ] 后跟空格加标题文字 1234567示例：# 这是一级标签## 这是二级标签### 这是三级标签#### 这是四级标签##### 这是五级标签###### 这是六级标签 效果为: 这是一级标签这是二级标签这是三级标签这是四级标签这是五级标签这是六级标签 标题文字下一行跟大于一个的=或-(似只有一级和二级标题) 12345示例：这是一级标题==========这是二级标题--- 效果为： 这是一级标题 这是二级标题 二、字体 加粗左右分别用两个 [ * ] 号包围需要加粗的文字 斜体左右分别用一个 [ * ] 号包围需要倾斜的文字 斜体加粗左右分别用三个 [ * ] 号包围需要倾斜加粗的文字 删除线左右分别用两个 [ ~~ ] 号包围需要加删除线的文字 12345示例：**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果为： 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 三、列表 无序列表在文本前面加 [ * ] 号或者 [ + ]号 或者 [ - ] 号，符号和文字之间有一个空格。在 [ * ] 号 前加两个空格键或者一个 tab 键就可以产生一个子列表。 1234567示例：* 列表内容+ 列表内容- 1 - 1.1 - 1.1.1 - 1.1.1.1 效果为： 列表内容 列表内容 1 1.1 1.1.1 1.1.1.1 有序列表在文本前加 [ 字母. ] 或 [ 数字. ] 即可生成一个有序列表。注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。 123456示例：1. 项目12. 项目23. 项目3 1. 项目3.1 2. 项目3.2 效果为： 项目1 项目2 项目3 项目3.1 项目3.2 四、链接1234567[链接名称](链接地址)[链接名称][1][1] : 链接地址示例：行内式[百度](http://baidu.com) 效果为：百度 五、图片1234567![名称](链接地址)![名称][1][1] : 链接地址示例：行内式![小书匠](http://xiaoshujiang.com/favicon.ico) 效果为：行内式 六、引用1234567891011示例：&gt; 第一行引用文字&gt; 第二行引用文字 嵌套引用：&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用&gt; &gt; &gt; &gt; 四级引用&gt; &gt; &gt; &gt; &gt; 五级引用&gt; &gt; &gt; &gt; &gt; &gt; 六级引用 效果为： 第一行引用文字第二行引用文字 一级引用 二级引用 三级引用 四级引用 五级引用 六级引用 七、水平线12示例：*** 效果为： GFM扩展语法表格1234567891011121314151617示例：First Header | Second Header------------- | -------------Content Cell | Content CellContent Cell | Content Cell表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 效果为：First Header | Second Header————- | ————-Content Cell | Content CellContent Cell | Content Cell 表头 表头 表头 内容 内容 内容 内容 内容 内容 增强型表格12345678910示例：|First Header | Second Header |||First Header | Second Header | Third Header||------------- | -------------|-------------|表身1Content Cell | Merge Content Cell||Content Cell | Content Cell| Content Cell|表身2Content Cell | Merge Content Cell||Content Cell | Content Cell| Content Cell|[表格标题] 效果为：|First Header | Second Header |||First Header | Second Header | Third Header||————- | ————-|————-|表身1Content Cell | Merge Content Cell||Content Cell | Content Cell| Content Cell| 表身2Content Cell | Merge Content Cell||Content Cell | Content Cell| Content Cell|[表格标题] 代码行内代码12示例：`var x = \"hello world\"` 效果为：var x = &quot;hello world&quot; 块代码12345示例：```javascriptvar a = \"hello world\";var b = \"good luck\";``` 效果为：12var a = \"hello world\";var b = \"good luck\"; HTML1&lt;div class=\"hey\"&gt;Hello world&lt;/div&gt; 支持的html标签 扩展语法目录1[toc] 待办事项1234示例：- [ ] 未完成事项- [ ] 未完成事项- [x] 完成事项 效果为： 未完成事项 未完成事项 完成事项 转义12345678910示例：* \\\\* \\`* \\~* \\** \\_* \\-* \\+* \\.* \\! 效果为： \\ ` ~ * _ - + . ! 特殊字符1234567&amp;nbsp;&amp;lt;&amp;gt;&amp;amp;&amp;copy;&amp;reg;&amp;sect; 效果为：&nbsp;(空格)&lt;&gt;&amp;(和号)&copy;(版权)&reg;(注册商标)&sect;(小节) 参考文献Mou凌云之翼高鸿祥","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"使用Hexo+Github搭建个人博客","slug":"使用Hexo-Github搭建个人博客","date":"2018-06-01T03:00:45.000Z","updated":"2018-06-02T11:43:21.314Z","comments":true,"path":"2018/06/01/使用Hexo-Github搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/06/01/使用Hexo-Github搭建个人博客/","excerpt":"前言：电脑系统Windows 8.1，64位 主要步骤 系统环境配置 安装Hexo Hexo初始化 部署到Github","text":"前言：电脑系统Windows 8.1，64位 主要步骤 系统环境配置 安装Hexo Hexo初始化 部署到Github 系统环境配置 安装Git 安装Node.js 安装GitGit官网Git安装教程 安装Node.jsNode.js官网Node.js安装教程 安装Hexo选一个自己喜欢的地方，创建个文件夹(例如我创建了一个命名为MyBlog的文件夹)。进入文件夹，右键空白区域→Git Bash Here。输入指令： npm install -g hexo-cli 开始安装Hexo。安装完成后，继续输入 hexo ，按下回车，若输出提示信息，则安装成功。或输入 hexo -v ，检查Hexo是否安装成功。 Hexo初始化若Hexo安装成功，输入 hexo init hexo 来对Hexo进行初始化。初始化所产生的文件都会在当前的目录MyBlog之下。初始化成功，在最后一行会显示 INFO&nbsp;Start&nbsp;blogging&nbsp;with &nbsp;Hexo&nbsp;!。 然后在MyBlog文件夹下会看到产生了一个hexo文件夹，这个就是初始化Hexo之后产生的。 （若不是直接打开Git Bash，此时git的工作目录将是/c/Users/你的用户名/。然后如果你这时输入命令对Hexo进行安装和初始化，就会把Hexo初始化到/c/Users/你的用户名/之下。为了便于管理，还是建议建立一个专门的文件夹，在这个文件夹对Hexo进行初始化。） 输入 cd hexo 命令进入到MyBlog下的hexo目录中，然后输入 npm install 安装依赖文件。输入 hexo generate （或简化的命令 hexo g )，生成博客网页资源文件。输入 hexo server （或简化的命令 hexo s ) ，在本地对形成的博客静态页面进行调试。此时在最后一行会显示 Hexo&nbsp;is&nbsp;running&nbsp;at&nbsp;http://localhost:4000/ .打开浏览器，输入地址localhost:4000会打开本地的博客预览页面。如果能看到默认的博客页面，说明软件都正确安装好了。 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们 ctrl+c 停止服务器，接着输入 hexo server -p 端口号 来改变端口号。 部署到Github 注册、登陆Github账号 创建Github pages 生成、配置ssh key 配置deployer（编辑站点配置文件） 将本地hexo项目托管到Github 注册、登陆Github账号Github注册教程 创建Github pagesNew repository→Repository name（必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。)→勾选Initialize this repository with a README。点击建好的项目右侧settings按钮，向下拉到GitHub Pages，会看到有个网址，访问它，会发现该项目已经被部署到网络上，并能够通过外网访问。 生成、配置ssh key输入 cd ~/.ssh ，检查是否由.ssh的文件夹。输入 ls ，列出“id_rsa” 以及“id_rsa.pub”说明存在。 若没有，是第一次使用git的话在MyBlog文件夹下，右键→Git Base Here。设置Git的user name和email12345678910111213设置用户名和邮箱git config --global user.name \"xxxx\" 设置用户名git config --global user.email \"xxxx\" 设置邮箱git config user.name 查看用户名git config user.email 查看邮箱git config --global user.name \"xxxx\" 修改用户名git config --global user.email \"xxxx@xxx.com\" 修改邮箱 在git bash中输入:ssh-keygen -t rsa -C &quot;你的github注册邮箱&quot; 连续三个回车，生成密钥。（中间会让你填写key文件名，可以不用填，直接回车得到默认文件名的key，建议默认名即可。中途还会让你输入一个密码，这个是以后在本机部署文件到github时用到的，不是github登陆密码，可填可不填。)之后会在上述.ssh文件夹中产生两个文件，“id_rsa” 以及“id_rsa.pub”。 用文本编辑器打开id_rsa.pub，全选复制到剪贴板，点击Github右上方头像→settings→SSH and GPG keys →New SSH key。title自定义，key栏中就把刚才复制的内容粘贴上去。点击下面的按钮，add SSH key，密码确认就行了。 输入 ssh -T git@github.com ，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了。 配置deployer（编辑站点配置文件）打开MyBlog/hexo，用文本编辑器打开_config.yml文件。在最后的# Deployment一段中作如下修改和添加：1234deploy: type: git repository: git@github.com:你的Github帐户名/你的Github帐户名.github.io.git branch: master 注意站点配置文件和主题配置文件中每个变量的冒号后都有一个空格，同级变量的缩进量要相等。（hexo文件夹下的_config.yml和hexo\\themes\\主题名称\\中的_config.yml分别成为站点配置文件和主题配置文件。） 安装hexo-deployer-git插件：git bash中，输入命令npm install hexo-deployer-git --save 将本地hexo项目托管到Github按顺序执行命令如下：hexo clean 每次更换主题后亦需要使用此命令，简写是 hexo clhexo generator 简写是hexo g（然后此时可以先执行hexo s –debug，打开浏览器，在本地查看过效果，确定满意之后，再用以下这一条命令来将本地博客项目部署到github。）hexo deploy 简写是hexo d或hexo d -g完成之后，稍等一下，在浏览器打开“你的用户名.github.io”应该就能够看到由hexo生成的博客了。 参考文章利用github pages 和Hexo搭建博客（Windows环境）使用Hexo+Github一步步搭建属于自己的博客（基础）","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]}]}